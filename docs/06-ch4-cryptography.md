# 第四章：密码学

以太坊的基础技术之一是密码学（Cryptography），它是计算机安全领域广泛应用的一个数学分支。在希腊语中，Cryptography 的意思是“秘密书写”（secret writing），但密码学的研究范畴远不止秘密书写，后者通常被称为加密（Encryption）。

例如，密码学还可以用于在不泄露秘密的情况下证明对秘密的知晓（如通过数字签名 / Digital Signature），或者证明数据的真实性（如通过数字指纹，也称为哈希 / Hashes）。这些类型的密码学证明是维持以太坊平台（以及所有区块链系统）运行的关键数学工具，同时也广泛应用于以太坊应用程序中。

请注意，截至本书出版时，以太坊协议的任何部分都不涉及加密（Encryption）；也就是说，与以太坊平台的所有通信以及节点之间的通信（包括交易数据）都是未加密的，任何人（必然地）都可以读取。这样做是为了让每个人都能验证状态更新的正确性，从而达成共识。

未来，诸如零知识证明（Zero-Knowledge Proofs）和全同态加密（Homomorphic Encryption）等先进的密码学工具将投入使用，它们允许在保持共识的同时，将一些加密计算记录在区块链上；虽然已经为此做好了准备，但这些技术尚未完全部署。

在本章中，我们将介绍以太坊中使用的一些密码学知识，即非对称加密或公钥密码学（Public Key Cryptography, PKC），它以私钥和地址的形式用于控制资金的所有权。

## 密钥与地址 (Keys and Addresses)

正如本书前面所述，以太坊有两种不同类型的账户：外部账户（**EOAs**）和合约账户（**Contracts**）。**EOAs** 对以太币（**Ether**）的所有权是通过数字**私钥**（Private Keys）、以太坊**地址**（Addresses）和数字**签名**（Signatures）建立的。

私钥是用户与以太坊进行所有交互的核心。事实上，账户地址是直接由私钥派生出来的：一个私钥唯一地决定了一个以太坊地址，这也通常被称为一个账户。

在以太坊系统中，私钥绝不会被直接使用；它们从不在以太坊上传输或存储。也就是说，私钥必须保持私密，绝不能出现在发送给网络的任何消息中，也不应存储在链上。在以太坊系统中传输和存储的只有账户地址和数字签名。

对资金的访问和控制是通过数字签名实现的，而数字签名同样是使用私钥创建的。以太坊交易必须包含有效的数字签名才能被纳入区块链。任何持有私钥副本的人都拥有对相应账户及其持有的以太币的控制权。只要用户妥善保管私钥，以太坊交易中的数字签名就能证明资金的真实所有者，因为签名证明了对私钥的持有权。

在基于公钥加密（**PKC**）的系统中（如以太坊），密钥成对出现，由一个**私钥（秘密密钥）**和一个**公钥**组成。你可以将公钥类比为银行账号，将私钥类比为秘密取款密码（**PIN**）；后者提供对账户的控制权，而前者用于向他人标识该账户。以太坊用户很少能直接看到私钥本身；在大多数情况下，私钥（以加密形式）存储在特殊文件中，并由以太坊钱包软件进行管理。

在以太坊交易的支付部分，收款人由以太坊地址表示，其用法与银行转账中的受益人账户明细相同。正如我们稍后将详细看到的，**EOA** 的以太坊地址是由密钥对中的公钥部分生成的。然而，并非所有以太坊地址都代表公钥-私钥对；它们也可以代表合约。我们将在第 7 章看到，合约并不受私钥支持。

在这一章接下来的部分中，我们将：

* 深入探讨密码学的基础，并探索其在以太坊中的数学原理。
* 研究密钥生成、存储和管理的过程。
* 审阅私钥、公钥和地址所使用的各种编码格式。
* 调研验证者密钥（**Validator Key**）密码学和 **KZG** 承诺方案，这些代表了以太坊密码学基础设施的最新更新。

## 公钥密码学 (PKC) 与加密货币 (Cryptocurrency)

**公钥密码学**（PKC，也称为**非对称加密** / Asymmetric Cryptography）是现代信息安全的基石。由 Martin Hellman、Whitfield Diffie 和 Ralph Merkle 在 20 世纪 70 年代首次发表的**密钥交换协议**（Key exchange protocol）是一项划时代的突破，它引发了公众对密码学领域的第一次大规模关注。在 20 世纪 70 年代之前，强大的密码学知识一直被政府视为最高机密。

**PKC** 使用唯一的密钥来保护信息。这些密钥基于具有特殊性质的数学函数：**正向计算容易，但逆向推导极难**。基于这些函数，密码学能够创建受数学定律保护的数字秘密和不可伪造的数字签名。

例如，将两个巨大的质数相乘是非常简单的。但是，如果给定这两个大质数的乘积，要找到它们的质因数却极其困难（这个问题被称为**质因数分解** / Prime factorization）。假设我们给出一个数字 `8,018,009` 并告诉你它是两个质数的乘积，那么你寻找这两个质数的难度，要远大于我将它们相乘得出该结果的难度。

如果已知某些秘密信息，其中一些数学函数可以很容易地被求逆。在上述例子中，如果我告诉你其中一个质因数是 `2,003`，你就可以通过简单的除法轻松找到另一个：`4003`。这类函数通常被称为**陷门函数**（Trapdoor functions），因为除非获得可以作为逆转函数“捷径”的秘密信息，否则它们极难求逆。

密码学中一类更有用的高级数学函数是基于**椭圆曲线**（Elliptic Curve）的算术运算。在椭圆曲线算术中，模素数乘法（Multiplication modulo a prime）很简单，但其逆运算——除法——在实际操作中几乎是不可能的。这被称为**离散对数问题**（Discrete logarithm problem），且目前尚无已知的“陷门”。**椭圆曲线密码学**（ECC）广泛应用于现代计算机系统，也是以太坊（以及其他加密货币）使用私钥和数字签名的基础。

> [!Note]
> 如果您有兴趣阅读更多关于现代密码学中使用的数学函数，请参考以下资源：
> * [密码学](https://oreil.ly/wOT_b) (Cryptography)
> * [陷门函数](https://oreil.ly/WrxXr) (Trapdoor function)
> * [质因数分解](https://oreil.ly/rxAnN) (Prime factorization)
> * [离散对数](https://oreil.ly/pj8PD) (Discrete logarithm)
> * [椭圆曲线密码学](https://oreil.ly/RP2QF) (Elliptic curve cryptography)


在以太坊中，我们使用 **PKC** 来创建本章一直在讨论的公私钥对。它们被视为一个“对”，是因为公钥是从私钥派生出来的。它们共同代表了一个以太坊账户：公钥提供了一个公开可访问的账户标识（地址），而私钥则提供了对账户中以太币访问权限的私密控制，以及在使用智能合约时所需的任何身份验证。私钥通过作为创建数字签名所需的唯一信息来控制访问权限，而签署交易以动用账户资金必须提供数字签名。数字签名也用于验证合约所有者或用户，我们将在第 7 章看到这一点。

> [!Tip]
> 在大多数钱包实现中，为了方便，私钥和公钥是作为密钥对存储在一起的。然而，由于公钥可以从私钥轻松计算出来，因此仅存储私钥也是可行的。

数字签名可以为任何消息创建。对于以太坊交易，交易细节本身就被用作“消息”。密码学的数学原理——在这里是椭圆曲线密码学——提供了一种将消息（即交易细节）与私钥结合的方法，从而产生一个只有通过私钥知识才能生成的代码。这个代码就被称为**数字签名**。

请注意，以太坊交易本质上是访问具有特定以太坊地址的特定账户的请求。当交易被发送到以太坊网络以转移资金或与智能合约交互时，必须附带由该以太坊地址对应的私钥创建的数字签名。椭圆曲线数学意味着任何人都可以通过检查数字签名是否与交易细节以及请求访问的以太坊地址匹配，来验证交易的有效性。**验证过程完全不涉及私钥**；私钥始终保持私密。然而，验证过程可以确凿无疑地判定，该交易只能来自于持有与该以太坊地址背后的公钥相对应的私钥的人。这就是 **PKC** 的“魔力”所在。

> [!Tip]
> 以太坊协议本身不包含任何加密——所有作为以太坊网络运行的一部分发送的消息（必然地）都可以被所有人读取。因此，私钥仅用于创建用于交易身份验证的数字签名。


## 私钥 (Private Keys)

私钥本质上只是一个随机选取的数字。对私钥的所有权和控制权是用户控制相关以太坊地址下所有资金，以及访问授权该地址的合约的根基。私钥用于创建支出以太币所需的签名，以此证明交易中所用资金的所有权。私钥必须始终保持机密，因为将其泄露给第三方等同于将该私钥保护下的以太币和合约控制权拱手相让。私钥还必须进行备份，并防止意外丢失。如果私钥丢失，它将无法找回，其保护下的资金也将永远丢失。

> [!Tip]
> 以太坊私钥就是一个数字。随机选取私钥的一种方法是直接使用硬币、铅笔和纸：抛 256 次硬币，你就得到了一个可以在以太坊钱包中使用的随机私钥的二进制位（大概可以，详见下文）。随后即可从该私钥生成公钥和地址。

生成密钥的第一步也是最重要的一步，是寻找一个安全的**熵**（Entropy）源，即随机性来源。创建一个以太坊私钥本质上涉及在 1 到 $2^{256}$ 之间选取一个数字。只要这个数字是不可预测且非确定性的，你使用什么具体方法来选取它并不重要。以太坊软件使用底层操作系统的**随机数生成器**（RNG）来产生 256 位随机位。通常，操作系统的 **RNG** 是通过人为的随机源进行初始化的，这就是为什么你可能会被要求随意移动几秒钟鼠标，或在键盘上随机敲击按键。另一种替代方案可以是计算机麦克风通道上的宇宙辐射噪声。

更准确地说，私钥可以是非0数字到略小于 $2^{256}$ 的任意非零数字——这是一个巨大的 78 位数字，约为1.158 × 10^77 。这个精确数字的前 38 位与 $2^{256}$ 相同，它被定义为以太坊所使用的椭圆曲线的**阶**（Order）。为了创建私钥，我们随机选取一个 256 位的数字，并检查它是否在有效范围内。在编程层面，这通常是通过将更长的随机位字符串（采集自密码学安全的随机源）输入到 **Keccak-256** 或 **SHA-256** 等 256 位哈希算法中来实现的，这两种算法都能方便地生成一个 256 位的数字。如果结果在有效范围内，我们就得到了一个合适的私钥。否则，我们只需换一个随机数再次尝试。

> [!Note]
> 以太坊私钥空间的大小————是一个超乎想象的天文数字。它在十进制下大约是10^77，即一个 78 位的数字。作为对比，可见宇宙估计包含10^80个原子。因此，私钥的数量几乎多到可以给宇宙中的每个原子分配一个以太坊账户。如果你随机选取一个私钥，没有任何可行的方法让别人猜到它或撞巧选中它。

请注意，生成私钥的过程是离线的；它不需要与以太坊网络进行任何通信，事实上也不需要与任何人通信。因此，要选取一个别人永远选不到的数字，它必须是真正随机的。如果你自己手动挑选数字，别人也尝试到这个数字（并卷走你的以太币）的概率就太高了。使用拙劣的 **RNG**（如大多数编程语言中的伪随机函数 `rand`）甚至更糟，因为它是显而易见且极易复现的。就像在线账户的密码一样，私钥必须是不可猜测的。幸运的是，你永远不需要记住你的私钥，所以你可以采用选取私钥的最佳方法：**真随机性**（True randomness）。

> [!Warning]
> 不要编写自己的代码来创建随机数，也不要使用编程语言提供的“简单”**RNG**。请注意，浏览器钱包中基于 **JavaScript** 的 **RNG** 可能是不安全的，除非有操作系统熵源的支持。至关重要的是，你必须使用**密码学安全的伪随机数生成器**（CSPRNG），并配合具有足够熵源的种子。请仔细研读你所选随机数库的文档，确保其在密码学上是安全的。**CSPRNG** 库的正确实现对密钥的安全性至关重要。

以下是一个十六进制格式显示的随机生成私钥（256 位显示为 64 个十六进制字符，每个字符代表 4 位）：
```
f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
```

## 公钥 (Public Keys)

以太坊公钥是椭圆曲线上的一个点，这意味着它是一组满足椭圆曲线方程的X轴和Y轴坐标。

简单来说，以太坊公钥是由两个数字拼接而成的。这两个数字通过一种单向计算从私钥生成。这意味着如果你拥有私钥，计算公钥是轻而易举的；但你无法从公钥反推回私钥。

> [!Warning]
> 数学高能预警！请保持冷静。如果你在接下来的段落中感到困惑，可以跳过后续几小节。市面上有许多工具和库可以帮你完成这些复杂的数学计算。

公钥是通过**椭圆曲线乘法**（Elliptic Curve Multiplication）从私钥计算得出的，这种运算在实际操作中是不可逆的：`K = k * G`。其中`k`是私钥，`G`是一个被称为**生成点**（Generator Point）的常数点，`K`是生成的公钥，而`*`是特殊的椭圆曲线“乘法”运算符。请注意，椭圆曲线乘法不同于普通的乘法。除了在函数特性上与普通乘法有相似之处外，两者基本没有共同点。例如，其逆运算（在普通数字中是除法）被称为“求解离散对数”——即在已知`K`的情况下计算`k`。其难度相当于尝试`k`的所有可能值（这种暴力搜索所需的时间可能超过宇宙的寿命）。

通俗地说，椭圆曲线上的算术与“常规”整数算术完全不同。点（G）可以乘以一个整数（k）得到另一个点（K）。但由于不存在“除法”运算，因此不可能通过简单地用公钥 K “除以”点 G 来计算出私钥 k。这就是我们在前文“PKC 与加密货币”一节中提到的单向数学函数。

> [!Note]
> 椭圆曲线乘法是密码学家所称的“单向函数”的一种：它在一个方向上（乘法）很容易执行，而在相反方向上（除法）则无法实现。私钥持有者可以轻松生成公钥并将其分享给全世界，因为他知道没人能通过逆向推导从公钥计算出私钥。这一数学技巧成为了不可伪造且安全的数字签名的基石，用于证明对以太坊资金的所有权及对合约的控制权。

在我们演示如何从私钥生成公钥之前，让我们先更详细地了解一下椭圆曲线密码学。

### 椭圆曲线密码学详解 (Elliptic Curve Cryptography Explained)

椭圆曲线密码学（Elliptic Curve Cryptography, ECC）是一种基于离散对数问题（Discrete Logarithm Problem）的非对称或公钥密码学（Public Key Cryptography），该问题通过椭圆曲线点上的加法和乘法运算来体现。图 4-1 是一个椭圆曲线的示例，类似于以太坊所使用的曲线。

> [!Note]
> 以太坊使用的椭圆曲线与比特币完全相同，称为 `secp256k1`。这使得重用比特币的许多椭圆曲线库和工具成为可能。

![Figure 4-1](<./images/figure 4-1.png>)

图 4-1. 一个椭圆曲线

以太坊使用特定的椭圆曲线和一组数学常数，这些常数由美国国家标准与技术研究院（NIST）建立的名为 `secp256k1` 的标准定义。`secp256k1` 曲线由以下产生椭圆曲线的函数定义：
```
y^2 = (x^3 + 7) over (Fp)
```

或者：
```
y^2 mod p = (x^3 + 7) mod p
```

其中 `mod p`（模素数 ）表示该曲线位于素数阶为 p 的有限域（Finite Field）上，也写作`Fp` ，其中 p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1, 。这是一个非常大的素数。

由于这条曲线是定义在素数阶有限域上而非实数域（Real Numbers）上，它看起来像是在二维空间中散落的点阵模式，这使得它难以直观可视化。然而，其数学原理与实数域上的椭圆曲线完全一致。作为示例，图 4-2 展示了在素数阶为 17 的更小有限域上的同一条椭圆曲线，呈现为网格上的点阵模式。以太坊的 `secp256k1` 曲线可以被想象成在一个难以想象的巨大网格上呈现的、更为复杂的点阵模式。

![Figure 4-2](<./images/figure 4-2.png>)

图 4-2. 椭圆曲线密码学：可视化模17上的椭圆曲线

例如，以下是一个坐标为(x, y)的点Q，它是 `secp256k1` 曲线上的一个点
```
Q = (49790390825249384486033144355916864607616083520101638681403973749255924539515, 59574132161899900045862086493921015780032175291755807399284007721050341297360)
```
示例 4-1 展示了如何使用 **Python** 自行验证这一点。变量 `x` 和 `y` 是点Q的坐标，如前例所示。变量 `p` 是椭圆曲线的素数阶（用于所有模运算的素数）。**Python** 代码的最后一行是椭圆曲线方程（**Python** 中的 `%` 运算符是模运算符）。如果 `x` 和 `y` 确实是椭圆曲线上某个点的坐标，那么它们将满足方程，结果为零。你可以尝试在命令行输入 `python`（或 `python3`）并复制列表中的每一行（在提示符 `>>>` 之后）来进行测试。

**示例 4-1. 使用 Python 确认该点位于椭圆曲线上**

```python
Python 3.12.4 (main, Jun  6 2024, 18:26:44) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0
```

### 椭圆曲线算术运算 (Elliptic Curve Arithmetic Operations)

许多椭圆曲线数学看起来和运作起来都非常像我们在学校学到的整数算术。具体来说，我们可以定义一个**加法运算符**（addition operator），它不是沿着数轴跳跃，而是跳跃到曲线上的其他点。一旦我们有了加法运算符，我们就可以定义点与整数之间的**乘法**（multiplication），这等同于重复的加法。

椭圆曲线加法的定义是：给定椭圆曲线上的两个点P1和P2，存在第三个点P3，该点同样位于椭圆曲线上。

从几何上看，这第三个点是通过在P1和P2之间画一条直线来计算的。令人惊叹的是，这条直线将与椭圆曲线交于且仅交于一个额外的地方。将这个点记为P3′ = (x, y)。然后关于x轴进行对称反射，得到P3，如图 4-3 所示。

![Figure 4-3](<./images/figure 4-3.png>)

图 4-3. 椭圆曲线加法：在椭圆曲线上将两点相加

如果P1和P2是同一个点，那么P1和P2“之间”的直线应该延伸为曲线在该点P1处的切线。这条切线将恰好与曲线交于一个新的点，如图 4-4 所示。你可以使用微积分技术来确定切线的斜率。有趣的是，尽管我们将关注点限制在具有两个整数坐标的曲线上，这些技术依然有效！

![Figure 4-4](<./images/figure 4-4.png>)

图 4-4. 椭圆曲线加法：点与其自身相加（二倍点）

在椭圆曲线数学中，还存在一个被称为**无穷远点**（point at infinity）的点，它大致对应于加法中数字0的角色。在计算机上，它有时由 `x = y = 0` 表示（虽然这不满足椭圆曲线方程，但这是一个易于检查的特殊情况）。有几个特殊情况解释了对无穷远点的需求。

在某些情况下（例如，如果P1和P2具有相同的x值但y值不同，如图 4-5 所示），直线将是垂直的，在这种情况下P3 = 无穷远点。

![Figure 4-5](<./images/figure 4-5.png>)

图 4-5. 椭圆曲线加法：导致无穷远点的特殊情况

如果P1是无穷远点，则P1+P2=P2 。同样地，如果P2是无穷远点，则P1+P2=P1。这展示了无穷远点如何扮演“正常”算术中零的角色[^1]。

事实证明，加法运算符 `+` 满足**结合律**（associative），这意味着  `(A + B) + C = A + (B + C)`。这代表我们可以无歧义地写作 `A + B + C`（不加括号）。

现在我们已经定义了加法，我们可以通过扩展加法的标准方式来定义**乘法**[^2]。对于椭圆曲线上的点 ，如果k是一个整数，那么`k * P = P + P + P + … + P`（共k次）。请注意，在这种情况下， k有时（可能会令人困惑地）被称为**指数**（exponent）。

> [!Tip]
> **译者注**：
> **计算效率优化**：在后端底层实现（如 `libsecp256k1`）中，计算并非真的执行k次加法。开发者通常使用 **双倍加算法**（Double-and-Add），其时间复杂度为O(logk)。这与快速幂算法的逻辑一致，是保证以太坊签名验证毫秒级响应的关键。

### 生成公钥 (Generating a Public Key)

从一个随机生成的数字形式的私钥 `k` 开始，我们将其与曲线上一个预定义的点——**生成点**（generator point）`G` 相乘，从而在曲线上的其他位置产生另一个点，这就是对应的公钥 `K`：
```
K = k * G
```
生成点是在 `secp256k1` 标准中指定的；对于所有 `secp256k1` 的实现来说，它都是相同的，并且所有从该曲线派生出的密钥都使用同一个点 `G`。由于生成点对所有以太坊用户都是固定的，因此私钥 `k` 与 `G` 相乘将始终得到相同的公钥 `K`。`k` 和 `K` 之间的关系是确定的，但只能沿一个方向计算，即从 `k` 到 `K`。这就是为什么以太坊地址（由 `K` 派生）可以与任何人分享，而不会泄露用户的私钥（`k`）。

正如我们在前一节中所描述的，`k * G` 的乘法等同于重复加法，即 `G + G + G + … + G`，重复 `k` 次。总而言之，为了从私钥 `k` 产生公钥 `K`，我们将生成点 `G` 自身相加 `k` 次。

> [!Tip]
> 私钥可以转换为公钥，但公钥无法转换回私钥，因为数学运算是单向的。

让我们利用这一计算过程，为我们在“私钥”（Private Keys）章节中展示的特定私钥寻找公钥：

`K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G`

密码学库可以利用椭圆曲线乘法帮助我们计算 `K`。生成的公钥 `K` 被定义为一个点：

`K = (x, y)`

其中：
```
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```
在以太坊中，你可能会看到公钥被表示为 130 个十六进制字符（65 字节）的序列化字符串。这是采用了[工业联盟高效密码组](https://oreil.ly/Y_cOQ)（Standards for Efficient Cryptography Group, SECG）在《高效密码标准》（SEC1）文档中提出的标准序列化格式。该标准定义了四种可能的出前缀，用于识别椭圆曲线上的点，如表 4-1 所示。

表 4-1. 序列化椭圆曲线公钥前缀

![Table 4-1](<./images/table 4-1.png>)

以太坊仅使用**未压缩公钥**（uncompressed public keys），因此唯一相关的前缀是十六进制的 `04`。序列化过程将公钥的 `x` 坐标和 `y` 坐标拼接在一起：

`04 + x 坐标 (32 字节 / 64 位十六进制) + y 坐标 (32 字节 / 64 位十六进制)`

因此，我们之前计算的公钥序列化结果为：

`046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0`


### 椭圆曲线库 (Elliptic Curve Libraries)

在加密货币相关项目中，有几种常用的 [secp256k1](https://www.secg.org/sec2-v2.pdf) 椭圆曲线实现：

[**OpenSSL**](https://www.openssl.org/)

OpenSSL 库提供了一套全面的密码学原语，包括完整的 `secp256k1` 实现。例如，可以使用 [`EC_POINT_mul`](https://www.openssl.org/docs/manmaster/man3/EC_POINT_mul.html) 函数来从私钥派生公钥。

[**libsecp256k1**](https://oreil.ly/lv84W)

Bitcoin Core 的 `libsecp256k1`是一个用 C 语言编写的 `secp256k1` 椭圆曲线及其他密码学原语的实现。它最初是为了在 Bitcoin Core 软件中取代 OpenSSL 而从零编写的，在性能和安全性方面都被认为更加优越。


## 密码学哈希函数 (Cryptographic Hash Functions)

密码学哈希函数在以太坊中无处不在。事实上，几乎所有的加密系统都广泛使用哈希函数——密码学家 [Bruce Schneier](https://www.schneier.com/) 曾总结道：“单向哈希函数比加密算法更像现代密码学的劳模。”

在本节中，我们将讨论哈希函数，探索其基本属性，并了解这些属性为何使它们在现代密码学的众多领域如此有用。我们在此讨论哈希函数，是因为它们是以太坊公钥转化为地址的过程中的重要一环。它们还可以用于创建“数字指纹”（Digital fingerprints），辅助数据的验证。

通俗地说，**哈希函数**（Hash function）是任何可以将任意大小的数据映射到固定大小数据的函数。哈希函数的输入被称为**原像**（Preimage）、**消息**（Message）或简单的输入数据。输出则被称为**哈希值**（Hash）。密码学哈希函数是一个特殊的子类，具有对安全平台（如以太坊）非常有用的特定属性。

密码学哈希函数是一种**单向哈希函数**（One-way hash function），它将任意大小的数据映射为固定长度的位字符串。其“单向”性质意味着，如果只知道输出哈希值，在计算上是不可能重新创建输入数据的。确定可能输入的唯一方法是进行暴力搜索（Brute-force search），逐个检查候选输入以寻找匹配的输出；鉴于搜索空间几乎是无限的，这项任务在实际操作中是不可能完成的。即使你找到了能够产生匹配哈希值的输入数据，它也可能不是原始输入数据：哈希函数是“多对一”函数。找到两组产生相同输出的输入数据被称为发现**哈希碰撞**（Hash collision）。粗略地说，哈希函数越好，哈希碰撞就越罕见。对于以太坊来说，碰撞在实际上是不可能发生的。

让我们仔细看看密码学哈希函数的主要属性：

* **确定性 (Determinism)**：给定的输入消息始终产生相同的哈希输出。
* **可验证性 (Verifiability)**：计算消息的哈希值是高效的（线性复杂度）。
* **非相关性 (Noncorrelation)**：对消息的一点微小改变（例如改变 1 位）应当使哈希输出发生剧烈变化，以至于它与原始消息的哈希值之间没有相关性（即“雪崩效应”）。
* **不可逆性 (Irreversibility)**：从哈希值反推消息是不可行的，相当于对所有可能的消息进行暴力搜索。
* **碰撞保护 (Collision protection)**：计算出两个产生相同哈希输出的不同消息应该是不可行的。

抗碰撞性对于避免以太坊中的数字签名伪造尤为重要。这些属性的结合使得密码学哈希函数在广泛的安全应用中非常有用，包括：

* 数据指纹识别 (Data fingerprinting)
* 消息完整性验证（错误检测 / Error detection）
* 工作量证明 ([Proof of Work](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/))
* 身份验证（密码哈希和密钥拉伸）
* 伪随机数生成器 (Pseudorandom number generators)
* 消息承诺（承诺-揭晓机制 / [Commit-reveal mechanisms](https://en.wikipedia.org/wiki/Commitment_scheme)）
* 唯一标识符 (Unique identifiers)

随着我们深入研究系统的各个层级，我们会在以太坊中发现许多这类应用。


### 以太坊的密码学哈希函数：Keccak-256 (Ethereum's Cryptographic Hash Function: Keccak-256)

以太坊在许多地方都使用了 `Keccak-256` 密码学哈希函数。`Keccak-256` 最初是作为 [NIST](https://www.nist.gov/)（美国国家标准与技术研究院）在 2007 年举办的 [SHA-3 密码学哈希函数竞赛](https://csrc.nist.gov/projects/hash-functions/sha-3-project)的候选算法设计的。`Keccak` 最终成为了获胜算法，并于 2015 年被正式标准化为联邦信息处理标准 [FIPS 202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf)。

然而，在以太坊开发期间，NIST 的标准化进程尚未最终完成。据称，为了提高效率，NIST 在标准流程结束后调整了 `Keccak` 的某些参数。与此同时，英雄般的举报人 [Edward Snowden](https://en.wikipedia.org/wiki/Edward_Snowden) 披露的文件暗示，NIST 可能受到了美国国家安全局（NSA）的不当影响，故意削弱了 [Dual_EC_DRBG](https://en.wikipedia.org/wiki/Dual_EC_DRBG) 随机数生成器（RNG）标准，从而在标准 RNG 中植入了后门。这场争议导致了对提议修改的抵制，并显著推迟了 [SHA-3](https://en.wikipedia.org/wiki/SHA-3) 的标准化进程。当时，以太坊基金会决定采用其发明者最初提交的原始 `Keccak` 算法，而不是由 NIST 修改后的 `SHA-3` 标准。

> [!Warning]
> 虽然你可能会在以太坊的文档和代码中看到提及 “SHA-3”，但其中许多（即便不是全部）实例实际上是指 `Keccak-256`，而不是最终定稿的 FIPS-202 `SHA-3` 标准。两者在实现上的差异非常细微，主要涉及**填充（Padding）参数**，但这些差异意义重大，因为对于相同的输入，`Keccak-256` 会产生与 FIPS-202 `SHA-3` 完全不同的哈希输出。

### 我使用的是哪种哈希函数？ (Which Hash Function Am I Using?)

如果两者都可能被统称为 “SHA-3”，你该如何判断你所使用的软件库实现的是 [FIPS-202 SHA-3](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) 还是 `Keccak-256`？

一种简单的判断方法是使用**测试向量**（Test vector），即针对给定输入的预期输出。哈希函数最常用的测试输入是空输入。如果你以空字符串作为输入运行哈希函数，你应该看到以下结果：
```
Keccak256("") = c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
SHA3("") = a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a
```
无论函数被称作什么，你都可以通过运行这个简单的测试来验证它是原始的 `Keccak-256` 还是最终的 NIST 标准 FIPS-202 `SHA-3`。请记住，尽管在代码中经常被称为 `SHA-3`，但以太坊使用的是 `Keccak-256`。

> [!Note]
> 由于以太坊所使用的哈希函数（Keccak-256）与最终定稿标准（FIPS-202 SHA-3）之间的差异引起了混乱，所有代码、操作码（Opcodes）和库中的 `sha3` 实例都已重命名为 `keccak256`。详情请参阅 [ERC-59](https://oreil.ly/rTHDv)。

接下来，让我们研究 `Keccak-256` 在以太坊中的第一个应用：从公钥生成以太坊地址。

## 以太坊地址 (Ethereum Addresses)

以太坊地址是使用 `Keccak-256` 单向哈希函数从公钥或合约中派生出的唯一标识符。

在之前的示例中，我们从一个私钥开始，利用椭圆曲线乘法派生出了公钥。

**私钥 k：**
```
k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315
```
**公钥 K**（ x轴和y轴坐标拼接后的十六进制显示）：
```
K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```

> [!Note]
> 值得注意的是，在计算地址时，公钥**并不包含**十六进制前缀 `04`。

我们使用 `Keccak-256` 来计算该公钥的哈希值：
`Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

然后，我们只保留最后的 **20 字节**（最低有效字节），这便是我们的以太坊地址：
`001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

你最常看到的以太坊地址带有 `0x` 前缀，这表示它们是十六进制编码的，如下所示：
`0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

### 以太坊地址格式 (Ethereum Address Formats)

以太坊地址是十六进制数字，是从公钥的 [Keccak-256](https://keccak.team/keccak.html) 哈希值的最后 20 字节派生出来的标识符。

与比特币地址不同，比特币地址在所有客户端的用户界面中都经过编码，包含内置的**校验和**（Checksum）以防止地址输入错误；而以太坊地址最初以原始十六进制形式呈现，没有任何校验和。这一决策背后的理由是：以太坊地址最终将被系统更高层级的抽象（如域名服务）所隐藏，如果需要校验和，应当在更高层级添加。

但在现实中，这些高层级的开发速度过于缓慢，这一设计选择在生态系统早期引发了诸多问题，包括因地址输入错误和输入验证失败导致的资金损失。此外，由于以太坊域名服务的开发进度慢于最初预期，钱包开发者采纳替代编码方案的速度也极其缓慢。接下来我们将了解几种编码选项。

> [!Note]
> 值得一提的是 [以太坊域名服务 (ENS)](https://ens.domains/)，它由 Alex Van de Sande 和 Nick Johnson 于 2017 年推出。**ENS** 提供了一种链上解决方案，可将易于人类阅读的名称（例如 `masteringethereum.eth`）转换为以太坊地址。

> [!Tip] **译者注**：
> 1. **静默失败的代价**：从后端开发视角看，缺乏内置校验和意味着如果你在 API 传参时把 `0xabc...123` 误打成了 `0xabc...122`，没有任何数学层面的保护会报错。在处理涉及真金白银的提币逻辑时，开发者必须在前端和后端代码中手动引入校验逻辑（如 [EIP-55](https://eips.ethereum.org/EIPS/eip-55)），否则一个简单的“手抖”就会造成永久性的资产损毁。
> 2. **ENS 的解析逻辑**：虽然 **ENS** 让地址变得易读，但后端服务在与合约交互前，依然需要通过解析器（Resolver）将其还原为原始的 20 字节地址。作为后端架构师，不仅要存储 `.eth` 域名，还要定期更新缓存的对应地址，以防止用户通过更改 **ENS** 记录造成的转账指向错误。


### 带有大小写校验和的十六进制编码 (ERC-55)

由于域名服务部署缓慢，[ERC-55](https://oreil.ly/JfgWs) 提出了一项标准。`ERC-55` 通过修改十六进制地址的大小写，为以太坊地址提供了一种向后兼容的校验和。其核心思想是：以太坊地址在解析上是不区分大小写的，所有钱包都应该接受大写或小写表示的地址，解释结果没有区别。通过修改地址中字母字符的大小写，我们可以传达一个校验和，用于保护地址的完整性，防止输入或读取错误。

不支持 `ERC-55` 校验和的钱包会直接忽略地址中大小写混合的事实，但支持它的钱包可以进行验证，并以 **99.986%** 的准确率检测出错误。

这种混合大小写的编码非常微妙，你最初可能不会注意到它。我们的示例地址是：
`0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

经过 `ERC-55` 混合大小写校验和处理后，它变成了：
`0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9`

你能看出区别吗？十六进制编码中的部分字母（A–F）现在变成了大写，而其他的保持小写。

`ERC-55` 的实现非常简单。我们对小写的十六进制地址进行 `Keccak-256` 哈希计算。这个哈希值充当了地址的数字指纹，为我们提供了一个方便的校验和。输入（地址）的任何微小变化都会导致生成的哈希（校验和）发生巨大变化，从而使我们能够有效地检测错误。哈希值随后被编码到地址本身的大小写中。

让我们分步拆解：

1. **对不带 `0x` 前缀的小写地址进行哈希：**
`Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") = 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1`
2. **根据哈希值修改大小写：**
如果哈希值中对应的十六进制位大于或等于 `0x8`，则将地址中的对应字母大写。将地址和哈希值对齐显示会更直观：
```text
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
```

我们的地址第四位是字母 `d`。哈希值的第四个字符是 `6`，小于 8，所以保持 `d` 小写。下一个字母是第六位的 `f`。哈希值的第六个字符是 `c`，大于 8，因此我们将地址中的 `f` 大写为 `F`，以此类推。由于地址只有 20 字节（40 个十六进制字符），我们只需使用哈希值的前 40 位。

自行检查最终生成的混合大小写地址，看看哪些字符被大写了，以及它们对应哈希值中的哪些位：
```text
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
```

### 检测 ERC-55 编码地址中的错误

现在，让我们看看 `ERC-55` 地址如何帮助我们发现错误。假设我们打印了一个 `ERC-55` 编码的地址：
`0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9`

现在让我们在读取地址时犯一个基础错误。倒数第二个字符是大写的 `F`，假设我们将其误读为大写的 `E`，并在钱包中输入了以下（错误的）地址：
`0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9`

幸运的是，我们的钱包符合 `EIP-55` 标准！它注意到了混合大小写并尝试验证该地址。钱包将其转换为全小写并计算校验哈希：
```
Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") = 5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927
```

如你所见，尽管地址只改变了一个字符（实际上只改变了 1 位，因为 `e` 和 `f` 在二进制上仅 1 位之差），但地址的哈希值发生了翻天覆地的变化。这就是哈希函数的特性，也是它们在校验和中如此有用的原因！

现在，我们将输入的地址与新计算的哈希对齐：

```text
Input Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
New Hash     : 5429b5d9460122fb4b11af9cb88b7bb76d892886...

```

完全对不上！多个字母的大小写都是错误的。请记住，大小写本身就是正确校验和的编码方式。我们输入的地址大小写与刚刚计算出的校验和不匹配，这意味着地址已被篡改或引入了错误。

## 验证者密码学 (Validators' Cryptography)

在本节中，我们将探讨在基于 [PoS](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)（权益证明）的新共识协议中，验证者所使用的密码学技术。虽然其核心思想始终是能够对消息进行数字签名并进行验证，但由于共识层存在一些特殊的需求，其设计选择和最终实现与以太坊用于交易或地址的密码学有着显著的不同。[^3]

### 简介 (Introduction)

在以太坊使用 `Ethash`（当时的 [PoW](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/) 共识算法）时，没有理由要求区块提议者（当时的矿工）对其生产的区块进行签名。事实上，基于 PoW 的共识算法不需要知道是谁创建了区块就能正常运行。如果区块提议者行为不当，协议会通过让他们浪费电力、时间和金钱来隐式地惩罚他们。

让我们以一个试图通过同时创建两个区块来进行“双花”（Double spend）的矿工为例。为了更好地理解这种“攻击”的核心思想，想象一个矿工想买车，并同意用 ETH 支付（假设是 10 ETH）。该矿工同时创建了两个区块。假设它们都是有效的：在第一个区块中，矿工添加了向经销商发送 10 ETH 的交易；而在另一个区块中，他没有添加。矿工正试图将链分叉为两个部分。

取决于（几乎是）随机的因素，车行经销商可能会先收到矿工支付了 10 ETH 的那个区块。因此，经销商可能认为支付成功了。但他们还没有把车交给矿工。事实上，经销商知道在 PoW 系统中，通常需要等待若干个区块确认后，才认为交易最终结算。

大约 12 秒后，另一名矿工在**不包含** 10 ETH 支付的那个区块之上生产了一个新区块。这完全是可能的，因为这通常取决于下一名矿工先收到了哪个区块。现在出现了一条更长的区块链，根据**最重链规则**（Heaviest chain rule，也被误称为最长链规则），该链被所有节点视为唯一有效的链。

经销商看到有效的区块链中并不包含之前收到的那个有 10 ETH 支付记录的区块，因此他们认为支付未完成，不把车给矿工。

请记住，在 PoW 系统中，矿工必须投入真实的能源和时间来生产一个通过 PoW 检查的有效区块（即区块哈希值低于动态阈值）。因此，他们耗费能源和时间创建区块，却看到自己的区块被整个网络拒绝，这本身就是一种**隐式惩罚**。他们损失了宝贵的能源和时间，而这些资源本可以更好地用于创建遵循所有规则、不尝试作弊的有效区块。

[PoS](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/) 系统对于行为不当的区块生产者（即验证者）没有这种相同的隐式惩罚。相反，它们使用一种显式的方法：**罚没**（Slashing）。

**罚没**是指通过扣除验证者部分（或全部）质押的 ETH，来惩罚不遵守规则的验证者的行为。这解释了为什么验证者必须质押最低数量的 ETH 才能成为活跃验证者。如果他们没有质押任何东西，当他们开始采取恶意行动时，协议将无法对他们进行惩罚。

要显式惩罚不遵守规则的验证者，需要确切知道每个验证者都在做什么。为此，验证者发送的每条消息（包括区块）都必须使用其**数字签名**进行身份验证。

让我们重现之前矿工的类似例子。现在我们有一个验证者同时提议两个区块。在 PoW 中，矿工需要花费两倍的能源和时间来同时产生两个有效区块，但在 PoS 中，这几乎是完全免费的。

但这就是“罚没”登场的地方。**双重签名**（Double-signing）——即同时提议两个区块——是一个可罚没事件，因此该验证者会立即受到惩罚（在这个特定例子中，其所有质押的 ETH 都会被销毁）。

既然我们知道了为什么验证者必须对所有消息进行身份验证，我们可以深入研究用于此目的的密码学：[**BLS 签名**](https://en.wikipedia.org/wiki/BLS_digital_signature)。在下一节中，我们将了解导致最终决定使用 BLS 密码学的需求。


### 需求 (Requirements)

针对“验证者之间发送的每条消息都需要身份验证”这一问题，你首先想到的方案可能是沿用以太坊在交易中已经使用的数字签名算法：**椭圆曲线数字签名算法**（[ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)）。

然而，面对以太坊庞大的验证者群体（目前已超过 100 万），`ECDSA` 无法胜任。事实上，这种数字签名算法必须满足一个核心要求：**必须能够压缩签名**，以减少区块中占用的空间，并缩短节点验证所有验证者签名所需的时间。

目前，每位验证者在每个 **Epoch**（纪元，即 32 个 **Slots** / 时段，详见第 15 章）内可以投一票——即一条需要身份验证的消息。这些消息需要通过 P2P 传闻层（Gossip layer）传输给其他验证者和节点，由每个节点验证签名的有效性，最后插入区块中。

这里的瓶颈显而易见：加入网络的验证者越多，节点需要处理的消息就越多。区块也会变得越来越大，因为需要预留越来越多的空间来存储这些验证者的签名。

> [!Note]
> 你可以根据活跃验证者的数量轻松计算出节点每秒需要处理的消息数：
> ```
> N = 活跃验证者数量
> 1 条消息 / 1 Epoch × N  =
> = 1 条消息 / 32 Slots × N = （一个 Epoch 由 32 个 Slots 组成）
> = 1 条消息 / (32 × 12 秒) × N = （每个 Slot 持续 12 秒）
> = 1 条消息 / 384 秒 × N =
> 0.0026041667条消息/秒 × N
> ```
> 因此，我们每秒大约产生 0.0026 条消息，乘以网络中活跃验证者的数量 ：
> ```
> N = 1,000  每秒约 2.6 条消息
> N = 10,000  每秒约 26 条消息
> N = 100,000  每秒约 260 条消息
> N = 1,000,000  每秒约 2,600 条消息
> ```
目前，以太坊 PoS 协议每秒需要处理约 2,600 条消息。

出于这些原因，大多数 PoS 区块链的验证者集合非常小，通常最多只有几十个或几百个。甚至以太坊最初的提案（见 [EIP-1011](https://oreil.ly/pQSCp)）也将目标定为最多 900 名验证者，并要求至少质押 1,500 ETH 才能进入活跃验证者集合。

如果不是以太坊基金会研究员 Justin Drake 在 2018 年 5 月于 [ethresearch 网站](https://ethresear.ch/)发表的[长文](https://oreil.ly/EbBib)中提出了 **BLS 签名聚合**（BLS signature aggregation）的想法，这可能就是以太坊 PoS 协议的最终规范了。


> [!Tip] **译者注**：
> 1. **吞吐量与复杂度的权衡**：从后端架构师的角度看，这是一个典型的“扇入”（Fan-in）瓶颈。2,600 TPS 的签名验证请求看似不高，但如果每个验证都需要独立的 CPU 密集型椭圆曲线运算，节点会瞬间满载。`ECDSA` 的验证成本是O(n) ，即验证 n 个签名需要 n 次运算；而追求 **BLS** 的目标是将验证成本降至接近O(1) 。
> 2. **去中心化的门槛**：最初提案要求的 1,500 ETH（按现价计算是天文数字）反映了技术瓶颈对去中心化的限制。**BLS 聚合技术**的应用，直接将参与门槛降低到了 32 ETH，使得验证者数量从数百暴增至百万量级，这在分布式系统设计中是一个质的飞跃。


### BLS 数字签名 (BLS Digital Signatures)

**BLS 签名**是以其作者的名字命名的。**BLS** 代表 Boneh、Lynn 和 Shacham，分别指代三位密码学家 Dan Boneh、Ben Lynn 和 Hovav Shacham。他们在 2001 年发表的一篇名为《基于 Weil 配对的短签名》（[Short Signatures from the Weil Pairing](https://oreil.ly/cJn6v)）的论文中引入了这种签名方案。

与 [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)（将在第 6 章进一步解释）一样，**BLS 签名**仍然基于椭圆曲线密码学。特别地，以太坊使用了 **BLS12-381** 曲线，这是由 Sean Bowe 在 2017 年为 [Zcash](https://z.cash/) 协议工作时设计的。该曲线由以下函数定义：
```
y^2 = x^3 + 4
```
其定义域是在模q的整数域上，其中q是一个 115 位（十进制）的数字：`0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab`。

> [!Tip]
> **译者注**：
> 1. **曲线家族的差异**：作为后端开发者，你会发现以太坊地址用的 `secp256k1` 曲线方程是
$$y^2 = x^3 + 7$$
而这里共识层用的 `BLS12-381` 是
$$y^2 = x^3 + 4$$ 。虽然方程看起来只是常数项变了，但 `BLS12-381` 属于“配对友好型（Pairing-friendly）”曲线。这种特性允许我们在不暴露私钥的情况下，通过某种复杂的双线性映射来验证两个加密点之间的乘法关系，这是实现“聚合签名”的数学基础。
> 2. **安全强度权衡**：`BLS12-381` 名字中的 381 代表其素数域的位宽（Bit-width）。虽然它的位宽比 `secp256k1` 更大（381 位 vs 256 位），但由于针对这类曲线的特定数学攻击（如数域筛选法）效率更高，它的实际安全性大致等同于 128 位安全强度。在后端工程实践中，这意味着处理 BLS 密钥需要更大的存储空间和不同位宽的大数库。

#### 它的工作原理 (How Does It Work?)

BLS 签名的核心思想与 [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) 非常相似：存在一个私钥，并由此派生出公钥。随后，使用私钥对每条消息进行签名，其他所有人都可以使用对应的公钥来验证消息的完整性。

**私钥 (sk)** 是一个介于 1 到 r-1 之间的整数，其中 r 是一个巨大的数字：`0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001`。它足有 77 位（十进制）之长！

**公钥 (pk)** 是通过执行 `sk * g1` 得到的，这是一个椭圆曲线点乘运算。其中 `g1` 是被称为 G1 群的生成元（Generator）。公钥以压缩和序列化的格式表示，结果为一个48字节的字符串。

被签名的**消息 (m)** 总是被映射到椭圆曲线上的一个点，该点属于另一个被称为 G2 的群。你可以将这种映射看作是一种哈希函数，它接收消息 `m`（即验证者的实际见证数据），并输出 G2 群中的一个点 `H(m)`。其压缩序列化形式为一个 **96 字节**的字符串。

最后，我们通过计算 `sk * H(m)` 得到消息 `m` 的**签名 (σ)**，这是G2中的一个新的椭圆曲线点。

`ECDSA` 和 `BLS` 之间的关键区别在于这两个协议的底层细节——即它们用于验证签名正确性的数学技术。事实上，`ECDSA` 涉及的是椭圆曲线上的标量乘法和加法等线性数学计算，而 **BLS 签名**则依赖于更为复杂的**椭圆曲线双线性配对**（Elliptic curve bilinear pairings）算术。

事实上，当且仅当以下等式成立时，签名 σ 才有效：
```
e(g1,σ) = e(pk, H(m))
```
其中e是一个椭圆曲线双线性配对函数。


#### 深入椭圆曲线特性 (Inside Elliptic Curve Properties)

完全理解前面的等式需要对椭圆曲线、配对（Pairing）以及整个深奥的领域有深入的了解。但一种简单的方法是直接遵循以下步骤。虽然你可能无法掌握配对为何具有该特性的所有细节，但它仍能帮助你熟悉它：
```
e(pk, H(m)) = e(sk * g1,H(m)) = ← pk = sk * g1
= e(g1, H(m))^sk = ← thanks to a pairing property
= e(g1, sk * H(m)) = ← thanks to the same property
= e(g1,σ) ← σ = sk * H(m)
```
正如 Vitalik Buterin 在一篇 [Medium 文章](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)中指出的：

> 如果你将椭圆曲线上的点看作是“单向加密”后的数字，`encrypt(p) = p * G = P`，其中G是生成点，那么传统椭圆曲线数学仅允许你检查数字之间的线性约束（例如：如果 `P = G * p, Q = G * q` 并且 `R = G * r`，那么验证 `5 * P + 7 * Q = 11 * R`实际上就是在验证`5 * p + 7 * q = 11 * r`）;配对技术（Pairings）允许你检查二次约束（即乘法关系），（例如：验证 `e(P, Q) * e(G, G * 5) = 1`实际上是在检查`p * q + 1 * 5 = 0`）

你可以想象，更复杂的算术也意味着生成和验证签名需要更多时间。以太坊对验证者使用 BLS 签名的唯一原因，是因为它们具有极其重要的特性：**签名聚合**（Signature aggregation）。

事实上，如果你将两个 `ECDSA` 签名相加，你得不到任何有意义的结果。如果你尝试用该结果来证明最初签名消息的完整性，你将无法通过任何测试。

相反，如果你将两个 BLS 签名相加，你只是在进行椭圆曲线加法。结果是一个新的椭圆曲线点（位于G2中），你可以将其与两个对应公钥的和（这仍然是G1中的一个椭圆曲线点）进行验证，从而正确地验证最初签名消息的完整性。

> [!Note]
> 聚合签名和聚合公钥与单个签名和单个公钥是无法区分的，因此你可以使用完全相同的算法来验证聚合签名的正确性。
>
> **聚合签名和公钥:**
> ```
> σagg = σ1 + σ2 + σ3 + … + σn
> pkagg = pk1 + pk2 + pk3 + … + pkn
> ```
> **聚合签名验证:**
> ```
> e(pkagg,H(m)) =
> = e(pk1 + pk2 + pk3 + ... + pkn,H(M))
> = e((sk1 + sk2 + sk3 + ... + skn) * g1,H(m))
> = e(g1,H(m))^(sk1 + sk2 + sk3 + ... + skn)
> = e(g1,(sk1 + sk2 + sk3 + ... + skn) * H(m))
> = e(g1,σ1 + σ2 + σ3 + ... + σn)
> = e(g1,σagg)
> ```


> [!Tip]
> **译者注**：
> 1. **从O(N)到O(1)的跨越**：作为后端开发者，请注意聚合后的验证成本。在 `ECDSA` 中，验证 1000 个签名需要 1000 次昂贵的运算；而在 BLS 聚合方案中，无论参与签名的验证者是 10 个还是 1000 个，最终在区块中只占一个点的大小（96 字节），且只需进行**一次**配对函数运算（Pairing）即可完成验证。这种极高的吞吐效率是以太坊能支持百万级验证者的技术基石。
> 2. **线性性质的陷阱**：虽然 BLS 的加法特性非常美妙，但也带来了“流氓公钥攻击（Rogue-key attack）”的风险。简单来说，攻击者可以通过构造一个特殊的公钥来抵消掉他人的签名。在后端实现中（如以太坊的 [Beacon Chain](https://ethereum.org/en/roadmap/beacon-chain/)），我们通过要求验证者在入驻时提交“所有权证明（Proof of Possession）”，即对其公钥进行一次额外的签名，来确保公钥是真实存在的，从而规避这种数学漏洞。

#### 总结 (In Summary)

密码学是一门非常高深的学科，它需要深厚的数学背景。本书并非专门为密码学家编写，因此有必要对前几节简要提及的内容进行总结。我们解释了 **BLS 签名**的工作原理，以及为什么选择它作为基于 **PoS**（权益证明）的新共识协议中验证者使用的数字签名算法：其**聚合特性**（Aggregation property）允许将多个数字签名压缩为一个，从而在不降低安全性的前提下，减少存储空间并缩短验证时间。

我们可以通过一个简单的例子来演示验证者在“现实生活”中如何使用 **BLS** 算法，以及签名聚合是如何发挥作用的。图 4-6 展示了一个场景：有三位验证者想要对一个区块（区块 A）表达投票。于是他们投出选票，对其进行签名，并相互分享。

![Figure 4-6](<./images/figure 4-6.png>)

图 4-6. BLS 签名聚合：三位验证者投票并签名

如果没有 **BLS**，你需要将所有三份已签名的选票全部存入区块中以实现永久存储。而有了 **BLS**，你可以将所有三份已签名的选票聚合为一份新的**聚合选票**（Aggregated vote），并仅将这一份存入区块。

这不仅节省了空间，还大幅减少了所有以太坊节点在验证所有签名选票时所需的时间和计算量，因为节点可以直接验证聚合后的选票，而无需对每份单独的签名选票执行验证。**BLS** 密码学的神奇之处在于，聚合结果与普通签名完全无异：这意味着验证聚合签名的难度并不比验证单个签名更高。因此，通过显著减少需要验证的签名选票数量，且每份验证所需的计算量保持不变，全节点必须执行的计算总量（以及所需的时间）远低于不使用 **BLS** 聚合签名的情况，如图 4-7 所示。

![Figure 4-7](<./images/figure 4-7.png>)

图 4-7. BLS 签名聚合缩短验证时间

如果验证者不遵守规则会怎样？如果验证者表现出恶意行为——例如**双重签名**（Double-signing），即同时对两个不同的区块进行投票——协议可以检测到这种行为并对验证者进行相应的惩罚，如图 4-8 所示。

![Figure 4-8](<./images/figure 4-8.png>)

图 4-8. BLS 签名支持检测恶意验证者

事实上，由于所有选票都使用 **BLS 签名**方案进行了数字签名，识别出对不当行为负责的验证者并对其进行相应的**罚没**（Slashing）是非常简单的。

## KZG 密码学 (KZG Cryptography)

2024 年 3 月 13 日，以太坊完成了 **Cancun-Deneb (Dencun)** 硬分叉升级。这次升级包含多项变更，但其中最重要的无疑是引入了一种新型交易：[EIP-4844](https://eips.ethereum.org/EIPS/eip-4844) **Blob 交易**。

我们在这里不会深入探讨为什么 **Blob 交易**对以太坊的路线图至关重要（我们将在第 16 章进行详细讨论）。相反，在接下来的章节中，我们将探索支撑这种新型交易底层的密码学技术：**多项式承诺方案**（Polynomial commitment schemes），更具体地说，是 **KZG 承诺方案**。

### 简介 (Introduction)

在研究多项式承诺方案之前，理解我们所面临的问题以及我们希望达到的最终目标至关重要。

> [!Note]
> 在本节中，我们将简要提到 **二层网络 (Layer 2s / L2s)** 这一术语。虽然我们会在第 16 章对 **L2s** 进行详细解释和扩展，但对其进行简单的介绍也是有帮助的。**L2s** 是以太坊的一种新型扩容方案：它们是真实的区块链，拥有独特的历史和状态，并定期将其所有更新和数据发布到以太坊主网。其基本原理是：必须能够仅通过查看以太坊主网就推导出整个 **L2** 区块链。

在不涉及过多细节的情况下，**L2s** 每天都会向以太坊主链发布大量数据。网络中的所有节点都必须下载并验证这些数据。这种情况通常会导致 `gas` 费用激增，在极端情况下，仅进行一次 `ETH` 转账的费用就可能达到 10 到 20 美元。

最终，我们希望不再将所有这些数据直接发布在链上，而只是存储一个对这些数据的**承诺**（Commitment）——即一个密码学哈希——而将完整数据留在以太坊链外。但仅发布哈希会产生一个新问题：网络中的所有节点必须确保该承诺所指向的数据在某处确实存在；否则，我们可能会丢失关键数据。

第一个（显而易见的）解决方案是强制所有节点临时下载完整数据，以便它们能够轻松验证承诺是否有效——即确认它指向了它们所拥有的完整数据。截至编写本章时（2025 年 6 月），我们正处于这一阶段。

长期的解决方案是不要求所有节点下载完整数据，而只下载其中极小的一部分。节点随后可以使用密码学证明来确保数据的完整可用性。这些证明必须体积小且能被快速验证。其核心思想是：证明（以及验证）数据的可用性比直接下载并验证数据要快得多，也轻量得多。这种策略被称为**数据可用性采样 (Data Availability Sampling / DAS)**，是以太坊社区最重要的研究领域之一。

为了实现 **DAS** 的最终目标，我们需要一个密码学系统使我们（所有节点）能够：

* 创建对某些数据的承诺（即你想要证明其完整存在且可用的数据）。
* 为与先前创建的承诺相关的数据生成小型证明。
* 轻松验证这些证明。

该密码学系统最好（但非强制）不要泄露过多与其所引用的数据相关的信息。在下一节中，我们将探索这样一种密码学系统：**多项式承诺方案**，更具体地说，是 **KZG 承诺方案**。

> [!Note]
> 你可能会纳闷，为什么我们在讨论“多项式”承诺方案而不是“数据”承诺方案。这是一个非常好的问题：我们的目标是对某些数据进行承诺，而不是对多项式。但诀窍在于：**数据可以被表示为多项式**。因此，如果我们能够实现多项式承诺方案，目标就达成了。


> [!Tip]
> **译者注**：
> 1. **从哈希到多项式的升维**：作为后端开发者，我们习惯了使用 `SHA-256` 等简单哈希来做 `Data Integrity` 校验。但传统哈希的一个致命缺陷是“全或无”——如果你只有部分数据，你无法验证这个局部数据是否属于原来的哈希。**多项式承诺（Polynomial Commitment）** 的强大之处在于它支持“局部验证”：通过多项式的特性，你可以仅用极小的数据片段和证明，就向验证者确信“这确实是原始大数据集中的一部分”，这正是实现 **DAS** 的数学基石。
> 2. **存储架构的范式转移**：**EIP-4844** 引入 **KZG** 实际上是在后端架构中引入了一个“带过期时间的分布式缓存层”。对于 **L2** 的开发者来说，这意味着你需要重新设计数据同步逻辑：不再依赖 `eth_getLogs` 等传统接口获取历史数据，而需要通过专门的 **Blob** 节点在数据被删除（约 18 天）前完成备份。这种设计迫使后端系统从“昂贵的永久存储”转向“廉价的临时带宽”，极大降低了系统的运营成本。
> 3. **从存储到承载的转变**：作为后端开发者，理解 **Blob** 的关键在于其生命周期。传统的 `calldata` 会永久存储在以太坊状态中，极其昂贵；而由 **KZG 承诺**保护的 **Blob** 数据在约 18 天后就会从节点中删除。**KZG** 在这里的作用是提供一个极小的“指纹”，确保即使原始数据被删除了，二层网络（Rollups）在验证期间提供的数据依然与当初存入时完全一致，且不可篡改。
> 4. **性能优化的新维度**：**EIP-4844** 引入 **KZG** 是为了解决以太坊的带宽瓶颈。通过多项式承诺，验证者不需要下载完整的 **Blob** 数据（通常为 128KB），而只需验证一个固定大小的 **KZG 承诺**（仅 48 字节）。这种“以小博大”的验证方式是后端分布式系统实现高性能水平扩展的经典范式。


### 多项式承诺方案 (Polynomial Commitment Schemes)
多项式承诺方案允许证明者（Prover）计算一个多项式的承诺（Commitment），并具有这样一个特性：该承诺随后可以在任何位置被“打开”（即进行求值计算）。证明者可以证明该多项式在某个特定位置的值等于其声称的数值，并能为这一主张生成一个证明（Proof）。验证者（Verifier）在同时拥有“承诺”和“证明”的情况下，可以验证该证明是否有效。当且仅当证明者没有作弊时——即所承诺的多项式在选定位置的实际求值确实等于声称的数值时——验证才会通过。

#### 多项式简介 (Introduction to Polynomials)

在本节中，我们将频繁讨论多项式。由于大家可能离开学校很久了，确保每个人都清楚多项式的定义至关重要。

多项式是一种如下所示的数学表达式：

$$x^3 + 3x^2 – 9$$

其中， $x$ 是变量，所有的数字（1, 3, 0, -9）都是**系数**（Coefficients）。请注意，我们将第三个系数设为 0，因为该多项式实际上是：

$$x^3 + 3x^2 + 0x – 9$$

在本节中，我们将用 `p(x)` 来表示一个多项式：

$$p(x) = x^3 + 3x^2 + 0x – 9$$

我们还需要了解多项式的**阶数**（Degree）n。它是指多项式中最高次幂的数值。在我们的示例多项式中，阶数是3，即 n = 3。

描述多项式的通用公式如下：

$$p(x) = p_0 + p_1x + p_2x^2 + \dots + p_nx^n$$

或者更正式地表示为：

$$p(x) = \sum_{i=0}^{n} p_i x^i$$

其中，n是多项式的阶数，
$$pi$$
是其所有的系数。

#### 使用 Merkle 树 (Using Merkle Trees)

让我们先看看如何使用经典的 **Merkle 树**（Merkle tree）数据结构来实现一种多项式承诺方案。如果你有兴趣深入研究 **Merkle 树**，我们将在第 14 章中对其进行详细扩展。

我们可以通过将 **Merkle 树**的所有叶子节点元素设置为我们想要承诺的多项式的所有系数 pi，来对一个阶数为 `n = 2^d – 1,`的多项式进行承诺，其中d是树的深度。

请看以下示例：
```
p(x) = x^7 + 5x^5 – 2x^4 + 3
n = 7 ← p(x)的阶数
d = 3 ← 所需 **Merkle 树**的深度
```

图 4-9 展示了应用于此示例的多项式承诺方案，该方案使用 **Merkle 根**（Merkle roots）作为核心密码学原语。

![Figure 4-9](<./images/figure 4-9.png>)

**图 4-9. 使用 Merkle 树进行多项式承诺**

最终的承诺就是我们通过构建完整 **Merkle 树**得到的 **Merkle 根**。现在，假设我们要向验证者证明 `p(1) = 7`。这个陈述是正确的，因为如果你令`x = 1`，可以轻松计算出该多项式在该位置的求值结果为7。

为了证明我们的断言 `p(1) = 7`，我们需要向验证者发送：
1. 我们想要证明的陈述：`p(1) = 7`。
2. **Merkle 根**——即对多项式`p(x)`的承诺。
3. 多项式的所有系数`pi`。

通过这种方式，验证者可以获取所有系数`pi` 并计算当 x = 1 时多项式的值。此时，验证者验证了我们的断言确实为真。然后，验证者获取所有系数 pi 并重新计算 **Merkle 树**，将他们得到的 **Merkle 根**与我们提供的根进行比较。在这里，他们验证了我们最初承诺的多项式确实就是我们发送给他们的那一个。

回顾使用 **Merkle 树**进行多项式承诺的特性，我们得到以下结论：

**承诺大小 (Commitment size)**

承诺是 **Merkle 根**，它是一个单一的哈希值，通常长度为 **32 字节**。

**证明大小 (Proof size)**

为了证明一次求值，我们需要发送多项式的所有系数 pi。这意味着证明大小随多项式的阶数 n 呈**线性增长**。

**验证者复杂度 (Verifier complexity)**

验证者必须执行线性工作（与多项式的阶数相关）才能完全验证我们的断言。事实上，验证者拥有所有系数 pi，必须同时计算 **Merkle 树**和多项式在声明点处的求值结果。

**方案隐私性 (Scheme privacy)**

该方案不会隐藏关于多项式的任何信息，因为证明者发送了其所有的系数 `pi`。

这些特性并不理想，因为在真实的以太坊协议中，多项式的阶数 n 可能非常大，而在网络上发送其所有系数所需的带宽过高。此外，我们希望有一种协议能让证明者尽可能少地泄露关于已承诺多项式的信息。

幸运的是，有一种方案可以满足我们所有的要求，这就是 **KZG** 登场的时刻。

### KZG 承诺 (KZG Commitment)

**KZG** 是一个缩写，代表 Kate、Zaverucha 和 Goldberg，这是其三位作者的姓氏。这三位密码学家在 2010 年发表的论文《多项式的常数大小承诺及其应用》（["Constant-Size Commitments to Polynomials and Their Applications"](https://oreil.ly/JnEc0)）中引入了这种承诺方案。

#### 可信设置 (The Trusted Setup)

**KZG 承诺方案**需要存在一个**可信设置**（Trusted setup）。你可以将其视为一个由密码学协议的所有参与者（即证明者和验证者）共享的公共知识库。之所以称其为“可信设置”，是因为为了生成该公共知识库，部分参与者需要生成随机数（秘密值）、对其进行加密并创建最终数据。随后，他们必须销毁这些秘密值，以确保协议的安全性。由于必须信任这些参与者会销毁他们的秘密值，整个仪式被称为“可信设置”。

现代设置通常使用 **Powers-of-Tau** 设置，它采用 **1-of-N** 信任模型。这意味着在整个可信设置过程中，只要有一个参与者是诚实的（即销毁了其秘密值），整个设置就被认为是安全的。

以太坊的 **KZG 可信设置仪式**有超过 140,000 名不同的参与者参与其中，如图 4-10 所示。

![Figure 4-10](<./images/figure 4-10.png>)

图 4-10. 以太坊 KZG 可信设置仪式参与者情况

更具体地说，可信设置会为`[s^i]₁`, `[s^i]₂`, `i = 0, 1, … , n – 1`，其中：
1. s是无人知晓的**可信设置秘密值**（由每个参与者生成的秘密值求和而成）。
2. `[s^i]₁` 和 `[s^i]₂` 实际上是**椭圆曲线点**（分别属于G1和G2曲线）。
3. n是多项式的**阶数**。

> [!Tip]
> 当你看到方括号中的内容时，它代表一个**椭圆曲线点**。


#### 承诺 (The Commitment)
正如你所见，KZG 承诺方案（再次）涉及到了椭圆曲线和配对技术，这在我们讨论 BLS 数字签名时已经见识过了。
请记住，在椭圆曲线上，如果你有一个秘密数字 a，你可以通过椭圆曲线乘法获得一个椭圆曲线点 [a]：
```
[a]₁ = aG₁
```
而且在计算上，反向推导是不可能的。因此，如果你只拥有[a]，你无法获得秘密值 a。

尽管证明者和验证者都不知道可信设置的秘密值s，但他们仍然可以对其执行某些操作：
```
c[s^i]₁ = cs^iG₁ = [cs^i]₁  ← 椭圆曲线标量乘法；c是一个整数
c[s^i]₁ + d[s^i]₁ = (cs^i + ds^i)G₁ = [cs^i + ds^i]₁  ← 椭圆曲线点加法
```
因此，如果`p(x) = p₀ + p₁x + p₂x² + ... + pₙxⁿ`是一个多项式，证明者可以计算：
```
[p(s)]₁ = [p₀ + p₁s₁ + p₂s²₁ + ... + pₙsⁿ₁] = p₀ + p₁[s]₁ + p₂[s²]₁ + ... + pₙ[sⁿ]₁
```

由于 `[s^i]₁`是可信设置的一部分，因而是公共知识，证明者能够在无人知晓的秘密点 $s$ 处对多项式进行求值。听起来很神奇，对吧？但请注意一件重要的事情：上述操作的输出不是一个整数，而是一个椭圆曲线点。那个`[p(s)]₁`椭圆曲线点就是我们对多项式 `p(x)`的 **KZG 承诺**。

> [!Tip]
> **译者注**：
> 1. **同态属性的妙用**：作为后端开发者，你可以把这个过程想象成一种“盲计算”。在传统的程序逻辑中，计算 `f(x)` 必须知道 `x`；但在 **KZG** 中，利用椭圆曲线的加法同态特性，我们可以在不知道s的情况下，通过对预计算好的点 [s^i] 进行加权求和，强行构造出 p(s) 的加密结果。这在分布式系统中极大地提高了安全性，因为敏感算力（秘密值 s）在初始仪式后就彻底消失了，留下的只有可用的计算基准。
> 2. **数据压缩的极致**：从工程存储角度看，无论你的 **Blob** 多项式有多少项（即阶数 $n$ 有多大），经过这一系列加权求和后，最终结果永远只是一个 G1 群上的点（在 **BLS12-381** 中为 48 字节）。这种将 O(N) 复杂度的原始数据映射为 O(1) 复杂度固定长度输出的能力，使得以太坊节点在验证 **Blob** 时，内存和磁盘 I/O 的压力降到了最低。


#### KZG 的可靠性：为什么证明者无法伪造承诺 (Soundness of KZG: Why the Prover Can't Fake the Commitment)

证明者是否能在不知道秘密值s 的情况下，找到一个不同的多项式 `q(x) != p(x)`，使得它们具有相同的 **KZG 承诺**：`[q(s)]₁ = [p(s)]₁`？如果可以，证明者就能欺骗验证者，让他们以为自己知道多项式p，而事实并非如此。

假设他们可以做到，那么必然存在一个次数为n的非零多项式`r(x) = p(x) – q(x)` 。由于`q(x) != p(x)`，这意味着 r(x) 最多只有n个零点，也就是说，`r(x) = 0`最多在n个位置成立。这是代数的一个基本性质。你可以轻松验证这在你学校学过的所有基本几何图形中都成立：直线（1 次多项式）有一个零点，抛物线（2 次多项式）最多有两个，依此类推。

证明者实现 `q(s) = p(s)` 的唯一方法是尽可能多地让 `r(x) = p(x) - q(x) = 0` 成立。但正如我们前面所说，他们最多只能选择n个零点。

由于证明者不知道s，他们能够猜中它的可能性极低。事实上，n（多项式的阶数）远小于 p（椭圆曲线的阶）。

如果 `n = 228` 且 `p = 2^256`，那么s恰好是所选零点之一的概率约为 `2 × 10^-69`。

因此我们可以说，虽然确实存在许多具有相同承诺 `C = [p(s)]₁`的多项式，但在计算上是不可能找到它们的。这被称为**计算绑定性**（Computational binding）。

到目前为止，我们已经能够通过在秘密点s处求值来对多项式 `p(x)`进行承诺，但我们仍然缺少一种方法，在不向验证者发送所有系数pi的情况下，证明初始证明者的断言 `p(z) = y`是真实的。在这里，椭圆曲线配对（Pairings）再次派上了用场。

### KZG 证明 (KZG Proof)

要理解最终的 **KZG 证明**，我们需要回顾多项式的一些重要性质。

如果多项式 `p(x)` 在 z 处有一个零点（即 `p(z) = 0`），那么它就能被 `(x - z)` 整除。这非常容易理解。以多项式 `p(x) = x^2 - 4` 为例，它也可以表示为 `p(x) = (x + 2)(x - 2)`。因为 `p(2) = 4 - 4 = 0`，所以 `p(x)` 可以被 `(x - 2)` 整除。

反之亦然：如果 `p(x)` 能被 `(x - z)` 整除，那么 `p(x)` 在 `z` 处必有一个零点。你可以使用之前的例子轻松证明这一点。

请记住，我们（作为证明者）想要证明 `p(z) = y`。此时，我们构造一个新多项式 `p(x) - y`。这个多项式在 `x = z` 处的求值结果为零，因此我们可以利用前面描述的性质——特别是由于 `p(x) - y` 在 z 处有零点，它一定能被 `(x - z)` 整除。

因此，我们可以计算出**商多项式**（Quotient polynomial）`q(x)`：
```
q(x) = [p(x) – y] / (x – z)
```
我们也可以将其写成等价形式：
```
q(x)(x – z) = p(x) – y
```
> [!Note]
> 这里非常重要的一点是：商多项式 `q(x)` 只有在 `p(x) - y` 能被 `(x - z)` 整除时才能计算出来。否则，计算是不可能的，因为总会产生余数。
> 为了更好地理解这一点，让我们看一个例子。再次以 `p(x) = (x + 2)(x - 2)` 为例。由于该多项式能被 `(x + 2)` 整除，我们可以计算出商多项式：
> ```
> q(x) = p(x) / (x + 2) = [(x + 2)(x – 2)] / (x + 2) = x – 2
> ```
> 如果我们尝试除以 `(x - 3)`，我们将无法获得商多项式（会有余数）。如果你愿意，可以尝试用前面的例子验算一下……

现在我们已经完全准备好生成证明了。事实上，对于断言 `p(z) = y` 的 **KZG 证明**就是`π = [q(s)]₁` 。简单来说，它就是在秘密点s处求值的商多项式（对应的椭圆曲线点）。

验证者通过计算以下等式来检查证明的有效性：
```
e(π, [s – z]₂) = e(C – [y]₁, H)
```

其中：
* `π = [q(s)]₁` 是 **KZG 证明**。
* `C = [p(s)]₁` 是对多项式 `p(x)` 的**承诺**。
* `H` 是 G2 群的生成元，证明者和验证者均已知。

让我们证明该密码学方案同时具备：
1. **完备性 (Correctness)**：如果证明者遵守所有规则，他们必须能够生成一个有效的证明，且验证者能够正确验证。
2. **可靠性 (Soundness)**：证明者无法通过计算伪造的证明来欺骗验证者——即证明者无法让验证者相信对于某个 `p(z) = y′`，`y′ != y` 成立。

#### 完备性 (Correctness)
如果我们取验证者方程并将其写入配对群（本质上是计算配对运算），我们得到：
```
[q(s)(s – z)]ₜ = [p(s) – y]ₜ
```
其中 T 是有限域扩张的一个乘法子群。
你可以看到，这个等式与我们之前计算的等式完全相同：
```
q(x)(x – z) = p(x) – y
```
只不过是在秘密点 s 处进行的求值。唯一的区别是我们现在处理的是椭圆曲线点而不是普通数字。
根据构造，该等式始终成立。这就是完备性部分的证明。

#### 可靠性 (Soundness)
证明者能伪造证明吗？也就是说：证明者能否在 `p(z) = y'` 不成立的情况下，声称其成立并仍通过验证者的检查？
为了尝试这样做，证明者有两种选择：

1. **尝试遵循正常程序**，仅更改声称的值 `y'`。为此，他们必须通过将 `p(x) - y'` 除以 `(x - z)` 来计算商多项式。但这在数学上是不可能的，因为 `p(z) – y′ != 0`，此时多项式除法无法除尽。你可能会好奇：如果证明者能选出一个 `y′ != y` 使得 `p(x) – y′ = 0` 呢？实际上，我们在之前的说明中已经给出了答案：这种概率几近于零。证明者无法算出这样一个 `y′`。因此，第一种方案并非切实可行。

2. **在构造证明时直接在椭圆曲线上操作**。事实上，如果他们能够生成如下证明：
   ```
   π′ = [C – y′] / [s – z]₂
   ```
   那么他们就能证明任何他们想要的东西：
   ```
   e(π′, [s – z]₂) = e(C – [y′]₁, H) →
   → e(π′, [s – z]₂) = e(C – [y′]₁, H) →
   → (C - y`)/(s - z)*(s - z) = C - y` →
   → C - y` = C - y`  ← 这始终为真.
   ```
   
   但同样地，对于证明者来说，计算出这个证明在计算上是不可能的，因为这需要知道s的值，而s是可信设置的秘密，无人知晓。


### KZG 的特性 (KZG Properties)

总结使用 **KZG 证明系统**进行多项式承诺的特性如下：

**承诺大小 (Commitment size)**

承诺是支持配对的椭圆曲线上的一个单一群元素。例如，在 **BLS12-381** 曲线中，其压缩形式的长度为 **48 字节**。

**证明大小 (Proof size)**

证明的大小与所承诺的多项式 `p(x)` 的大小（阶数）无关。它始终是一个单一的椭圆曲线群元素。

**验证者复杂度 (Verifier complexity)**

验证过程同样独立于多项式的大小，仅需要两次（椭圆曲线）群乘法和两次配对（Pairings）运算。

**方案隐私性 (Scheme privacy)**

该方案能够很大程度上隐藏证明者所承诺的多项式 `p(x)`。事实上，在使用 **Merkle 树**时，证明者必须发送所有的系数；而在使用 **KZG** 时，他们只需发送在秘密点 $s$ 处求值的商多项式，尽管它是一个椭圆曲线点而非整数。


### 多重证明 (Multiproofs)

我们已经能够证明多项式 `p(x)` 的单个求值结果，但我们还可以做得更多。我们可以证明多项式在任意数量点上的求值结果，并且仍然保持相同的证明大小。

让我们看看这是如何运作的。我们想要证明对于每一个 `zᵢ`，`p(x)` 的求值结果为 `yᵢ`：
```
(z₀, y₀), (z₁, y₁), …, (zₖ₋₁, yₖ₋₁)
```
我们总能找到一个阶数低于k的多项式通过所有这些点。这是一个代数性质，并且有一个数学公式可以生成该多项式，即**插值多项式** (Interpolation polynomial) `I(x)`：
```
I(x) = Σ yᵢ · ∏ (x – zⱼ)/(zᵢ – zⱼ)  (for i,j = 0 to k-1, j ≠ i)
```
虽然这听起来很难，但实际上非常容易理解。假设我们有两个不同的点，如图 4-11 所示：
```
A = (1, 0)
B = (2, 1)
```
![Figure 4-11](<./images/figure 4-11.png>)

图 4-11. 两个不同的点 A 和 B

很容易理解，存在一条直线——即阶数为 1 的多项式（小于点的数量 2）——同时穿过 A 和 B。

这条直线是：
```
I(x) = x – 1
```
图 4-12 更好地说明了这一点。

![Figure 4-12](<./images/figure 4-12.png>)

图 4-12. 通过点 A 和 B 的插值多项式（直线）

这里我们使用了直觉，但我们可以使用公式来证明结果是一样的。记住这里`k = 2`：
```
I(x) = y₀ · (x – z₁)/(z₀ – z₁) + y₁ · (x – z₀)/(z₁ – z₀)
     = 0 · (x – 2)/(1 – 2) + 1 · (x – 1)/(2 – 1)
     = 0 + (x – 1) = x – 1
```
由于证明者想要证明 `p(x)` 通过本节开头提到的所有点，如果我们假设这是真的（即证明者是诚实的），那么 `p(x) - I(x)` 在每个点 `z₀, z₁, …, zₖ₋₁`处都为零。

这意味着它能被 `(x – z₀)(x – z₁)...(x – zₖ₋₁)`整除。我们将这个多项式 `Z(x)` 称为**零化多项式** (Zerofier)。

现在，我们按照通常的方法进行。证明者计算商多项式 `q(x)`：
```
q(x) = [p(x) – I(x)] / Z(x)
```
并生成证明 `π = [q(s)]₁`。请注意，这个证明仍然是通常的（单个椭圆曲线点）**KZG 证明**。

为了检查该证明的有效性，验证者需要：

1. 应用前面描述的公式计算 `I(x)`，然后计算 `[I(s)]₁`。
2. 计算 `Z(x)`，然后计算 `[Z(s)]₂`。请注意，验证者可以计算 `Z(x)`，因为他们知道证明者想要证明的所有声明点（及其值）。
3. 然后应用通常的等价性检查：
   `e(π, [Z(s)]₂) = e(C – [I(s)]₁, H)`

通过在配对群 (Pairing group) 中写入等式：
```
q(s)Z(s) = p(s) – I(s)
```
这与之前证明者计算商多项式时的等式相同，唯一的区别是这里它是在秘密点s处求值的。

### 总结 (In Summary)

让我们总结一下 **KZG 承诺方案**中完整的证明者（Prover）与验证者（Verifier）交互流程。

首先从证明者开始，他拥有某些数据。他们立即将这些数据编码为一个多项式，如图 4-13 所示。

![Figure 4-13](<./images/figure 4-13.png>)

图 4-13. 证明者将数据编码为多项式 p

证明者的目标是说服验证者他确实知道某段数据（现已编码为多项式）。然而，证明者不想泄露整个数据集。相反，他们希望验证者能够验证关于该数据的特定声明。特别地，证明者希望验证者确认该多项式在特定点处的求值结果符合预期，如图 4-14 所示。

![Figure 4-14](<./images/figure 4-14.png>)

图 4-14. 证明者想要证明多项式在特定点处的求值结果

为了实现这一目标，证明者计算多项式的 **KZG 承诺**并将其发送给验证者，如图 4-15 所示。

![Figure 4-15](<./images/figure 4-15.png>)

图 4-15. 证明者计算 KZG 承诺 C 并发送给验证者

随后，证明者需要为他们想要向验证者证明的所有求值结果计算 **KZG 证明**，如图 4-16 所示。

![Figure 4-16](<./images/figure 4-16.png>)

图 4-16. 证明者计算多项式不同求值结果的 KZG 证明并发送给验证者

现在轮到验证者了。为了确保证明者是诚实的，验证者需要利用证明者先前发送的信息以及**可信设置**（Trusted setup）来计算椭圆曲线配对检查，如图 4-17 所示。

![Figure 4-17](<./images/figure 4-17.png>)

图 4-17. 验证者通过椭圆曲线配对运算检查求值的有效性


## 结论 (Conclusion)

我们对公钥密码学（PKC）进行了综述，重点讨论了公钥和私钥在以太坊中的应用，以及哈希函数等密码学工具在创建和验证以太坊地址中的作用。我们还研究了数字签名及其如何在不泄露私钥的情况下证明私钥的所有权。在第 5 章中，我们将把这些概念整合起来，探讨如何使用钱包来管理密钥集合。


[^1]: 椭圆曲线的无穷远点 (Point at Infinity, O) 是一个虚拟点，用于在射影坐标系中补全加法群的封闭性。P + (-P) = O
[^2]: 其实就是点乘或者标量乘法，在椭圆曲线密码学（ECC）中，最核心的问题是椭圆曲线离散对数问题 (ECDLP)。这里，我们知道 \(T=mS\) 中的点 \(T\) 和 \(S\)，但要求解整数 \(m\)，这个 \(m\) 就被称为离散对数或指数，因为它在计算中扮演了“次数”的角色，类似于普通数论中的指数。
[^3]: 第一版中没有这部分内容，这是很好的补充。
