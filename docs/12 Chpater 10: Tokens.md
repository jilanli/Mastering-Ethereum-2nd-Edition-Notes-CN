# 第十章：代币

“Token”（代币）一词源于古英语中的 tācen[^1]，意为符号或象征。它通常被用来指代由私人发行、具有特殊用途、且本身内在价值微乎其微的类硬币物品，例如交通代币（车票）、洗衣代币或游戏机代币。如今，在区块链上运行的代币正在重新定义这个词：它们是基于区块链的抽象概念，可以被所有，并代表资产、货币或访问权限。

“代币”一词与“价值微不足道”之间的联系，在很大程度上与物理代币的有限用途有关。物理代币通常局限于特定的商家、组织或地点，不易交换，且通常只有单一功能。而通过区块链代币，这些限制被解除，或者更准确地说，被完全重新定义了。许多区块链代币在全球范围内具有多种用途，并可以在全球流动性市场中互相交易，或兑换成其他货币。随着使用和所有权限制的消失，对其“价值微不足道”的预期也成为了过去。

在本章中，我们将研究代币的各种用途及其创建方式。我们还将讨论代币的属性，如同质化（Fungibility）和内在性（Intrinsicality）。最后，我们将研究它们所基于的标准和技术，并尝试构建我们自己的代币。

## 代币的用途

代币最显而易见的用途是作为数字私人货币。然而，这仅仅是其可能的用途之一。代币可以通过编程来实现许多不同的功能，而且这些功能往往相互重叠。例如，一个代币可以同时传达投票权、访问权和资源所有权。如下表所示，货币仅仅是代币的第一个“应用”：

* 货币（Currency）：代币可以作为一种货币形式，其价值通过私人贸易决定。

* 资源（Resource）：代币可以代表在分享经济或资源共享环境中赚取或生产的资源——例如，代表可在网络上共享的存储或 CPU 资源的代币。

* 资产（Asset）：代币可以代表对内在或外在、有形或无形资产的所有权——例如黄金、房地产、汽车、石油、能源、大型多人在线游戏（MMOG）物品等。

* 访问权（Access）：代币可以代表访问权限，并允许进入数字或物理财产，如讨论论坛、专属网站、酒店房间或租赁车辆。

* 股权（Equity）：代币可以代表数字组织（如 DAO）或法律实体（如公司）中的股东权益。

* 投票（Voting）：代币可以代表数字或法律系统中的投票权。

* 收藏品（Collectible）：代币可以代表数字收藏品（如 CryptoPunks）或实物收藏品（如画作）。

* 身份（Identity）：代币可以代表数字身份（如虚拟头像）或法律身份（如国民身份证）。

* 证明（Attestation）：代币可以代表由某些机构或去中心化信誉系统出具的事实认证或证明（例如结婚记录、出生证明或大学学位）。

* 实用性（Utility）：代币可以用于访问服务或为服务付费。

通常，单个代币会涵盖其中的多项功能。有时很难将它们区分开来，因为在物理世界中，它们的等价物总是密不可分的。
例如，在物理世界中，驾照（证明）同时也是身份证明文件（身份），两者无法分离。但在数字领域，此前交织在一起的功能可以被分离并独立开发（例如，匿名证明）。

## 代币与同质化

[维基百科](https://oreil.ly/ge7zP)指出：“在经济学中，同质化（Fungibility）是指一种商品或货物的属性，其个体单位在本质上是可以互相互换的。”当我们可以将代币的任何单一单位替换为另一单位，且其价值或功能没有任何区别时，这种代币就是同质化的。

非同质化代币（NFTs） 是指每一个都代表唯一的有形或无形物品的代币，因此它们是不可互换的。例如，一个代表特定梵高画作所有权的代币，并不等同于另一个代表毕加索画作的代币，尽管它们可能属于同一个“艺术品所有权代币”系统。
同样，代表特定数字收藏品的代币（如某只特定的 CryptoKitty 加密猫），也无法与任何其他 CryptoKitty 互换。每个 NFT 都关联着一个唯一的标识符，例如序列号。

我们将在本章稍后部分看到同质化和非同质化代币的示例。
> [!Note]
> 请注意，“Fungible”一词在日常生活中常被误用来表示“可直接兑换成金钱”（例如，赌场代币可以“兑现”，而洗衣代币通常不行）。这不是我们在此处使用该词的含义。

## 对手方风险

对手方风险是指交易中的另一方未能履行其义务的风险。某些类型的交易会面临额外的对手方风险，因为其中涉及两个以上的参与方。
例如，如果你持有一份贵金属的存款证明并将其卖给他人，那么该交易中至少存在三个参与方：卖家、买家以及贵金属的托管人。由于有人持有实物资产，他们必然会成为交易履行的一方，并为任何涉及该资产的交易增加对手方风险。

通常，当资产通过所有权代币进行间接交易时，资产托管人会带来额外的对手方风险。他们真的持有该资产吗？
他们是否会承认（或允许）基于代币（如凭证、契据、产权证或数字代币）转移而发生的所有权变更？在代表资产的数字代币领域，与非数字世界一样，了解谁持有代币所代表的资产，以及适用于该底层资产的规则是什么，都至关重要。

## 代币与内在性

“Intrinsic”（内在的）一词源于拉丁语的 intra，意为“来自内部”。有些代币代表的是区块链内部固有的数字物品。这些数字资产与代币本身一样，都受共识规则的管辖。这产生了一个重要的影响：代表内在资产的代币不承担额外的对手方风险。
如果你持有一个 CryptoKitty 的私钥，并没有任何其他方为你代管这只加密猫——你直接拥有它。区块链共识规则适用，你对私钥的所有权（即控制权）等同于对该资产的所有权，无需任何中间人。

相反，许多代币被用来代表外在（Extrinsic）事物，例如房地产、公司投票股、商标、金条和债券。这些物品并不存在于区块链“内部”，其所有权受法律、习俗和政策的管辖，与管辖代币的共识规则相互独立。
换句话说，代币发行者和持有者可能仍需依赖现实世界的非智能合约。结果是，这些外在资产具有额外的对手方风险，因为它们由托管人持有、记录在外部登记机构中，或受区块链环境之外的法律和政策控制。

基于区块链的代币最重要的影响之一，就是能够将外在资产转化为内在资产，从而消除对手方风险。一个典型的例子是从公司股权（外在）转向 DAO（去中心化自治组织）或类似组织中的股权或投票代币（内在）。
稳定币是另一个例子，它们作为锚定法定货币的区块链代币，由国库券和现金储备等外在资产提供支持。

## 实用、股权，还是圈钱陷阱？

几乎每一个以太坊项目在启动时似乎都会发行某种代币。但所有这些项目真的都需要代币吗？“将万物代币化”的口号听起来很响亮，但现实要复杂得多。
代币可以是组织和激励社区的强大工具，但它们也已成为投机和炒作的代名词。

理论上，代币主要有两个用途。首先是实用型代币（Utility Tokens）。它们旨在提供对特定生态系统内服务或资源的访问权。例如，某种代币可能代表去中心化网络上的存储空间，
或者是 DApp（去中心化应用）中高级功能的访问权限。在这种情况下，代币的价值与其在平台内的功能挂钩。其次是股权型代币（Equity Tokens），其功能理应类似于公司的股票。这些代币可以代表对项目的所有权或控制权，例如 DAO 中的投票权或利润分成。

然而在实践中，这两类代币的界限往往非常模糊。许多实用型代币在很大程度上仍具有投机性，用户持有它们更多是将其作为资产，而非访问凭证。类似于股权的代币虽然可能赋予治理权，
但往往缺乏确保成员有效参与的机制。有些项目将代币深度整合到其经济模型中，但这只是例外，而非普遍现象。

这就引出了一个问题：代币本质上是坏的吗？并非如此。代币在创建和激励社区，或驱动 DAO 的去中心化治理方面可以非常有效。但现实情况是，大多数代币在推出时，
获利而非实用性才是主要驱动力。如果你正考虑发行或投资一种代币，值得问几个尖锐的问题：该代币在协议中是否真的起到了必不可少的作用，还是仅仅是一个筹款工具？如果没有它，项目是否也能运行得一样好？诚实地回答这些问题，可以帮助你区分真正的创新与营销驱动的炒作。

显然，代币领域仍在不断演变。代币本身并无好坏之分，其价值取决于其设计和实现方式。挑战在于如何将有意义的事物与毫无意义的事物区分开来，并抵御下一个“模因币”（Meme Coin）的诱惑。

> [!Note]
> 在撰写本章期间（2025 年 1 月），新当选的总统唐纳德·特朗普推出了他自己的模因币（Meme coin），该代币在一天之内市值就达到了 150 亿美元。此前许多人曾期待他在任期内会推出有利的加密货币政策，
> 然而，我们等来的却是一个模因币。这一事件突显了主导加密货币领域的投机狂热——在这种环境下，炒作往往战胜了实质内容。

## 它就是一只鸭子！

长期以来，代币一直是初创公司最青睐的融资工具。它们许诺创新、去中心化，有时甚至是彻底的财务自由。但问题在于：在大多数司法管辖区，向公众发行证券是一项受监管的活动，而代币很容易跨越红线进入证券领域。
多年来，各项目一直试图通过将自己的代币贴上“实用型代币”的标签来规避监管，声称它们只是对未来服务访问权的预售。其逻辑是：如果代币不是股权，它就不是证券。但正如那句老话所说：“如果它走起来像鸭子，叫起来也像鸭子，那它就是一只鸭子。” 监管机构，尤其是美国证券交易委员会（SEC），正盯紧了这些“鸭子”。

在过去的几年里，SEC 对代币发行采取了日益激进的立场，打击那些试图在实用性与股权之间“横跳”的项目。例如，2020 年，SEC 起诉了 Ripple Labs 及其发行的 XRP 代币，指控其为未经注册的证券。
Ripple 辩称 XRP 是货币而非证券，但法院的后续裁决显示了这类案件的复杂程度。

即使是以太坊本身也未能免于审查。早在 2018 年，前 SEC 官员曾宣布以太币已经“足够去中心化”，因此不属于证券。但就在 2024 年，SEC 暗示以太坊向权益证明（PoS）的转型可能会让它重新回到显微镜下。
为什么？因为质押奖励（Staking rewards）类似于红利，而红利是证券的核心特征。这些进展表明，监管环境已变得多么反复无常且难以预测。

令人着迷——同时也令人沮丧——的是，这些案件往往演变成了语义之争。项目方坚称其代币是实用工具，就像服务的门票。但如果购买者的主要动机是投机，SEC 就会将其视为证券，简单明了。
挑战在于，用于做出这些判定的法律框架早在区块链技术出现之前就已存在。诞生于 20 世纪 40 年代的“豪威测试”（Howey Test）旨在定义投资合同，并非为去中心化网络或可编程资产而设计。因此，将其应用于加密项目并不总是那么直接。创新者想要筹集资金并建立社区，而监管机构则想要保护投资者免受误导。其结果便是：一场又一场法庭大戏不断上演，数亿资金和整个生态系统的命运悬于一线。

## 以太坊上的代币

区块链代币早在以太坊之前就已存在。从某种意义上说，第一种区块链货币——比特币本身就是一种代币。在以太坊出现之前，许多代币平台也已在比特币和其他加密货币之上开发出来。然而，以太坊上第一个代币标准的引入，才真正引发了代币的爆炸式增长。

维塔利克·布特林（Vitalik Buterin）曾建议，代币是像以太坊这样通用的可编程区块链最显而易见且最有用的应用之一。事实上，在以太坊运行的第一年里，经常能看到维塔利克和其他人穿着印有以太坊 Logo 的 T 恤，
背后则是智能合约的示例代码。这些 T 恤有几个版本，但最常见的一款展示的就是代币的实现代码。

在我们深入研究如何在以太坊上创建代币的细节之前，了解代币在以太坊上是如何运行的宏观图景至关重要。代币与以太币（Ether）不同，因为以太坊协议本身对代币一无所知。 
发送以太币是以太坊平台的内在行为，但发送甚至拥有代币则不然。以太坊账户的以太币余额是在协议层处理的，而以太坊账户的代币余额则是在智能合约层处理的。

要在以太坊上创建一种新代币，你必须创建一个新的智能合约。一旦合约部署完成，它将处理包括所有权、转账和访问权限在内的一切事务。你可以按照任何你想要的方式编写智能合约来执行所有必要的操作，但遵循现有标准可能是最明智的做法。接下来我们将探讨这些标准。


## ERC-20 代币标准

第一个代币标准由 Fabian Vogelsteller 于 2015 年 11 月作为一项 ERC（以太坊意见征求稿）提出。该提案被自动分配了 GitHub 问题编号 20，因此得名“ERC-20 代币”。
目前绝大多数代币都基于 ERC-20 标准。虽然该提案最终成为了 EIP-20（以太坊改进提案），但人们大多仍沿用其最初的名称：ERC-20。

ERC-20 是同质化代币的标准，这意味着 ERC-20 代币的不同单位是可以互换的，且不具备唯一属性。ERC-20 标准为实现代币的合约定义了一个通用接口，
使得任何兼容该标准的代币都可以通过相同的方式被访问和使用。该接口由一系列必须在标准实现中存在的函数组成，同时也包含了一些开发者可以自行添加的可选函数和属性。

### ERC-20 强制性函数与事件

一个符合 ERC-20 标准的代币合约必须至少提供以下函数和事件：

**totalSupply**

返回当前存在的代币总单位数。ERC-20 代币的供应量可以是固定的，也可以是可变的。

**balanceOf**

给定一个地址，返回该地址拥有的代币余额。

**transfer**

给定地址和金额，从执行转账的地址余额中向目标地址转入相应数量的代币。

**transferFrom**

给定发送者、接收者和金额，将代币从一个账户转移到另一个账户。该函数通常与 approve 配合使用。

**approve**

给定接收地址和金额，授权该地址从授权账户中多次执行转账，总额不超过设定的金额。

**allowance**

给定所有者地址和支出者（spender）地址，返回支出者仍被授权从所有者处提取的余额。

**Transfer（事件）**

在转账成功（调用 transfer 或 transferFrom）后触发，即使转账金额为零也应触发。

**Approval（事件）**

在成功调用 approve 后记录的事件。

#### ERC-20 可选函数

除了上一节列出的强制性函数外，该标准还定义了以下可选函数：

**name**

返回代币的人类可读名称（例如：“US dollars”）。

**symbol**

返回代币的人类可读符号（例如：“USD”）。

**decimals**

返回用于划分代币金额的小数位数。例如，如果小数位数为 2，那么 1,000 的代币单位量实际上代表 10.00 的余额。

#### 用 Solidity 定义的 ERC-20 接口

以下是 ERC-20 接口规范在 Solidity 中的样子：
```Solidity
contract ERC20 {
   function totalSupply() public view returns (uint256 theTotalSupply);
   function balanceOf(address _owner) public view returns (uint256 balance);
   function transfer(address _to, uint256 _value) public returns (bool success);
   function transferFrom(address _from, address _to, uint256 _value) public returns
      (bool success);
   function approve(address _spender, uint256 _value) public returns (bool success);
   function allowance(address _owner, address _spender) public view returns
      (uint256 remaining);
   event Transfer(address indexed _from, address indexed _to, uint256 _value);
   event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}
```

#### ERC-20 数据结构

如果你去研究任何一个 ERC-20 的实现方案，你会发现它包含两个核心数据结构：一个用于追踪余额（Balances），另一个用于追踪授权额度（Allowances）。
在 Solidity 中，它们是通过**数据映射**（Mapping）实现的。

第一种数据映射实现了一张按所有者分类的代币余额内部表。这使得代币合约能够记录谁拥有这些代币。每一次转账本质上都是从一个余额中扣除，并增加到另一个余额中：
```Solidity
mapping(address account => uint256) _balances;
```
第二种数据结构是授权额度的映射。正如我们在下一节将看到的，对于 ERC-20 代币，所有者可以向支出者（Spender）委派权限，
允许他们从所有者的余额中支出特定金额（即授权额度）。ERC-20 合约使用一个二维映射来记录这些授权额度，其主键是代币所有者的地址，映射到支出者地址及相应的授权金额：
```Solidity
mapping(address account => mapping(address spender => uint256)) public _allowances;
```

#### ERC-20 工作流程：“Transfer” 与 “Approve 和 TransferFrom”

ERC-20 代币标准拥有两个转账函数。你可能会纳闷这是为什么。

ERC-20 允许两种不同的工作流程。第一种是使用 transfer 函数的直观单笔交易流程。钱包向其他钱包发送代币时，使用的正是这种流程。绝大多数代币交易都是通过 transfer 流程完成的。

执行 transfer 合约非常简单：如果 Alice 想给 Bob 发送 10 个代币，她的钱包会向代币合约地址发送一笔交易，调用 transfer 函数，并将 Bob 的地址和数值 10 作为参数传入。
代币合约随后调整 Alice 的余额（-10）和 Bob 的余额（+10），并发布一个 Transfer 事件。

第二种是先后使用 approve 和 transferFrom 的两笔交易流程。这种流程允许代币所有者将控制权委派给另一个地址。它最常用于将控制权委派给某个合约以进行代币分发，但也可以被交易所使用。
例如，如果一家公司正在进行 ICO 售卖代币，他们可以向一个众筹（Crowdsale）合约地址进行 approve（授权），允许其分发特定数量的代币。随后，众筹合约就可以执行 transferFrom，
将代币合约所有者的余额转移给每一位代币买家。就像图 10-1 中展示的。
![Figure 10-1](<./images/figure 10-1.png>)
图 10-1：ERC-20 代币的“Approve”与“TransferFrom”两步工作流

对于 approve 和 transferFrom 工作流，需要执行两笔交易。假设 Alice 想要允许 AliceICO 合约将总供应量 50% 的 AliceCoin 代币出售给像 Bob 和 Charlie 这样的买家。
首先，Alice 部署 AliceCoin ERC-20 合约，并将所有代币发行到她自己的地址。接着，Alice 部署可以由以太币（Ether）换取代币的 AliceICO 合约。
下一步，Alice 启动 approve 和 transferFrom 流程。她向 AliceCoin 合约发送一笔交易，调用 approve 函数，参数为 AliceICO 合约的地址以及总供应量的 50%。
这将触发 Approval 事件。现在，AliceICO 合约便获得了出售 AliceCoin 的权限。

当 AliceICO 合约从 Bob 那里收到以太币时，它需要向 Bob 回传相应数量的 AliceCoin。在 AliceICO 合约内部设定了 AliceCoin 与以太币之间的汇率。Alice 在创建 AliceICO 合约时设定的汇率，
决定了 Bob 发送一定量以太币后能获得多少代币。当 AliceICO 合约调用 AliceCoin 的 transferFrom 函数时，它将 Alice 的地址设为发送方（sender），将 Bob 的地址设为接收方（recipient），
并根据汇率计算出要转移给 Bob 的 AliceCoin 数量填入 value 字段。随后，AliceCoin 合约将余额从 Alice 的地址转移到 Bob 的地址，并触发 Transfer 事件。
只要不超过 Alice 设定的授权限额，AliceICO 合约可以无限次调用 transferFrom。AliceICO 合约可以通过调用 allowance 函数来实时追踪它还能出售多少 AliceCoin。

#### ERC-2612：通过 “Permit” 实现的无 Gas 转账

在第 9 章中，我们详细探讨了 ERC-20 代币传统的 transfer 和 transferFrom 流程。虽然这些方法一直是代币转账的中流砥柱，但它们并非没有局限性。
两者都要求发送者直接与区块链交互，这意味着他们手头必须拥有一些原生加密货币（如 ETH）来支付 Gas 费。这造成了一个巨大的障碍，尤其是当代币被发送到一个没有任何原生资金的新地址时。这种体验令人沮丧，远非理想。

这正是 ERC-2612 大显身手的地方。它是对 ERC-20 代币标准的一个巧妙补充，允许用户在无需亲自接触区块链的情况下批准代币转移。
它的工作原理是这样的：你不再需要发送链上交易来授权（Approve）转账，而是只需使用钱包对必要的数据（如接收者地址、代币数量、过期时间和 Nonce 值）进行签名。
这会生成一个签名，而任何需要执行转账的人（无论是接收者还是第三方）都可以将该签名提交给代币合约的 permit 方法。合约读取并验证签名，随后处理授权——这一切都无需你为初始步骤支付 Gas 费。
它既高效又安全，大大减少了流程中的麻烦。

要实现 ERC-2612，代币开发者需要在其 ERC-20 合约中扩展此功能。一旦部署，它将为用户带来两大核心收益：首先，它简化了整个流程。
用户只需一个签名即可授予权限，而无需逐一授权每一笔转账。其次，由于减少了所需的交易次数，它节省了 Gas 成本。

#### ERC-20 的实现方案

虽然可以用大约 30 行 Solidity 代码实现一个兼容 ERC-20 的代币，但大多数实际方案要复杂得多。这是为了应对潜在的安全漏洞。
EIP-20 标准提到了两种实现方案，分别由 Consensys 和 OpenZeppelin 开发。Consensys 的 EIP-20 代币自 2018 年起已停止维护，
而 [OpenZeppelin 的 ERC-20 代币](https://oreil.ly/7d7RD) 则成为了开发者的事实标准，并一直保持活跃维护。
该实现方案构成了 OpenZeppelin 库的基础，用于实现更复杂的兼容 ERC-20 的代币，例如带有融资上限、代币化金库、归属计划（Vesting）等功能的代币。

### 发行我们自己的 ERC-20 代币

让我们来创建并发行属于我们自己的代币。在本例中，我们将使用 Foundry 框架。本示例假设你已经安装了 Foundry 并完成了相关配置，且熟悉其基本操作。

我们将把我们的代币命名为 “Mastering Ethereum Token”，符号为 MET。首先，让我们使用以下命令创建并初始化一个 Foundry 项目目录：
```Bash
$ mkdir METoken
$ cd METoken
$ forge init
```
完成上述初始化命令后，你的项目应该呈现如下目录结构。
```
METoken/
├── foundry.toml
├── lib
│   └── forge-std
│       └── ...
├── README.md
├── script
│   └── Counter.s.sol
├── src
│   └── Counter.sol
└── test
    └── Counter.t.sol
```
Counter 是 Foundry 的默认示例合约，自带相关的测试和部署脚本。我们将删除所有与之相关的文件，为我们的代币合约腾出空间。

在本例中，我们将导入 OpenZeppelin 库，它是基于 Solidity 开发代币的行业标准：
```Bash
$ forge install OpenZeppelin/openzeppelin-contracts
[...]
Installed openzeppelin-contracts v5.2.0
```
在 METoken/lib/openzeppelin-contracts/contracts 目录下，我们现在可以看到所有的 OpenZeppelin 合约。虽然 OpenZeppelin 库包含的内容远超 ERC-20 代币标准，但我们只会使用其中的一小部分。

接下来，让我们编写代币合约。创建一个新文件 METoken.sol，并复制示例 10-1 中的代码。我们的合约非常简单，因为它从 OpenZeppelin 库中继承了所有功能。
示例 10-1：METoken.sol —— 一个实现 ERC-20 代币的 Solidity 合约
```Solidity
pragma solidity 0.8.28;
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
contract METoken is ERC20 {
    constructor(uint256 initialSupply) ERC20("METoken", "MET") {
        _mint(msg.sender, initialSupply);
    }
}
```
在这里，我们将 "METoken" 和 "MET" 作为名称和符号传递给 ERC-20 合约的构造函数。代币的**初始供应量**（Initial Supply）在部署期间作为构造函数参数提供，
并会被发送给该代币合约的部署者（msg.sender）。我们使用了默认的 decimals（小数位数）值 18，这是 ERC-20 代币广泛采用的标准。

现在我们可以使用 Foundry 来编译 METoken 合约：
```Bash
$ forge build
[⠊] Compiling...
[⠒] Compiling 6 files with Solc 0.8.28
[⠢] Solc 0.8.28 finished in 36.18ms
Compiler run successful!
```
让我们设置一个部署脚本，将 METoken 合约发布到区块链上。在 METoken/script 文件夹中创建一个新文件 METokenDeploy.s.sol，并复制以下代码：

```Solidity
pragma solidity 0.8.28;
import {Script, console} from "forge-std/Script.sol";
import {METoken} from "../src/METoken.sol";
contract METokenDeployer is Script {
    METoken public _METoken;
    function run() public {
        vm.startBroadcast();
        _METoken = new METoken(50_000_000e18);
        vm.stopBroadcast();
    }
}
```
在这个例子中，我们传入了 5000 万作为初始供应量。你注意到我们乘以了 1e18 吗？这就是代币的小数位数（decimals）。
请记住，为了获得 X 个代币的余额，我们需要输入的代币数量为 $X \times 10^{decimals}$。

> [!Note]
> 脚本文件的后缀 .s.sol 是 Foundry 的一项命名约定，用于快速识别文件的用途。这并不是强制性的要求——只需将脚本文件存放在 script 文件夹内即可——但这是一个非常好的实践，
> 会在开发过程中带来很多便利。同样，带有 .t.sol 后缀的测试文件也适用这一约定。

在我们部署到以太坊测试网络之前，先启动一个本地区块链来测试一切。我们将使用 Foundry 工具箱中的另一个工具：Anvil，一个本地以太坊开发节点。

要使用它，只需打开一个新的终端窗口并输入 anvil。控制台将显示一系列可用账户及其私钥、链 ID（Chain ID）、RPC URL 等信息。
RPC URL 是允许 Foundry（或任何以太坊客户端）与我们的本地区块链节点通信的端点，从而实现交易、合约部署和数据查询。Anvil 默认的 RPC 地址是 `http://127.0.0.1:8545`。
为了告诉部署脚本在本地链上进行部署，我们需要通过控制台参数提供该 URL，并带上标志位 `--rpc-url "http://127.0.0.1:8545"`。

最后我们需要的是部署者账户的私钥。由于这是一个本地区块链，我们在以太坊主网或测试网使用的地址在这里不会有任何资金，而且我们也不希望非必要地暴露真实的私钥。相反，我们将使用 Anvil 启动时生成的测试账户。这些账户在本地链上预装了 10,000 ETH，非常适合开发和测试。

我们已经准备好通过运行以下命令来部署代币：

```Bash
$ forge script script/METokenDeploy.s.sol --broadcast --rpc-url "http://127.0.0.1:8545"
--private-key <DEPLOYER_PRIVATE_KEY>
[⠊] Compiling...
No files changed, compilation skipped
Script ran successfully.
```
> [!Note]
> 你可能想知道 --broadcast 标志是干什么用的。它是用来告诉 Foundry 真正将交易广播到区块链上。
> 如果没有这个标志，Foundry 只会模拟执行（Simulate）该交易，而不会产生真实的链上变更。

控制台输出告知我们部署脚本运行成功。如果我们查看运行 Anvil 的那个终端窗口，会发现大量的活动日志，其中就包括我们的合约创建信息：
```
   Transaction: 0xd01e3a90e1f2ee60112658e92f4ebf04c24df67d2ec1315cfb79d145729d15ec
    Contract created: 0x5FbDB2315678afecb367f032d93F642f64180aa3
    Gas used: 941861
    Block Number: 1
    Block Hash: 0x748b6058dea932317cacf45bb63be82f253554f359b97ace224e35979a92b00a
    Block Time: "Fri, 31 Jan 2025 19:10:42 +0000"
```
我们的 METoken 已成功部署到以下地址：
```
0x5FbDB2315678afecb367f032d93F642f64180aa3
```
或者，我们也可以直接使用 Forge 的 create 控制台命令来部署代币：
```Bash
$ forge create METoken --broadcast --rpc-url http://127.0.0.1:8545 --private-key
<DEPLOYER_PRIVATE_KEY> --constructor-args 50000000000000000000000000
```
在这里，总供应量作为构造函数参数传入，并且已经将小数位数（decimals）计算在内。

#### Interacting with METoken


[^1]: 这个词有纯正的日耳曼语血统，既不来自拉丁语，也不来自希腊语。
