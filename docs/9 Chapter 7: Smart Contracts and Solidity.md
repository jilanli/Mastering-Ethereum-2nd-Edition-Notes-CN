# 第 7 章：智能合约与 Solidity

正如我们在第 2 章中讨论过的，以太坊中有两种不同类型的账户：外部账户（EOA）和合约账户。EOA 由用户控制，通常是通过以太坊平台之外的软件（如钱包应用）来操作。相比之下，合约账户由程序代码（通常也被称为智能合约）控制，这些代码由 EVM（以太坊虚拟机）执行。

简而言之，EOA 是不关联任何代码或数据存储的简单账户，而合约账户则既有关联代码又有数据存储。EOA 由交易控制，这些交易是在独立于协议之外的“现实世界”中创建，并使用私钥进行加密签名的；而合约账户没有私钥，因此它们以其智能合约代码所规定的预置方式进行“自我控制”。这两类账户都由一个以太坊地址来标识。在本章中，我们将讨论合约账户以及控制它们的程序代码。

## 什么是智能合约？
“智能合约”（Smart Contract）这一术语多年来被用来描述各种不同的事物。20 世纪 90 年代，密码学家**尼克·萨博（Nick Szabo）**创造了这个术语，并将其定义为“一套以数字形式指定的承诺，包括各方履行这些承诺的协议”。自那时起，智能合约的概念不断演变，特别是在 2009 年比特币发布以及随后的去中心化区块链平台出现之后。

在以太坊的语境下，这个术语其实有点名不副实。因为以太坊智能合约既不“智能”，也不是法律意义上的“合约”，但这个术语还是流传了下来。在本书中，我们使用“智能合约”指代那些作为以太坊网络协议的一部分、在 EVM（以太坊虚拟机）上下文中确定性运行的不可篡改的计算机程序——也就是说，它们运行在去中心化的“以太坊世界计算机”上。

让我们拆解一下这个定义：

**计算机程序**（Computer programs） 

智能合约仅仅是计算机程序。在此语境下，“合约”一词没有任何法律含义。

**不可篡改**（Immutable） 

一旦部署，智能合约的代码就无法更改。与传统软件不同，修改智能合约的唯一方法是部署一个新实例。

**确定性**（Deterministic） 

在发起执行的交易背景以及执行时的以太坊区块链状态确定的情况下，智能合约的执行结果对每个运行它的人来说都是相同的。

**EVM 上下文**（EVM context） 

智能合约在一个非常受限的执行上下文中运行。它们只能访问自身的状态、调用它们的交易上下文，以及有关最近区块的一些信息。

**去中心化世界计算机**（Decentralized world computer） 

EVM 作为本地实例运行在每个以太坊节点上。但由于所有 EVM 实例都从相同的初始状态出发，并产生相同的最终状态，因此整个系统作为一个单一的“世界计算机”运行。

## 智能合约的生命周期
智能合约通常使用诸如 Solidity 之类的高级语言编写。但为了运行，它们必须被编译成在 EVM 中运行的低级字节码。一旦编译完成，它们就会使用一种特殊的合约创建交易部署到以太坊平台上，这类交易的特征是具有空的 to 字段（参见第 6 章中的“特殊交易：合约创建”）。每个合约都由一个以太坊地址标识，该地址是合约创建交易根据发起账户和 nonce 计算得出的函数。合约的以太坊地址可以在交易中作为接收者，用于向合约发送资金或调用合约的其中一个函数。请注意，与 EOA 不同，为新智能合约创建的账户没有关联的密钥。作为合约创建者，你在协议层面并不会获得任何特殊特权（尽管你可以显式地在智能合约中编写特权代码）。你当然也不会收到合约账户的私钥，因为私钥实际上并不存在——我们可以说智能合约账户拥有它们自己。

重要的是，合约只有在被交易调用时才会运行。以太坊中的所有智能合约最终都是由于 EOA 发起的交易而执行的。一个合约可以调用另一个合约，后者又可以调用另一个合约，依此类推，但此类执行链中的第一个合约始终是由来自 EOA 的交易调用的。合约从不“自行运行”或“在后台运行”。在交易直接或间接地触发执行（作为合约调用链的一部分）之前，合约实际上处于休眠状态。还值得注意的是，智能合约在任何意义上都不是“并行”执行的——以太坊世界计算机可以被认为是一台单线程机器。

无论交易调用了多少个合约，或者这些合约在被调用时执行了什么操作，交易都是原子性的。交易会完整地执行，只有当所有执行都成功终止时，全局状态（合约、账户等）的更改才会被记录。成功终止意味着程序在没有错误的情况下运行并到达执行终点。如果执行由于错误而失败，其所有影响（状态更改）都会被“回滚”，就像交易从未运行过一样。失败的交易仍会被记录为已尝试，并且用于执行的 gas 会从发起账户中扣除，但除此之外对合约或账户状态没有影响。

如前所述，合约的代码一旦部署就无法更改。从历史上看，合约可以被删除，从而从其地址中移除代码和内部状态（存储），留下一个空白账户。在这样的删除之后，发送到该地址的任何交易都不会导致代码执行，因为没有代码留存。这种删除是通过名为 `SELFDESTRUCT` 的 EVM 操作码完成的，它提供了 gas 返还，通过删除存储状态来激励释放网络资源。然而，`SELFDESTRUCT` 操作在 2023 年通过 [EIP-6780](https://oreil.ly/5LcZo) 被弃用，原因是它对账户状态要求的重大变动，特别是移除所有代码和存储。随着以太坊路线图中的后续升级，这种操作将不再可行。

## 以太坊高级语言简介
EVM 是一个运行名为 EVM 字节码的特殊代码形式的虚拟机，类似于你计算机的 CPU 运行诸如 x86_64 之类的机器码。我们将在第 14 章更详细地研究 EVM 的运行和语言。在本节中，我们将了解如何编写在 EVM 上运行的智能合约。

虽然可以直接用字节码编写智能合约，但 EVM 字节码相当笨拙，程序员很难阅读和理解。相反，大多数以太坊开发人员使用高级语言编写程序，并使用编译器将其转换为字节码。

尽管任何高级语言都可以适配用来编写智能合约，但将任意语言适配为可编译为 EVM 字节码是一项相当繁琐的任务，并且通常会导致一定程度的混乱。智能合约在一个高度受限且极简的执行环境（EVM）中运行。此外，还需要提供一组特定的 EVM 系统变量和函数。因此，从头开始构建一种智能合约语言比使通用语言适用于编写智能合约更容易。结果，出现了许多用于编写智能合约的专用语言。以太坊拥有几种这样的语言，以及生成 EVM 可执行字节码所需的编译器。

通常，编程语言可以分为两大编程范式：声明式和命令式，分别也称为函数式和过程式。在声明式编程中，我们编写表达程序逻辑而非其流程的函数。声明式编程用于创建没有副作用的程序，这意味着在函数之外没有状态变化。声明式编程语言包括 Haskell 和 SQL。相比之下，命令式编程是程序员编写一组结合了程序逻辑和流程的过程。命令式编程语言包括 C++ 和 Java。有些语言是“混合型”的，意味着它们鼓励声明式编程，但也可以用来表达命令式编程范式。这类混合型语言包括 Lisp、JavaScript 和 Python。通常，任何命令式语言都可以用来以声明式范式编写，但往往会导致代码不够优雅。相比之下，纯声明式语言不能用来编写命令式范式。在纯声明式语言中，没有“变量”。

虽然命令式编程更常被程序员使用，但编写完全按预期执行的程序可能非常困难。程序的任何部分改变任何其他部分状态的能力使得推导程序的执行变得困难，并引入了许多产生漏洞的机会。相比之下，声明式编程更容易理解程序的行为：由于它没有副作用，程序的任何部分都可以被隔离理解。

在智能合约中，漏洞字面意义上意味着金钱损失。因此，编写没有非预期效果的智能合约至关重要。为此，你必须能够清晰地推导程序的预期行为。因此，声明式语言在智能合约中发挥的作用比在通用软件中大得多。然而，正如你将看到的，最广泛使用的智能合约语言（Solidity）是命令式的。程序员和大多数人类一样，抵制改变！

目前支持的智能合约高级编程语言包括以下几种（按流行程度排序）：

**Solidity**

一种过程式（命令式）编程语言，语法类似于 JavaScript、C++ 或 Java。它是以太坊智能合约中最流行且最常用的语言。

**Yul**

一种中间语言，可以以独立模式使用或在 Solidity 中内联使用，非常适合跨平台的高级优化。初学者在探索 Yul 之前应先从 Solidity 或 Vyper 开始，因为它需要具备关于智能合约安全和 EVM 的高级知识。

**Vyper**

一种面向合约的编程语言，具有类 Python 语法，它优先考虑用户安全，并通过语言设计和高效执行来鼓励清晰的编码实践。

**Huff**

一种底层编程语言，主要由需要高度高效且极简合约代码的开发人员使用，允许进行超出 Solidity 等高级语言所能提供的高级优化。与 Yul 一样，不建议初学者使用。

**Fe**

一种用于 EVM 的静态类型智能合约语言，受 Python 和 Rust 启发。它的目标是易于学习，即使对于刚接触以太坊的开发人员也是如此。自 2021 年 1 月发布 Alpha 版本以来，其开发仍处于早期阶段。

过去还开发过其他语言，但现在已不再维护，例如 LLL、Serpent 和 Bamboo。

如你所见，有许多语言可供选择。然而，在所有这些语言中，Solidity 是迄今为止最流行的，甚至已经成为以太坊乃至其他类 EVM 区块链上事实上的高级语言。

## 使用 Solidity 构建智能合约
Solidity 由 Gavin Wood（本书第一版的合著者）创造，是一种专门用于编写智能合约的语言，其特性直接支持在以太坊世界计算机的去中心化环境中运行。由于其属性具有相当的通用性，它最终被用于在其他多个区块链平台上编写智能合约。该语言最初由 Christian Reitwiessner 开发，随后由 Alex Beregszaszi、Liana Husikyan、Yoichi Hirai 以及几位前以太坊核心贡献者接手。Solidity 目前作为一个独立项目在 [GitHub](https://oreil.ly/ik9kH)上进行开发和维护。

Solidity 项目的核心“产品”是 Solidity 编译器 solc，它将使用 Solidity 语言编写的程序转换为 EVM 字节码。该项目还管理着以太坊智能合约中重要的 ABI（应用程序二进制接口）标准，我们将在本章详细探讨这一标准。Solidity 编译器的每个版本都对应并编译特定版本的 Solidity 语言。

为了开始学习，我们将下载 Solidity 编译器的二进制可执行文件。然后，我们将延续第 2 章中的示例，开发并编译一个简单的合约。

### 选择 Solidity 版本
Solidity 遵循一种名为**语义化版本控制**（[Semantic Versioning](https://semver.org/)）的版本模型，其版本号结构由点分隔的三个数字组成：主版本号.次版本号.修订号（MAJOR.MINOR.PATCH）。“主版本号”在发生重大且不向后兼容的更改时增加；“次版本号”在主版本发布之间添加向后兼容的功能时增加；“修订号”则用于向后兼容的漏洞修复。

在撰写本文时，Solidity 的版本为 0.8.26。主版本号为 0 的规则（用于项目的初始开发阶段）有所不同：任何内容都可能随时发生变化。在实践中，Solidity 将“次版本号”视为主版本号，将“修订号”视为次版本号。因此，在 0.8.26 中，8 被视为主要版本，而 26 被视为次要版本。正如你在第 2 章中看到的，你的 Solidity 程序可以包含一条 pragma 指令，该指令指定了与之兼容并可用于编译合约的 Solidity 最低和最高版本。由于 Solidity 正在迅速演变，通常最好安装最新版本。

> [!Note]
> Solidity 快速演变的另一个后果是文档过时的速度很快。目前，我们使用的是 Solidity 0.8.26 版本，本书中的所有内容都基于该版本。虽然本书将始终为你学习 Solidity 打下坚实的基础，但未来的版本可能会更改某些语法和功能。因此，每当你产生疑问或遇到新事物时，查看 Solidity [官方文档](https://oreil.ly/LzV7L)以保持更新是一个好主意。

### 下载与安装 Solidity
根据你的操作系统和具体需求，你可以通过多种方法下载并安装 Solidity：既可以使用二进制发布版本，也可以通过源代码进行编译。你可以在 Solidity [官方文档](https://oreil.ly/JW--z)中找到详细且更新及时的说明。

以下是在 Ubuntu/Debian 操作系统上，使用 apt 软件包管理器安装最新 Solidity 二进制发布版本的方法：
```Bash
$ sudo add-apt-repository ppa:ethereum/ethereum
$ sudo apt update
$ sudo apt install solc
```
安装好 solc 之后，可以通过运行以下命令检查版本：
```Bash
$ solc --version
solc, the solidity compiler commandline interface
Version: 0.8.26+commit.8a97fa7a.Linux.g++
```
### 开发环境
虽然完全可以使用简单的文本编辑器来开发 Solidity 智能合约，但利用像 [Hardhat](https://hardhat.org/) 或 [Foundry](https://oreil.ly/-7Qvy) 这样的开发框架可以显著提高开发效率。这些框架提供了一套全面的工具，能够简化并改进开发流程。例如，它们提供了强大的测试环境，允许你编写并运行单元测试来验证合约行为；它们还提供**分叉（Forking）**功能，可以创建主网的本地实例，用于真实的测试场景。凭借先进的调试和追踪功能，你可以轻松地单步执行代码，快速识别并解决问题，从而节省时间并减少错误。此外，这些框架还支持脚本编写和部署自动化、扩展功能的插件生态系统，以及跨不同环境的无缝网络管理。将这些功能整合到你的工作流中，可以确保更高水平的代码质量和安全性，而这仅凭简单的文本编辑器是很难实现的。

除了框架之外，采用像 VS Code 这样的现代 IDE 能进一步提高生产力。VS Code 为 Solidity 提供了广泛的扩展插件，包括让代码更易读的语法高亮；帮助组织和导航复杂项目的先进注释和书签工具；以及提供代码结构洞察和潜在问题分析的视觉工具。此外，还有像 Remix IDE 这样基于 Web 的开发环境。

这些工具结合在一起，不仅提高了代码质量，还加速了开发过程，使我们能够更快速、更安全地构建和部署智能合约。

### 编写一个简单的 Solidity 程序
在第 2 章中，我们编写了第一个 Solidity 程序。当初次构建 Faucet（水龙头）合约时，我们使用 Remix IDE 来编译和部署该合约。在本节中，我们将重新审视、改进并修饰这个 Faucet 合约。

我们的第一次尝试如示例 7-1 所示。

示例 7-1. Faucet.sol：一个实现水龙头功能的 Solidity 合约
```Solidity
// SPDX-License-Identifier: GPL-3.0
// Our first contract is a faucet!
contract Faucet {
    // Give out ether to anyone who asks
    function withdraw(uint _withdrawAmount, address payable _to) public {
        // Limit withdrawal amount
        require(_withdrawAmount <= 100000000000000000);
        // Send the amount to the address that requested it
        _to.transfer(_withdrawAmount);
    }
    // Accept any incoming amount
    receive() external payable {}
}
```
正如我们在第 2 章中看到的，注释中的 SPDX 许可证标识符表明该智能合约是在 GPL-3.0 协议下授权的。这旨在告知用户和开发者在使用及分发该代码时所享有的法律权利和承担的义务。

### 使用 Solidity 编译器 (solc) 进行编译
现在，我们将使用命令行形式的 Solidity 编译器来直接编译我们的合约。Solidity 编译器 solc 提供了多种选项，你可以通过传递 `--help` 参数来查看这些选项。

我们使用 solc 的 `--bin` 和 `--optimize` 参数来为我们的示例合约生成优化后的二进制文件：
```Bash
$ solc --optimize --bin Faucet.sol
======= Faucet.sol:Faucet =======
Binary:
6080604052348015600e575f5ffd5b5060fa8061001b5f395ff3fe608060405260043610601d575f3560e01c806
2f714ce146027575f5ffd5b36602357005b5f5ffd5b3480156031575f5ffd5b506041603d366004608d565b6043
565b005b67016345785d8a00008211156056575f5ffd5b6040516001600160a01b0382169083156108fc0290849
05f818181858888f193505050501580156088573d5f5f3e3d5ffd5b505050565b5f5f60408385031215609d575f
5ffd5b8235915060208301356001600160a01b038116811460b9575f5ffd5b80915050925092905056fea264697
06673582212208935b6cf5d9070b7609ad59ac4b727e512522c674cacf09a2eff88dafa3242ee64736f6c634300
081b0033
```
solc 产生的结果是一个十六进制序列化的二进制文件，它可以被提交到以太坊区块链上。

## 以太坊合约 ABI
在计算机软件中，应用程序二进制接口（ABI）是两个程序模块之间的接口——通常存在于操作系统与用户程序之间。ABI 定义了在机器码级别如何访问数据结构和函数；这不应与 API 混淆，API 是在高级的、通常是人类可读的源代码格式中定义这种访问。因此，ABI 是将数据编码进机器码以及从机器码中解码数据的主要方式。

在以太坊中，ABI 用于为 EVM 编码合约调用，并从交易中读取数据。ABI 的目的是定义合约中可以被调用的函数，并描述每个函数如何接收参数以及如何返回结果。

合约的 ABI 被指定为一个由函数描述（参见“函数”）和事件（参见“事件”）组成的 JSON 数组。函数描述是一个包含 type（类型）、name（名称）、inputs（输入）、outputs（输出）、constant（是否为常量）和 payable（是否可支付）等字段的 JSON 对象。事件描述对象则包含 type、name、inputs 和 anonymous（是否匿名）字段。

我们使用 solc 命令行编译器来为我们的 Faucet.sol 示例合约生成 ABI：
```Bash
$ solc --abi Faucet.sol
======= Faucet.sol:Faucet =======
Contract JSON ABI
[{"inputs":[{"internalType":"uint256","name":"withdrawAmount","type":"uint256"}],
"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"},
{"stateMutability":"payable","type":"receive"}]
```

如你所见，编译器生成了一个 JSON 数组，描述了 Faucet.sol 中定义的两个函数。一旦合约部署完成，任何想要访问 Faucet 合约的应用程序都可以使用这个 JSON。利用 ABI，诸如钱包或 DApp 浏览器之类的应用程序可以构造交易，以正确的参数和参数类型调用 Faucet 中的函数。例如，钱包会知道要调用 withdraw 函数，必须提供一个名为 withdrawAmount 的 uint256 类型参数。钱包可以提示用户提供该数值，然后创建一个对该数值进行编码并执行 withdraw 函数的交易。

应用程序与合约进行交互所需的全部信息就是 ABI 以及合约部署的地址。

## 选择 Solidity 编译器和语言版本
正如我们在之前的代码中看到的，我们的 Faucet 合约在 Solidity 0.8.26 版本下可以成功编译。但如果我们使用的是另一个版本的 Solidity 编译器会怎样呢？这种语言仍处于不断的变动之中，事物可能会以意想不到的方式发生变化。我们的合约相当简单，但如果我们的程序使用了一个仅在 Solidity 0.8.26 版本中新增的功能，而我们尝试用 0.8.25 版本去编译它，结果会如何？

为了解决此类问题，Solidity 提供了一种名为 版本 Pragma (version pragma) 的编译器指令，用于告知编译器该程序需要特定的编译器（及语言）版本。让我们看一个例子：
```Solidity
pragma solidity 0.8.26;
```
Solidity 编译器会读取版本 Pragma，如果编译器版本与该指令不兼容，则会产生错误。在这种情况下，我们的版本 Pragma 表明该程序可以由版本为 0.8.26 的 Solidity 编译器编译。Pragma 指令不会被编译进 EVM 字节码；它们是编译时指令，仅供编译器用于检查兼容性。

> [!Note]
> 在 pragma 指令中，符号 ^ 表示我们允许使用等于或高于指定版本的任何**次版本**（minor revision）进行编译。例如，指令 pragma solidity ^0.7.1; 意味着该合约可以使用版本号为 0.7.1、0.7.2 和 0.7.3 的 solc 进行编译，但不能使用 0.8.0（因为 0.8.0 是主版本，而不是次版本）。

让我们为 Faucet 合约添加一个 pragma 指令。我们将新文件命名为 Faucet2.sol，以便在接下来的示例中记录我们的改动，如示例 7-2 所示。

示例 7-2. Faucet2.sol：为 Faucet 添加版本 pragma
```Solidity
pragma solidity 0.8.26;
// SPDX-License-Identifier: GPL-3.0
// Our first contract is a faucet!
contract Faucet {
    // Give out ether to anyone who asks
    function withdraw(uint _withdrawAmount, address payable _to) public {
        // Limit withdrawal amount
        require(_withdrawAmount <= 100000000000000000);
        // Send the amount to the address that requested it
        _to.transfer(_withdrawAmount);
    }
    // Accept any incoming amount
    receive() external payable {}
}
```
添加版本 pragma 是一项最佳实践，因为它能避免编译器与语言版本不匹配的问题。在本章中，我们将探索其他的最佳实践，并继续改进 Faucet 合约。

## 使用 Solidity 编程
在本节中，我们将了解 Solidity 语言的一些功能。正如我们在第 2 章中提到的，我们的第一个合约示例非常简单，而且在多方面都存在缺陷。在探索如何使用 Solidity 的过程中，我们将在这里逐步改进它。不过，这不会是一本详尽无遗的 Solidity 教程，因为 Solidity 相当复杂且演变迅速。我们将介绍基础知识，为你打下坚实的基础，以便你能够自行探索其余内容。

### 数据类型
首先，让我们来看看 Solidity 提供的一些基础数据类型：

**布尔型 (bool)**

布尔值，true 或 false，配合逻辑运算符使用：!（非）、&&（与）、||（或）、==（等于）以及 !=（不等于）。

**整型 (int, uint)**

有符号整型（int）和无符号整型（uint），以 8 位为增量进行声明，范围从 int8 到 uint256。如果不带尺寸后缀，则默认使用 256 位，以匹配 EVM 的字长（Word Size）。

**定点数 (fixed, ufixed)**

定点数，声明格式为 (u)fixedMxN，其中 M 表示总位数（以 8 为增量，最高 256 位），N 表示小数点后的位数（最多 18 位）——例如 ufixed32x2。

> [!Note]
> 注意 Solidity 目前尚未完全支持定点数。它们可以被声明，但无法进行赋值（无论是赋值给他人还是被他人赋值）。

**地址（Address）**

一个 20 字节的以太坊地址。address 对象拥有许多有用的成员函数，最主要的是 balance（返回账户余额）和 transfer（向该账户转账以太币）。

**字节数组（定长）**

固定大小的字节数组，声明范围从 bytes1 到 bytes32。

**字节数组（变长）**

大小可变的字节数组，声明为 bytes 或 string。

**枚举（Enum）**

用于列举离散值的用户自定义类型：enum NAME {LABEL1, LABEL2, ...}。枚举的底层类型是 uint8；因此，它最多只能有 256 个成员，并且可以显式转换为所有整型。

**数组（Arrays）**

任意类型的数组，可以是定长的或动态的：uint32[][5] 是一个包含 5 个动态无符号整型数组的定长数组。

**结构体（Struct）**

用于将变量分组的用户自定义数据容器：struct NAME {TYPE1 VARIABLE1; TYPE2 VARIABLE2; ...}。

**映射（Mapping）**

用于 键 ⇒ 值 对的哈希查找表：`mapping(KEY_TYPE => VALUE_TYPE) NAME`。

除了这些数据类型，Solidity 还提供了多种值字面量，可用于计算不同的单位。

**时间单位（Time units）**

全局变量 block.timestamp 表示区块发布并添加到区块链时的时间（以秒为单位），从 Unix 纪元（1970 年 1 月 1 日）起算。seconds、minutes、hours 和 days 这些单位可以作为后缀使用，并转换为基础单位“秒”的倍数。

> [!Note]
> 由于一个区块可以包含多笔交易，该区块内的所有交易都共享同一个 block.timestamp。这个时间戳反映的是区块发布（被挖出/确认）的时间，而不是每笔交易发起的准确时刻。

**以太币单位（Ether units）**

单位 wei 和 ether 可以作为后缀使用，它们会被转换为基础单位 wei 的倍数。此前，finney 和 szabo 等面值单位也是可用的，但在 Solidity 0.7.0 版本中它们已被移除。

在我们的 Faucet 合约示例中，我们为 withdrawAmount 变量使用了 uint 类型（它是 uint256 的别名）。我们也间接地使用了 address 变量，并通过 msg.sender 对其进行赋值。在本章剩余的示例中，我们将使用更多这些数据类型。

让我们使用单位乘法器来提高示例合约的可读性。在 withdraw 函数中，我们限制了最大提取金额，并以以太币的基础单位 wei 来表示该限制：
```Solidity
require(withdrawAmount <= 100000000000000000);
```
这非常不利于阅读。我们可以通过使用单位乘法器 ether 来改进代码，从而用 ether 而不是 wei 来表达该数值：
```Solidity
require(withdrawAmount <= 0.1 ether);
```

### 变量：定义与作用域
在 Solidity 中，定义变量和函数的语法与其他静态类型语言类似：我们为每个变量分配一个类型、一个名称以及一个可选的初始值。对于状态变量，我们还可以指定它们的可见性（visibility）。默认的可见性是 internal，这意味着该变量只能在当前合约及其派生合约中访问。若要让其他智能合约也能访问它们，我们需要使用 public 可见性。

Solidity 智能合约具有三种类型的变量作用域：

**状态变量** (State variables) 

通过在区块链上记录数值，这些变量在智能合约中存储永久数据，即所谓的持久状态。状态变量定义在智能合约内部，但在任何函数之外。例如：`uint public count;`

**局部变量** (Local variables) 

这些是在计算过程中使用的临时数据，仅在短时间内保存信息。局部变量不会存储在区块链上；它们存在于函数内部，在定义的范围之外无法访问。例如：`uint count = 1;`

**全局变量** (Global variables) 

这些变量由 Solidity 自动提供，无需显式声明或导入即可使用。它们提供了有关区块链环境的信息，并包含程序中使用的实用函数。预定义的全局变量在下一节中会详尽列出。

正如我们简要提到的，声明状态变量时可以指定其可见性。Solidity 提供了三种不同的可见性级别：*public*（公开）会自动生成读取器函数（getter functions），允许外部合约读取其数值，但外部合约无法直接修改它们。*internal*（内部）仅在当前合约及其派生合约（继承自该合约的合约）中可访问。*private*（私有）与 internal 类似，但即使是派生合约也无法访问。

### 预定义全局变量与函数
当合约在 EVM 中执行时，它可以访问一小组全局对象。这些对象包括 block（区块）、msg（消息）和 tx（交易）。此外，Solidity 还将许多 EVM 操作码（opcodes）公开为预定义函数。在本节中，我们将检查你可以从 Solidity 智能合约内部访问的变量和函数。


