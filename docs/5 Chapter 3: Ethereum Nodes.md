# 第三章：以太坊节点 (The Ethereum Node)

以太坊节点（Ethereum node）是一个实现了以太坊规范，并通过 **P2P**（点对点）网络与其他以太坊节点进行通信的软件应用程序。

最初，一个节点只需运行单个客户端即可完全实现作为以太坊生态系统成员的所有要求。2022 年 9 月 15 日，“合并”（The Merge）硬分叉发生，将共识协议从基于 **PoW**（工作量证明）的方案更改为 **Gasper**——即新的基于 **PoS**（权益证明）的共识协议。这也导致了关注点分离（separation of concerns）——即共识与执行的分离，并产生了一种新型的以太坊客户端：共识客户端（consensus client）。

因此，在撰写本文时，一个以太坊节点必须同时运行两个软件组件才能与最新的规范兼容，如图 3-1 所示，其定义如下：

**共识客户端 (Consensus client)**

这款新软件现在负责共识协议，让所有节点对区块链的单一历史记录达成一致。

**执行客户端 (Execution client)**

该软件专注于接收网络上发生的所有区块和交易，在 **EVM**（以太坊虚拟机）内部执行它们，并验证其正确性。
[Figure 3-1](<./images/figure 3-1.png>)
[图 3-1：合并后以太坊节点的架构 (The architecture of a post-Merge Ethereum node)]

不同的以太坊客户端——包括执行客户端和共识客户端——只要符合参考规范和标准化的通信协议，就可以互操作。虽然这些不同的客户端由不同的团队使用不同的编程语言开发，但它们都“说”同一种协议并遵循相同的规则。因此，它们都可以用于运行以太坊网络并与之交互。

以太坊是一个开源项目，所有主要客户端的源代码均在开源许可证（如 LGPL v3.0）下发布，可供任何人免费下载和用于任何目的。不过，开源不仅意味着免费使用，还意味着以太坊是由一个开放的志愿者社区开发的，任何人都可以对其进行修改。“更多的眼睛”意味着更值得信赖的代码。

以太坊最初由一份名为“黄皮书”（Yellow Paper）的正式规范定义，该规范由本书原作者之一加文·伍德（Gavin Wood）编写。尽管该规范会随着以太坊重大变更而定期更新，但现在已有清晰的路径指向两种不同的参考实现：一种用于执行客户端，另一种用于共识客户端。这些参考实现使用 Python 编写，并优先考虑可读性和简洁性。

> [!NOTE]
> 这些规范（Specs）并非旨在作为全节点的完整实现，而是作为“可执行的伪代码规范”。

这与比特币形成了对比，例如，比特币没有以任何正式方式进行定义。比特币的“规范”就是其参考实现 `Bitcoin Core`；而以太坊的执行规范记录在一篇结合了英文和数学（形式化）说明的论文中。这份形式化规范，加上各种**以太坊改进提案** (**EIPs**, Ethereum Improvement Proposals) 以及用 Python 编写的新共识规范，共同定义了以太坊节点的标准行为。

由于以太坊拥有清晰的形式化规范，产生了一系列独立开发但可互操作的客户端软件实现。以太坊在网络上运行的实现方案比任何其他区块链都更加多样化，这通常被认为是一件好事。事实上，这已被证明是抵御网络攻击的绝佳方式，因为针对特定客户端实现策略的漏洞利用只会让开发者忙于修补，而其他客户端则能让网络运行几乎不受影响。

---

> [!TIP] **译者注**：
> 1. **客户端多样性 (Client Diversity) 带来的鲁棒性**：从后端高可用架构的角度来看，以太坊的这种设计有效避免了“单点故障”。如果全网 90% 的节点都运行同一个客户端（如 `Geth`），一旦该客户端出现导致共识错误的逻辑漏洞，整个网络都会瘫痪。通过保持执行层（Geth, Nethermind, Besu 等）和共识层（Prysm, Lighthouse, Teku 等）的多样性，以太坊在协议层实现了真正的“多活冗余”。
> 2. **可执行规范 (Executable Spec) 的优势**：对于后端开发者而言，阅读复杂的数学公式（黄皮书）门槛较高。以太坊转向使用 Python 编写参考实现（如 `execution-specs`），意味着规范本身就是可以运行的代码。这极大地方便了开发者通过单元测试或模拟执行来验证自己的第三方实现是否完全符合共识规则。
> 3. **引擎 API (Engine API) 与解耦**：从后端架构视角看，合并后的节点实际上演变成了一个微服务架构。共识客户端和执行客户端之间通过 `Engine API`（基于 JSON-RPC）进行通信。这种解耦允许开发者自由组合不同的客户端（例如使用 `Lighthouse` 作为共识层，配合 `Geth` 作为执行层），极大地增强了系统的健壮性和客户端多样性。
> 4. **执行层的本质**：虽然共识层决定了区块的顺序，但作为后端开发者，我们交互最频繁的依然是执行层。执行层维护着完整的状态树（State Tree），所有的合约调用、账户余额查询和 `eth_call` 操作最终都是由执行客户端在本地 **EVM** 中跑完并返回结果的。
---
### 以太坊网络 (Ethereum Networks)

目前存在多种基于以太坊的网络，它们在很大程度上符合最初以太坊“黄皮书”（Yellow Paper）中定义的正式规范，但彼此之间可能互操作，也可能不互操作。

许多 **EVM** 兼容链（如 Ethereum Classic, BNB Chain 和 Polygon）共享大部分执行规范（execution spec），但在共识机制和参数上往往有所不同。虽然它们在协议层基本兼容，但这些网络通常具有某些特性或属性，要求以太坊客户端软件的维护者进行小幅修改以支持各个网络。正因如此，并非每个版本的以太坊客户端软件都能运行所有基于以太坊的区块链。

截至 2025 年 6 月，以太坊执行协议有五种主要实现，使用四种不同的语言编写；以太坊共识协议也有五种实现，使用五种不同的语言编写：

**执行客户端 (Execution clients) 包括：**

* **Geth**：使用 Go 语言编写
* **Nethermind**：使用 C# 语言编写
* **Besu**：使用 Java 语言编写
* **Erigon**：使用 Go 语言编写
* **Reth**：使用 Rust 语言编写

**共识客户端 (Consensus clients) 包括：**

* **Lighthouse**：使用 Rust 语言编写
* **Lodestar**：使用 TypeScript 语言编写
* **Nimbus**：使用 Nim 语言编写
* **Prysm**：使用 Go 语言编写
* **Teku**：使用 Java 语言编写

在本节中，我们将重点介绍以下两种执行客户端：

* **Geth**：最古老且使用最广泛的执行客户端，由以太坊基金会维护。
* **Reth**：在 Parity/OpenEthereum 停止维护后，由 Paradigm 创建的基于 Rust 的新型执行客户端。

以及以下两种共识客户端：

* **Prysm**：首个共识客户端，现由 Offchain Labs 维护。
* **Lighthouse**：目前使用率最高的共识客户端，由 Sigma Prime 维护。

我们将演示如何使用这些客户端搭建节点。具体来说，我们将使用 `Geth-Prysm` 和 `Reth-Lighthouse` 组合，并探索它们的部分命令行选项和 **API**。

> [!NOTE]
> 这些配对仅作为示例；你可以根据自己的喜好，选择组合任何执行客户端和共识客户端来运行以太坊节点。

---

> [!TIP] **译者注**：
> 1. **多语言实现的工程意义**：从后端稳定性角度看，这种“多语言实现”是极高等级的安全策略。如果某种编程语言的底层库（例如 Go 的内存分配器或 Java 的虚拟机）出现漏洞，只会影响特定客户端，而不会拖垮整个以太坊网络。在金融级后端设计中，这被称为“异构冗余”。
> 2. **Reth 的崛起与性能优化**：作为后端开发者，值得关注 **Reth** 这种新一代 Rust 客户端。它利用了 Rust 极致的性能和零成本抽象（Zero-cost abstractions），在数据存取性能和同步速度上远超传统客户端。在处理高并发 **JSON-RPC** 请求或构建高性能索引层时，选择 Rust 驱动的客户端已成为目前行业的技术风向标。

---
### 我应该运行全节点吗？ (Should I Run a Full Node?)

区块链的健康度、韧性和抗审查能力取决于是否有大量独立运营且地理分散的**全节点**（Full Nodes）——即下载整个区块链并无限期保留数据的节点。每个全节点都可以帮助其他新节点获取区块数据以引导其运行，并为运营商提供对所有交易和合约的权威且独立的验证。

> [!NOTE]
> 准确地说，这些节点之间存在细微区别：
> * **存档节点 (Archive nodes)**：无限期保留所有历史状态数据的以太坊节点。
> * **全节点 (Full nodes)**：会定期裁剪（Discard）历史状态和收据的以太坊节点——这通常是你启动节点时的默认选项。

然而，运行全节点会产生硬件资源和带宽成本。截至 2025 年 6 月（具体取决于客户端配置），全节点必须下载至少 **2 TB** 的数据并将其存储在本地硬盘上。随着新交易和区块的不断加入，这种数据负担每天都在迅速增加。我们将在后面的“全节点的硬件要求”章节中更详细地讨论这一主题。

对于以太坊开发来说，运行一个连接主网（Mainnet）的全节点并不是必须的。你几乎可以使用以下替代方案完成所有开发工作：

* **测试网节点**（连接到较小的公共测试区块链）。
* **本地私有区块链**（如 `Anvil`）。
* **托管节点 API**（由 **Infura** 或 **Alchemy** 等服务提供商提供）。

你还可以选择运行**远程客户端**（Remote Client），它不会在本地存储区块链副本，也不会验证区块和交易。这些客户端提供钱包功能，可以创建和广播交易。远程客户端可用于连接现有网络，例如你自己的全节点、公共区块链、公共或许可制（**PoA**，权威证明）测试网，或私有本地区块链。在实践中，你可能会使用 **MetaMask**、**Rabby Wallet** 或 **Coinbase Wallet** 等远程客户端，作为在不同节点选项之间切换的便捷方式。

“远程客户端”和“钱包”这两个术语常被互换使用，尽管它们存在细微差别。通常，远程客户端除了提供钱包的交易功能外，还会提供 **API**（如 `web3.js` API）。

不要将以太坊中的“远程客户端”概念与“轻客户端”（Light Client，类似于比特币中的 **SPV** 简单支付验证客户端）混淆。轻客户端会验证区块头，并使用 **Merkle** 证明来验证交易是否被包含在区块链中及其产生的影响，从而获得与全节点相似的安全级别。相反，以太坊远程客户端不验证区块头或交易。它们完全信任全节点来提供区块链访问权限，因此会丧失显著的安全性。你可以通过运行自己的全节点来缓解这些问题。

#### 全节点、公共测试网与本地仿真环境的优劣势分析 (Advantages and Disadvantages of Node Options)

选择如何连接以太坊取决于你的开发需求。你可以运行全节点来支持网络，也可以使用测试网或本地仿真环境来加速开发。

---

#### 全节点的优缺点 (Full Node Advantages and Disadvantages)

运行全节点有助于你所连接网络的运行，但也会为你带来轻度到中度的成本。

**优点：**

* **增强鲁棒性**：支持以太坊网络的韧性和抗审查能力。
* **权威验证**：权威地验证所有交易，不依赖任何第三方。
* **无中介交互**：无需中介即可与公共区块链上的任何合约交互。
* **直接部署**：可以直接将合约部署到公共区块链中。
* **离线查询**：可以离线查询（只读）区块链状态（账户、合约等）。
* **隐私保护**：查询区块链时不会让第三方知道你正在读取的信息。

**缺点：**

* **资源消耗**：需要大量且不断增长的硬件和带宽资源。
* **同步耗时**：首次启动时可能需要数天时间才能完全同步。
* **维护成本**：必须进行维护、升级并保持在线以维持同步状态。

---

#### 公共测试网的优缺点 (Public Testnet Advantages and Disadvantages)

无论你是否选择运行全节点，你可能都想运行一个公共测试网节点。

**优点：**

* **轻量化**：测试网节点需要同步和存储的数据少得多——根据网络不同，大约为 100–300 GB（截至 2025 年 6 月）。
* **快速启动**：测试网节点可以在几小时内完成全同步。
* **零成本开发**：部署合约或进行交易需要“测试以太币”（Test Ether），它没有价值，可以从各种“水龙头”（Faucets）免费获取。
* **真实环境**：测试网是拥有许多其他用户和合约的公共区块链，处于“生存”运行状态。

**缺点：**

* **无经济博弈**：测试网上不能使用“真钱”。因此，你无法针对真正的对手测试安全性，因为没有利益风险（Nothing at stake）。
* **仿真限制**：公共区块链的某些方面无法在测试网上进行真实测试。例如，虽然发送交易需要手续费，但在测试网上这并非考量因素（因为 Gas 是免费的）。此外，测试网不会像公共主网那样经常出现网络拥堵。
* **环境差异**：某些测试网是为特定目的设计的，可能与以太坊主网略有不同。

---

#### 本地区块链仿真的优缺点 (Local Blockchain Simulation Advantages and Disadvantages)

对于许多测试目的，最佳选择是启动单实例私有链。**Anvil** 是目前最流行的本地区块链仿真工具之一。

**优点：**

* **零延迟**：无需同步，磁盘上几乎没有数据；你自己产出第一个区块。
* **资金自由**：无需寻找水龙头；你可以给自己“奖励”区块奖励用于测试。
* **绝对私密**：没有其他用户，只有你。
* **按需部署**：没有其他合约，只有你在启动后亲自部署的那些。

**缺点：**

* **缺乏竞争**：没有其他用户意味着本地链的行为与公共链不同。不存在对交易空间或交易排序（Sequencing）的竞争。
* **出块预判**：除了你之外没有其他区块生产者，意味着出块更加可预测；因此，你无法测试某些在公共区块链上发生的极端场景。
* **冷启动负担**：没有其他合约意味着你必须部署所有想要测试的内容，包括依赖项和库。

---

> [!TIP] **译者注**：
> 幸运的是，像 **Anvil** 这样的工具允许你在任意区块高度“分叉”（Fork）以太坊主网链，让你在类主网的状态下实验你的智能合约。
> 1. **主网分叉（Mainnet Forking）的妙用**：从后端集成测试的角度看，`Anvil` 的分叉功能是神技。它允许你直接在本地模拟环境中调用主网上已有的 Uniswap 或 Aave 合约，而不需要自己在本地重新部署整套复杂的 DeFi 协议。这极大降低了编写集成测试的成本。
> 2. **隐私与 MEV 考量**：对于生产环境的后端服务，运行全节点的物理成本虽然高，但在隐私保护上具有不可替代的价值。如果你使用 Infura 等公共服务，你的所有查询请求（比如查询某个大户的余额）都会暴露给服务商。对于需要防御 **MEV**（最大可提取价值）攻击的交易发送逻辑，拥有自己的全节点是第一道防线。
> 3. **全节点 vs 存档节点的状态剪枝 (Pruning)**：从后端运维视角看，全节点之所以能在 2 TB 左右维持平衡，是因为它使用了“剪枝”技术，只保留最近的区块状态，而将旧的状态删除。如果你需要查询一年多以前某个账户在特定高度的余额（即执行 `eth_getBalance` 时的 `blockNumber` 参数很久远），普通全节点会返回错误，此时你必须使用占用空间高达 12 TB+ 的**存档节点**。
> 4. **JSON-RPC 的信任链**：作为后端开发者，当你调用托管服务（如 **Infura**）时，本质上是将你的逻辑层建立在对他人的“信任”之上。在处理大额资产充值回调或关键业务逻辑时，建议至少在本地部署一个全节点作为数据校验的“真相来源”（Source of Truth），以规避服务商接口延迟或被中间人攻击的风险。
---
### 运行以太坊节点 (Running an Ethereum Node)

如果你有足够的时间和资源，你应该尝试运行一个全节点（Full Node），哪怕仅仅是为了深入了解这一过程。在本节中，我们将介绍如何下载、编译并运行以太坊客户端组合：`Geth-Prysm` 和 `Reth-Lighthouse`。
这要求你对操作系统的**命令行界面**（CLI）有一定的了解。无论你选择将它们作为全节点、测试网节点，还是作为本地私有链的客户端运行，安装这些客户端都是非常值得的。

#### 全节点的硬件要求 (Hardware Requirements for a Full Node)

在开始之前，你应该确保你的计算机拥有足够的资源来运行一个以太坊全节点。你至少需要 **2 TB** 的磁盘空间来存储以太坊区块链的完整副本。如果你还想在以太坊测试网上运行全节点，则至少需要额外的 **100–400 GB**。下载 **2 TB** 的区块链数据可能需要很长时间，因此建议在高速网络连接下进行。

同步以太坊区块链是极度消耗输入/输出 (**I/O**) 性能的。最好配备固态硬盘 (**SSD**)。如果你使用的是机械硬盘 (**HDD**)，则至少需要 **8 GB** 的 **RAM** 作为缓存。否则，你可能会发现系统速度太慢，无法跟上进度并完成同步。

以下是同步以太坊区块链全副本的最低要求摘要：

* **CPU**：2 核或更多
* **存储空间**：至少 **2 TB** 剩余空间
* **内存 (RAM)**：配合 **SSD** 至少 **8 GB**；若使用 **HDD** 则需 **8 GB** 以上（强烈建议使用 **SSD**）
* **网络**：7 Mbps 以上的下载带宽

如果你希望在合理的时间内完成同步，并存储本书讨论的所有开发工具、库、客户端和区块链，你需要性能更强的计算机。以下是我们推荐的配置：

* **CPU**：4 核以上的高速 **CPU**——主频比核心数更重要
* **内存 (RAM)**：**16 GB** 以上
* **存储空间**：至少 **2 TB** 剩余空间的快速 **NVMe SSD**
* **网络**：24 Mbps 以上的下载带宽

很难预测区块链规模增长的速度以及何时需要更多磁盘空间，因此建议在开始同步之前检查区块链的最新大小。

> [!NOTE]
> 这里列出的磁盘大小要求假设你使用的是默认设置运行节点，即对旧的“状态数据”（State data）进行了“裁剪”（Pruned）。如果你运行的是“存档”（Archival）节点（保留磁盘上的所有状态），根据客户端的不同，可能需要超过 **2 TB**（甚至高达 **12–15 TB**）的空间。在运行节点之前，请务必参考官方客户端网站上的最新硬件要求。

#### 构建与运行客户端的软件要求 (Software Requirements for Building and Running a Client)

本节涵盖了 `Geth-Prysm` 和 `Reth-Lighthouse` 客户端软件。它还假设你使用的是类 **Unix** 命令行环境。示例显示了在运行 **Bash shell**（命令行执行环境）的 **macOS** 上的命令和输出。这些说明在大多数 **Linux** 发行版上无需修改即可运行。**Windows** 用户可以使用 **Windows Subsystem for Linux (WSL2)**。

> [!TIP]
> 在本章的许多示例中，我们将使用操作系统的 **CLI**（也称为 **shell**），通过终端应用程序访问。**shell** 会显示一个提示符；你输入命令，**shell** 回应一些文本并显示一个新提示符供你输入下一个命令。你的系统上的提示符可能看起来不同，但在以下示例中，它由 `$` 符号表示。在示例中，当你看到 `$` 符号后的文本时，请不要输入 `$` 符号，而是输入紧随其后的命令（以粗体显示），然后按回车键执行。示例中，每条命令下方的行是操作系统对该命令的响应。当你看到下一个 `$` 前缀时，你就知道这是一个新命令，应该重复此过程。

在开始之前，你可能需要安装一些软件。如果你从未在当前使用的计算机上进行过任何软件开发，你可能需要安装一些基础工具。对于接下来的示例，你需要安装 `git`（源代码管理系统）、`golang`（**Go** 语言及其标准库）以及 **Rust**（一种系统级编程语言）。

以下是本示例中我们将使用的四个客户端的文档页面：

* **Geth**
* **Prysm**
* **Reth**
* **Lighthouse**

你可以随时查阅这些网站以了解各客户端架构的更多细节，并在安装过程中进行故障排除。

#### 准备阶段 (Preparation Phase)

从你的家目录（home directory）开始，在计算机中创建一个名为 `ethereum-node1` 的文件夹，然后在其中创建两个名为 `execution`（执行层）和 `consensus`（共识层）的子文件夹：

```bash
$ mkdir ethereum-node1
$ cd ethereum-node1
$ mkdir execution
$ mkdir consensus

```

现在你的文件夹结构应该是这样的：

```text
ethereum-node1
├── consensus
└── execution

```

对一个名为 `ethereum-node2` 的新文件夹重复上述步骤：

```bash
$ cd .. # 此命令用于返回家目录
$ mkdir ethereum-node2
$ cd ethereum-node2
$ mkdir execution
$ mkdir consensus

```

最后，你应该有两个根文件夹——`ethereum-node1` 和 `ethereum-node2`——且每个根文件夹下都有两个子文件夹：`execution` 和 `consensus`。

你还需要安装 **Go** 和 **Rust**。你可以查看它们的官方网站以获取安装指南。

#### Geth-Prysm

进入新建的文件夹 `ethereum-node1`：

```bash
$ cd ethereum-node1

```

##### Geth

首先，我们将通过源代码编译来安装 **Geth**。**Geth** 是执行规范的 **Go** 语言实现，由以太坊基金会积极开发，因此被认为是以太坊客户端的“官方”实现。通常，每个基于以太坊的区块链都会有自己的 **Geth** 实现。如果你正在运行 **Geth**，那么你需要使用以下存储库链接之一来确保为你的区块链获取正确的版本：

* [Ethereum](https://github.com/ethereum/go-ethereum)
* [BNB Chain](https://github.com/bnb-chain/bsc)
* [Polygon PoS](https://github.com/maticnetwork/bor)

> [!NOTE]
> 你可以跳过这些指令，直接为你选择的平台安装预编译好的二进制文件。预编译版本更容易安装，可以在此处列出的任何存储库的“releases”部分找到。但是，通过自己下载并编译软件，你可以学到更多。

**克隆存储库**。第一步是克隆 **Git** 存储库以获取源代码副本。在 `execution` 子文件夹中使用如下 `git` 命令在你本地克隆所选存储库：

```bash
$ cd execution
$ git clone https://github.com/ethereum/go-ethereum.git

```

在存储库复制到本地系统时，你应该会看到进度报告。

**从源代码构建 Geth**。要构建 **Geth**，请切换到源代码下载目录，在选择最新版本（目前是 `v1.14.3`，但你可以随时检查最新版）后使用 `make` 命令：

```bash
$ cd go-ethereum
$ git checkout v1.14.3
$ make geth

```

如果一切顺利，你会看到 **Go** 编译器构建每个组件，直到生成 **Geth** 可执行文件。构建完成后，让我们在不实际启动它的情况下确保 **Geth** 工作正常：

```bash
$ ./build/bin/geth version

```

你应该会看到类似于 `GethVersion: 1.14.3-stable` 的版本报告。先不要运行 **Geth**，因为我们还需要安装共识客户端，才能让以太坊节点同步到链尖。

#### Prysm

现在轮到共识客户端了。**Prysm** 是共识规范的 **Go** 语言实现，由 **Offchain Labs** 积极开发。起初，它是合并（The Merge）后使用最广泛的共识客户端。现在，得益于社区提升客户端多样性的巨大努力，它的市场份额大幅下降，目前维持在 **37%**。

**安装二进制文件**。**Prysm** 可以像 **Geth** 那样从源代码构建，但过程稍微复杂一些。建议按照以下方法安装。首先进入 `consensus` 文件夹：

```bash
$ cd ../.. # 此命令用于返回 ethereum-node1 文件夹
$ cd consensus

```

运行以下命令：

```bash
$ curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh && chmod +x prysm.sh

```

**生成 JWT 密钥 (JWT Secret)**。组成以太坊节点的执行客户端和共识客户端是两个独立的软件，但它们必须相互交互。为此，执行客户端和共识客户端都会使用一种“密码”来验证它们的连接。现在我们需要生成它：

```bash
$ ./prysm.sh beacon-chain generate-auth-secret

```

一个 `jwt.hex` 文件会出现。让我们把它移动到父文件夹：

```bash
$ mv jwt.hex ../jwt.hex

```

#### 运行节点 (Run the node)

现在你已经拥有了执行和共识客户端，并正确生成了 **JWT** 密钥，你可以启动客户端并运行一个以太坊全节点了。

**运行执行客户端**。首先，你需要运行执行客户端 **Geth**。导航回 `execution` 文件夹并运行以下命令：

```bash
$ cd .. # 此命令用于返回 ethereum-node1 文件夹
$ cd execution
$ ./go-ethereum/build/bin/geth --mainnet \
    --http \
    --http.api eth,net,engine,admin,web3 \
    --authrpc.jwtsecret=../jwt.hex

```

如果你看到 `Starting Geth on Ethereum mainnet...` 等日志，说明一切运行正常。

**运行共识客户端**。现在你应该运行共识客户端 **Prysm**。不要关闭执行客户端所在的终端标签页。只需打开一个新的终端窗口或标签页并导航到 `consensus` 文件夹：

```bash
$ cd ethereum-node1
$ cd consensus
$ ./prysm.sh beacon-chain \
    --execution-endpoint=http://localhost:8551 \
    --mainnet \
    --jwt-secret=../jwt.hex \
    --checkpoint-sync-url=https://beaconstate.info \
    --genesis-beacon-api-url=https://beaconstate.info

```

系统可能会要求你接受 **Prysm** 的服务条款，输入 `accept` 即可。现在你就大功告成了！你应该会看到执行客户端和共识客户端开始在终端输出大量日志。这意味着你的以太坊全节点正在同步到链尖。

---

> [!TIP] **译者注**：
> 1. **IOPS 是关键指标**：从后端架构的角度来看，同步节点的瓶颈通常不在 **CPU** 或带宽，而在磁盘的随机读写（**IOPS**）。由于 **Merkle-Patricia Trie** 的状态频繁更新，**HDD** 的寻道延迟会导致节点永远跟不上主网的出块速度。在云端部署时，请务必选择预留 **IOPS** 的高速云磁盘。
> 2. **JWT 认证的重要性**：`jwt.hex` 不仅仅是一个密码，它保护了执行层的敏感接口（端口 `8551`）。这个端口允许共识层通过 `Engine API` 指示执行层切换分叉或打包区块。如果这个接口暴露且无认证，攻击者可以通过恶意指令远程控制你的节点行为。
> 
> 

#### Reth-Lighthouse

让我们使用两种不同的客户端重复上述过程：使用 **Reth** 作为执行客户端，**Lighthouse** 作为共识客户端。

#### Reth

进入 `ethereum-node2` 文件夹，然后进入 `execution` 文件夹：

```bash
$ cd ethereum-node2
$ cd execution
$ git clone https://github.com/paradigmxyz/reth
$ cd reth
$ cargo install --locked --path bin/reth --bin reth

```

构建可能需要 **10 分钟**以上。完成后，通过 `reth --version` 检查安装是否正确。

#### Lighthouse

现在进入 `consensus` 文件夹并安装共识客户端 **Lighthouse**。

```bash
$ cd .. # 返回 ethereum-node2 文件夹
$ cd consensus

```

你需要先安装依赖项。在 **macOS** 上运行 `brew install cmake`。然后克隆并构建：

```bash
$ git clone https://github.com/sigp/lighthouse.git
$ cd lighthouse
$ git checkout stable
$ make

```

#### 运行节点 (Run the node)

同样，首先运行执行客户端 **Reth**：

```bash
$ cd ../.. # 返回 ethereum-node2 文件夹
$ cp ../ethereum-node1/jwt.hex ./jwt.hex # 使用之前生成的 jwt.hex 文件
$ cd execution
$ reth node --full --http --http.api all --authrpc.jwtsecret=../jwt.hex

```

接着，在新的终端窗口运行共识客户端 **Lighthouse**：

```bash
$ cd ethereum-node2
$ cd consensus
$ lighthouse bn \
    --network mainnet \
    --checkpoint-sync-url https://mainnet.checkpoint.sigp.io \
    --execution-endpoint http://localhost:8551 \
    --execution-jwt ../jwt.hex \
    --http

```

你现在拥有了一个正在同步的以太坊全节点。

---

> [!TIP] **译者注**：
> 1. **Rust 栈的优势**：**Reth** 和 **Lighthouse** 都采用了 **Rust** 语言。对于后端工程而言，这意味着极高的内存安全性和卓越的并发处理能力。**Reth** 在同步设计上利用了 **Staged Sync**（阶段性同步）架构，其数据读取性能目前处于行业领先地位，非常适合需要高吞吐 **RPC** 服务的场景。
> 2. **检查点同步 (Checkpoint Sync)**：在运行 **Lighthouse** 时，我们使用了 `--checkpoint-sync-url`。这在后端运维中是一个巨大的飞跃，它允许节点从一个受信任的状态快照开始同步，而不需要从 2020 年的创世区块开始重跑共识，将数天的等待缩短至几分钟。
> 
> 

> [!TIP]
> 觉得这些步骤太复杂？如果你想贡献网络但不想处理这些繁琐的配置，**BuidlGuidl Client** 提供了一键运行节点的脚本。另一个选择是 **Dappnode**，你可以购买预装好全节点的即插即用硬件，或者安装其核心软件来简化部署过程。

我可以为您提供关于如何配置 **Systemd** 脚本来实现节点后台运行和自动重启的建议吗？


---
