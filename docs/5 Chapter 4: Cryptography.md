# 第四章：密码学

以太坊的基础技术之一是密码学（Cryptography），它是计算机安全领域广泛应用的一个数学分支。在希腊语中，Cryptography 的意思是“秘密书写”（secret writing），但密码学的研究范畴远不止秘密书写，后者通常被称为加密（Encryption）。

例如，密码学还可以用于在不泄露秘密的情况下证明对秘密的知晓（如通过数字签名 / Digital Signature），或者证明数据的真实性（如通过数字指纹，也称为哈希 / Hashes）。这些类型的密码学证明是维持以太坊平台（以及所有区块链系统）运行的关键数学工具，同时也广泛应用于以太坊应用程序中。

请注意，截至本书出版时，以太坊协议的任何部分都不涉及加密（Encryption）；也就是说，与以太坊平台的所有通信以及节点之间的通信（包括交易数据）都是未加密的，任何人（必然地）都可以读取。这样做是为了让每个人都能验证状态更新的正确性，从而达成共识。

未来，诸如零知识证明（Zero-Knowledge Proofs）和全同态加密（Homomorphic Encryption）等先进的密码学工具将投入使用，它们允许在保持共识的同时，将一些加密计算记录在区块链上；虽然已经为此做好了准备，但这些技术尚未完全部署。

在本章中，我们将介绍以太坊中使用的一些密码学知识，即非对称加密或公钥密码学（Public Key Cryptography, PKC），它以私钥和地址的形式用于控制资金的所有权。

### 密钥与地址 (Keys and Addresses)

正如本书前面所述，以太坊有两种不同类型的账户：外部账户（**EOAs**）和合约账户（**Contracts**）。**EOAs** 对以太币（**Ether**）的所有权是通过数字**私钥**（Private Keys）、以太坊**地址**（Addresses）和数字**签名**（Signatures）建立的。

私钥是用户与以太坊进行所有交互的核心。事实上，账户地址是直接由私钥派生出来的：一个私钥唯一地决定了一个以太坊地址，这也通常被称为一个账户。

在以太坊系统中，私钥绝不会被直接使用；它们从不在以太坊上传输或存储。也就是说，私钥必须保持私密，绝不能出现在发送给网络的任何消息中，也不应存储在链上。在以太坊系统中传输和存储的只有账户地址和数字签名。

对资金的访问和控制是通过数字签名实现的，而数字签名同样是使用私钥创建的。以太坊交易必须包含有效的数字签名才能被纳入区块链。任何持有私钥副本的人都拥有对相应账户及其持有的以太币的控制权。只要用户妥善保管私钥，以太坊交易中的数字签名就能证明资金的真实所有者，因为签名证明了对私钥的持有权。

在基于公钥加密（**PKC**）的系统中（如以太坊），密钥成对出现，由一个**私钥（秘密密钥）**和一个**公钥**组成。你可以将公钥类比为银行账号，将私钥类比为秘密取款密码（**PIN**）；后者提供对账户的控制权，而前者用于向他人标识该账户。以太坊用户很少能直接看到私钥本身；在大多数情况下，私钥（以加密形式）存储在特殊文件中，并由以太坊钱包软件进行管理。

在以太坊交易的支付部分，收款人由以太坊地址表示，其用法与银行转账中的受益人账户明细相同。正如我们稍后将详细看到的，**EOA** 的以太坊地址是由密钥对中的公钥部分生成的。然而，并非所有以太坊地址都代表公钥-私钥对；它们也可以代表合约。我们将在第 7 章看到，合约并不受私钥支持。

在这一章接下来的部分中，我们将：

* 深入探讨密码学的基础，并探索其在以太坊中的数学原理。
* 研究密钥生成、存储和管理的过程。
* 审阅私钥、公钥和地址所使用的各种编码格式。
* 调研验证者密钥（**Validator Key**）密码学和 **KZG** 承诺方案，这些代表了以太坊密码学基础设施的最新更新。

### 公钥密码学 (PKC) 与加密货币 (Cryptocurrency)

**公钥密码学**（PKC，也称为**非对称加密** / Asymmetric Cryptography）是现代信息安全的基石。由 Martin Hellman、Whitfield Diffie 和 Ralph Merkle 在 20 世纪 70 年代首次发表的**密钥交换协议**（Key exchange protocol）是一项划时代的突破，它引发了公众对密码学领域的第一次大规模关注。在 20 世纪 70 年代之前，强大的密码学知识一直被政府视为最高机密。

**PKC** 使用唯一的密钥来保护信息。这些密钥基于具有特殊性质的数学函数：**正向计算容易，但逆向推导极难**。基于这些函数，密码学能够创建受数学定律保护的数字秘密和不可伪造的数字签名。

例如，将两个巨大的质数相乘是非常简单的。但是，如果给定这两个大质数的乘积，要找到它们的质因数却极其困难（这个问题被称为**质因数分解** / Prime factorization）。假设我们给出一个数字 `8,018,009` 并告诉你它是两个质数的乘积，那么你寻找这两个质数的难度，要远大于我将它们相乘得出该结果的难度。

如果已知某些秘密信息，其中一些数学函数可以很容易地被求逆。在上述例子中，如果我告诉你其中一个质因数是 `2,003`，你就可以通过简单的除法轻松找到另一个：。这类函数通常被称为**陷门函数**（Trapdoor functions），因为除非获得可以作为逆转函数“捷径”的秘密信息，否则它们极难求逆。

密码学中一类更有用的高级数学函数是基于**椭圆曲线**（Elliptic Curve）的算术运算。在椭圆曲线算术中，模素数乘法（Multiplication modulo a prime）很简单，但其逆运算——除法——在实际操作中几乎是不可能的。这被称为**离散对数问题**（Discrete logarithm problem），且目前尚无已知的“陷门”。**椭圆曲线密码学**（ECC）广泛应用于现代计算机系统，也是以太坊（以及其他加密货币）使用私钥和数字签名的基础。

> [!NOTE]
> 如果您有兴趣阅读更多关于现代密码学中使用的数学函数，请参考以下资源：
> * 密码学 (Cryptography)
> * 陷门函数 (Trapdoor function)
> * 质因数分解 (Prime factorization)
> * 离散对数 (Discrete logarithm)
> * 椭圆曲线密码学 (Elliptic curve cryptography)
> 
> 

在以太坊中，我们使用 **PKC** 来创建本章一直在讨论的公私钥对。它们被视为一个“对”，是因为公钥是从私钥派生出来的。它们共同代表了一个以太坊账户：公钥提供了一个公开可访问的账户标识（地址），而私钥则提供了对账户中以太币访问权限的私密控制，以及在使用智能合约时所需的任何身份验证。私钥通过作为创建数字签名所需的唯一信息来控制访问权限，而签署交易以动用账户资金必须提供数字签名。数字签名也用于验证合约所有者或用户，我们将在第 7 章看到这一点。

> [!TIP]
> 在大多数钱包实现中，为了方便，私钥和公钥是作为密钥对存储在一起的。然而，由于公钥可以从私钥轻松计算出来，因此仅存储私钥也是可行的。

数字签名可以为任何消息创建。对于以太坊交易，交易细节本身就被用作“消息”。密码学的数学原理——在这里是椭圆曲线密码学——提供了一种将消息（即交易细节）与私钥结合的方法，从而产生一个只有通过私钥知识才能生成的代码。这个代码就被称为**数字签名**。

请注意，以太坊交易本质上是访问具有特定以太坊地址的特定账户的请求。当交易被发送到以太坊网络以转移资金或与智能合约交互时，必须附带由该以太坊地址对应的私钥创建的数字签名。椭圆曲线数学意味着任何人都可以通过检查数字签名是否与交易细节以及请求访问的以太坊地址匹配，来验证交易的有效性。**验证过程完全不涉及私钥**；私钥始终保持私密。然而，验证过程可以确凿无疑地判定，该交易只能来自于持有与该以太坊地址背后的公钥相对应的私钥的人。这就是 **PKC** 的“魔力”所在。

> [!TIP]
> 以太坊协议本身不包含任何加密——所有作为以太坊网络运行的一部分发送的消息（必然地）都可以被所有人读取。因此，私钥仅用于创建用于交易身份验证的数字签名。


### 私钥 (Private Keys)

私钥本质上只是一个随机选取的数字。对私钥的所有权和控制权是用户控制相关以太坊地址下所有资金，以及访问授权该地址的合约的根基。私钥用于创建支出以太币所需的签名，以此证明交易中所用资金的所有权。私钥必须始终保持机密，因为将其泄露给第三方等同于将该私钥保护下的以太币和合约控制权拱手相让。私钥还必须进行备份，并防止意外丢失。如果私钥丢失，它将无法找回，其保护下的资金也将永远丢失。

> [!TIP]
> 以太坊私钥就是一个数字。随机选取私钥的一种方法是直接使用硬币、铅笔和纸：抛 256 次硬币，你就得到了一个可以在以太坊钱包中使用的随机私钥的二进制位（大概可以，详见下文）。随后即可从该私钥生成公钥和地址。

生成密钥的第一步也是最重要的一步，是寻找一个安全的**熵**（Entropy）源，即随机性来源。创建一个以太坊私钥本质上涉及在  到  之间选取一个数字。只要这个数字是不可预测且非确定性的，你使用什么具体方法来选取它并不重要。以太坊软件使用底层操作系统的**随机数生成器**（RNG）来产生 256 位随机位。通常，操作系统的 **RNG** 是通过人为的随机源进行初始化的，这就是为什么你可能会被要求随意移动几秒钟鼠标，或在键盘上随机敲击按键。另一种替代方案可以是计算机麦克风通道上的宇宙辐射噪声。

更准确地说，私钥可以是  到略小于  的任意非零数字——这是一个巨大的 78 位数字，约为 。这个精确数字的前 38 位与  相同，它被定义为以太坊所使用的椭圆曲线的**阶**（Order）。为了创建私钥，我们随机选取一个 256 位的数字，并检查它是否在有效范围内。在编程层面，这通常是通过将更长的随机位字符串（采集自密码学安全的随机源）输入到 **Keccak-256** 或 **SHA-256** 等 256 位哈希算法中来实现的，这两种算法都能方便地生成一个 256 位的数字。如果结果在有效范围内，我们就得到了一个合适的私钥。否则，我们只需换一个随机数再次尝试。

> [!NOTE]
> 以太坊私钥空间的大小————是一个超乎想象的天文数字。它在十进制下大约是 ，即一个 78 位的数字。作为对比，可见宇宙估计包含  个原子。因此，私钥的数量几乎多到可以给宇宙中的每个原子分配一个以太坊账户。如果你随机选取一个私钥，没有任何可行的方法让别人猜到它或撞巧选中它。

请注意，生成私钥的过程是离线的；它不需要与以太坊网络进行任何通信，事实上也不需要与任何人通信。因此，要选取一个别人永远选不到的数字，它必须是真正随机的。如果你自己手动挑选数字，别人也尝试到这个数字（并卷走你的以太币）的概率就太高了。使用拙劣的 **RNG**（如大多数编程语言中的伪随机函数 `rand`）甚至更糟，因为它是显而易见且极易复现的。就像在线账户的密码一样，私钥必须是不可猜测的。幸运的是，你永远不需要记住你的私钥，所以你可以采用选取私钥的最佳方法：**真随机性**（True randomness）。

> [!WARNING]
> 不要编写自己的代码来创建随机数，也不要使用编程语言提供的“简单”**RNG**。请注意，浏览器钱包中基于 **JavaScript** 的 **RNG** 可能是不安全的，除非有操作系统熵源的支持。至关重要的是，你必须使用**密码学安全的伪随机数生成器**（CSPRNG），并配合具有足够熵源的种子。请仔细研读你所选随机数库的文档，确保其在密码学上是安全的。**CSPRNG** 库的正确实现对密钥的安全性至关重要。

以下是一个十六进制格式显示的随机生成私钥（256 位显示为 64 个十六进制字符，每个字符代表 4 位）：

`f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315`


### 公钥 (Public Keys)

以太坊公钥是椭圆曲线上的一个点，这意味着它是一组满足椭圆曲线方程的  和  坐标。

简单来说，以太坊公钥是由两个数字拼接而成的。这两个数字通过一种**单向计算**从私钥生成。这意味着如果你拥有私钥，计算公钥是轻而易举的；但你无法从公钥反推回私钥。

> [!WARNING]
> 数学高能预警！请保持冷静。如果你在接下来的段落中感到困惑，可以跳过后续几小节。市面上有许多工具和库可以帮你完成这些复杂的数学计算。

公钥是通过**椭圆曲线乘法**（Elliptic Curve Multiplication）从私钥计算得出的，这种运算在实际操作中是不可逆的：。其中  是私钥， 是一个被称为**生成点**（Generator Point）的常数点， 是生成的公钥，而  是特殊的椭圆曲线“乘法”运算符。

请注意，椭圆曲线乘法不同于普通的乘法。除了在函数特性上与普通乘法有相似之处外，两者基本没有共同点。例如，其逆运算（在普通数字中是除法）被称为“求解离散对数”——即在已知  的情况下计算 。其难度相当于尝试  的所有可能值（这种暴力搜索所需的时间可能超过宇宙的寿命）。

通俗地说，椭圆曲线上的算术与“常规”整数算术完全不同。点（）可以乘以一个整数（）得到另一个点（）。但由于不存在“除法”运算，因此不可能通过简单地用公钥  “除以”点  来计算出私钥 。这就是我们在前文“PKC 与加密货币”一节中提到的单向数学函数。

> [!NOTE]
> 椭圆曲线乘法是密码学家所称的“单向函数”的一种：它在一个方向上（乘法）很容易执行，而在相反方向上（除法）则无法实现。私钥持有者可以轻松生成公钥并将其分享给全世界，因为他知道没人能通过逆向推导从公钥计算出私钥。这一数学技巧成为了不可伪造且安全的数字签名的基石，用于证明对以太坊资金的所有权及对合约的控制权。

在我们演示如何从私钥生成公钥之前，让我们先更详细地了解一下椭圆曲线密码学。

#### 椭圆曲线密码学详解 (Elliptic Curve Cryptography Explained)

椭圆曲线密码学（Elliptic Curve Cryptography, ECC）是一种基于离散对数问题（Discrete Logarithm Problem）的非对称或公钥密码学（Public Key Cryptography），该问题通过椭圆曲线点上的加法和乘法运算来体现。图 4-1 是一个椭圆曲线的示例，类似于以太坊所使用的曲线。

> [!NOTE]
> 以太坊使用的椭圆曲线与比特币完全相同，称为 `secp256k1`。这使得重用比特币的许多椭圆曲线库和工具成为可能。

![Figure 4-1](<./images/figure 4-1.png>)
图 4-1. 一个椭圆曲线

以太坊使用特定的椭圆曲线和一组数学常数，这些常数由美国国家标准与技术研究院（NIST）建立的名为 `secp256k1` 的标准定义。`secp256k1` 曲线由以下产生椭圆曲线的函数定义：
```
y^2 = (x^3 + 7) over (Fp)
```

或者：
```
y^2 mod p = (x^3 + 7) mod p
```

其中 `mod p`（模素数 ）表示该曲线位于素数阶为 p 的有限域（Finite Field）上，也写作`Fp` ，其中 p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1, 。这是一个非常大的素数。

由于这条曲线是定义在素数阶有限域上而非实数域（Real Numbers）上，它看起来像是在二维空间中散落的点阵模式，这使得它难以直观可视化。然而，其数学原理与实数域上的椭圆曲线完全一致。作为示例，图 4-2 展示了在素数阶为 17 的更小有限域上的同一条椭圆曲线，呈现为网格上的点阵模式。以太坊的 `secp256k1` 曲线可以被想象成在一个难以想象的巨大网格上呈现的、更为复杂的点阵模式。
![Figure 4-2](<./images/figure 4-2.png>)
图 4-2. 椭圆曲线密码学：可视化  上的椭圆曲线

例如，以下是一个坐标为  的点 ，它是 `secp256k1` 曲线上的一个点：
```
Q = (49790390825249384486033144355916864607616083520101638681403973749255924539515, 59574132161899900045862086493921015780032175291755807399284007721050341297360)
```
示例 4-1 展示了如何使用 **Python** 自行验证这一点。变量 `x` 和 `y` 是点  的坐标，如前例所示。变量 `p` 是椭圆曲线的素数阶（用于所有模运算的素数）。**Python** 代码的最后一行是椭圆曲线方程（**Python** 中的 `%` 运算符是模运算符）。如果 `x` 和 `y` 确实是椭圆曲线上某个点的坐标，那么它们将满足方程，结果为零。你可以尝试在命令行输入 `python`（或 `python3`）并复制列表中的每一行（在提示符 `>>>` 之后）来进行测试。

**示例 4-1. 使用 Python 确认该点位于椭圆曲线上**

```python
Python 3.12.4 (main, Jun  6 2024, 18:26:44) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0
```

#### 椭圆曲线算术运算 (Elliptic Curve Arithmetic Operations)

许多椭圆曲线数学看起来和运作起来都非常像我们在学校学到的整数算术。具体来说，我们可以定义一个**加法运算符**（addition operator），它不是沿着数轴跳跃，而是跳跃到曲线上的其他点。一旦我们有了加法运算符，我们就可以定义点与整数之间的**乘法**（multiplication），这等同于重复的加法。

椭圆曲线加法的定义是：给定椭圆曲线上的两个点P1和P2，存在第三个点P3，该点同样位于椭圆曲线上。

从几何上看，这第三个点是通过在P1和P2之间画一条直线来计算的。令人惊叹的是，这条直线将与椭圆曲线交于且仅交于一个额外的地方。将这个点记为P3′ = (x, y)。然后关于x轴进行对称反射，得到P3，如图 4-3 所示。
[Figure 4-3](<./images/figure 4-3.png>)
**图 4-3. 椭圆曲线加法：在椭圆曲线上将两点相加**

如果P1和P2是同一个点，那么P1和P2“之间”的直线应该延伸为曲线在该点P1处的切线。这条切线将恰好与曲线交于一个新的点，如图 4-4 所示。你可以使用微积分技术来确定切线的斜率。有趣的是，尽管我们将关注点限制在具有两个整数坐标的曲线上，这些技术依然有效！
[Figure 4-4](<./images/figure 4-4.png>)
图 4-4. 椭圆曲线加法：点与其自身相加（二倍点）

在椭圆曲线数学中，还存在一个被称为**无穷远点**（point at infinity）的点，它大致对应于加法中数字0的角色。在计算机上，它有时由 `x = y = 0` 表示（虽然这不满足椭圆曲线方程，但这是一个易于检查的特殊情况）。有几个特殊情况解释了对无穷远点的需求。

在某些情况下（例如，如果P1和P2具有相同的x值但y值不同，如图 4-5 所示），直线将是垂直的，在这种情况下P3 = 无穷远点。
[Figure 4-5](<./images/figure 4-5.png>)
图 4-5. 椭圆曲线加法：导致无穷远点的特殊情况

如果P1是无穷远点，则P1+P2=P2 。同样地，如果P2是无穷远点，则P1+P2=P1。这展示了无穷远点如何扮演“正常”算术中零的角色[^1]。

事实证明，加法运算符 `+` 满足**结合律**（associative），这意味着  `(A + B) + C = A + (B + C)`。这代表我们可以无歧义地写作 `A + B + C`（不加括号）。

现在我们已经定义了加法，我们可以通过扩展加法的标准方式来定义**乘法**[^2]。对于椭圆曲线上的点 ，如果k是一个整数，那么`k * P = P + P + P + … + P`（共k次）。请注意，在这种情况下， k有时（可能会令人困惑地）被称为**指数**（exponent）。

---

> [!TIP]
> **译者注**：
> 1. **计算效率优化**：在后端底层实现（如 `libsecp256k1`）中，计算  并非真的执行k次加法。开发者通常使用 **双倍加算法**（Double-and-Add），其时间复杂度为 。这与快速幂算法的逻辑一致，是保证以太坊签名验证毫秒级响应的关键。
> 2. **常量时间执行**：在编写处理私钥（即 ）的底层代码时，必须确保算术运算是**常量时间**（Constant Time）的。如果由于  的二进制位不同导致计算时长有细微差异，攻击者可以通过“侧信道攻击”（Side-channel attack）根据耗时推导出私钥。
> 
> 

---
#### 生成公钥 (Generating a Public Key)

从一个随机生成的数字形式的私钥 `k` 开始，我们将其与曲线上一个预定义的点——**生成点**（generator point）`G` 相乘，从而在曲线上的其他位置产生另一个点，这就是对应的公钥 `K`：
```
K = k * G
```
生成点是在 `secp256k1` 标准中指定的；对于所有 `secp256k1` 的实现来说，它都是相同的，并且所有从该曲线派生出的密钥都使用同一个点 `G`。由于生成点对所有以太坊用户都是固定的，因此私钥 `k` 与 `G` 相乘将始终得到相同的公钥 `K`。`k` 和 `K` 之间的关系是确定的，但只能沿一个方向计算，即从 `k` 到 `K`。这就是为什么以太坊地址（由 `K` 派生）可以与任何人分享，而不会泄露用户的私钥（`k`）。

正如我们在前一节中所描述的，`k * G` 的乘法等同于重复加法，即 `G + G + G + … + G`，重复 `k` 次。总而言之，为了从私钥 `k` 产生公钥 `K`，我们将生成点 `G` 自身相加 `k` 次。



> [!TIP]
> 私钥可以转换为公钥，但公钥无法转换回私钥，因为数学运算是单向的。

让我们利用这一计算过程，为我们在“私钥”（Private Keys）章节中展示的特定私钥寻找公钥：

`K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G`

密码学库可以利用椭圆曲线乘法帮助我们计算 `K`。生成的公钥 `K` 被定义为一个点：

`K = (x, y)`

其中：
```
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```
在以太坊中，你可能会看到公钥被表示为 130 个十六进制字符（65 字节）的序列化字符串。这是采用了工业联盟高效密码组（Standards for Efficient Cryptography Group, SECG）在《高效密码标准》（SEC1）文档中提出的标准序列化格式。该标准定义了四种可能的出前缀，用于识别椭圆曲线上的点，如表 4-1 所示。

表 4-1. 序列化椭圆曲线公钥前缀
![Table 4-1](<./images/table 4-1.png>)

以太坊仅使用**未压缩公钥**（uncompressed public keys），因此唯一相关的前缀是十六进制的 `04`。序列化过程将公钥的 `x` 坐标和 `y` 坐标拼接在一起：

`04 + x 坐标 (32 字节 / 64 位十六进制) + y 坐标 (32 字节 / 64 位十六进制)`

因此，我们之前计算的公钥序列化结果为：

`046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0`


#### 椭圆曲线库 (Elliptic Curve Libraries)

在加密货币相关项目中，有几种常用的 [secp256k1](https://www.secg.org/sec2-v2.pdf) 椭圆曲线实现：

[**OpenSSL**](https://www.openssl.org/)
OpenSSL 库提供了一套全面的密码学原语，包括完整的 `secp256k1` 实现。例如，可以使用 [`EC_POINT_mul`](https://www.openssl.org/docs/manmaster/man3/EC_POINT_mul.html) 函数来从私钥派生公钥。

[**libsecp256k1**](https://github.com/bitcoin-core/secp256k1)
Bitcoin Core 的 `libsecp256k1`是一个用 C 语言编写的 `secp256k1` 椭圆曲线及其他密码学原语的实现。它最初是为了在 Bitcoin Core 软件中取代 OpenSSL 而从零编写的，在性能和安全性方面都被认为更加优越。


### 密码学哈希函数 (Cryptographic Hash Functions)

密码学哈希函数在以太坊中无处不在。事实上，几乎所有的加密系统都广泛使用哈希函数——密码学家 [Bruce Schneier](https://www.schneier.com/) 曾总结道：“单向哈希函数比加密算法更像现代密码学的劳模。”

在本节中，我们将讨论哈希函数，探索其基本属性，并了解这些属性为何使它们在现代密码学的众多领域如此有用。我们在此讨论哈希函数，是因为它们是以太坊公钥转化为地址的过程中的重要一环。它们还可以用于创建“数字指纹”（Digital fingerprints），辅助数据的验证。

通俗地说，**哈希函数**（Hash function）是任何可以将任意大小的数据映射到固定大小数据的函数。哈希函数的输入被称为**原像**（Preimage）、**消息**（Message）或简单的输入数据。输出则被称为**哈希值**（Hash）。密码学哈希函数是一个特殊的子类，具有对安全平台（如以太坊）非常有用的特定属性。

密码学哈希函数是一种**单向哈希函数**（One-way hash function），它将任意大小的数据映射为固定长度的位字符串。其“单向”性质意味着，如果只知道输出哈希值，在计算上是不可能重新创建输入数据的。确定可能输入的唯一方法是进行暴力搜索（Brute-force search），逐个检查候选输入以寻找匹配的输出；鉴于搜索空间几乎是无限的，这项任务在实际操作中是不可能完成的。即使你找到了能够产生匹配哈希值的输入数据，它也可能不是原始输入数据：哈希函数是“多对一”函数。找到两组产生相同输出的输入数据被称为发现**哈希碰撞**（Hash collision）。粗略地说，哈希函数越好，哈希碰撞就越罕见。对于以太坊来说，碰撞在实际上是不可能发生的。

让我们仔细看看密码学哈希函数的主要属性：

* **确定性 (Determinism)**：给定的输入消息始终产生相同的哈希输出。
* **可验证性 (Verifiability)**：计算消息的哈希值是高效的（线性复杂度）。
* **非相关性 (Noncorrelation)**：对消息的一点微小改变（例如改变 1 位）应当使哈希输出发生剧烈变化，以至于它与原始消息的哈希值之间没有相关性（即“雪崩效应”）。
* **不可逆性 (Irreversibility)**：从哈希值反推消息是不可行的，相当于对所有可能的消息进行暴力搜索。
* **碰撞保护 (Collision protection)**：计算出两个产生相同哈希输出的不同消息应该是不可行的。

抗碰撞性对于避免以太坊中的数字签名伪造尤为重要。这些属性的结合使得密码学哈希函数在广泛的安全应用中非常有用，包括：

* 数据指纹识别 (Data fingerprinting)
* 消息完整性验证（错误检测 / Error detection）
* 工作量证明 ([Proof of Work](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/))
* 身份验证（密码哈希和密钥拉伸）
* 伪随机数生成器 (Pseudorandom number generators)
* 消息承诺（承诺-揭晓机制 / [Commit-reveal mechanisms](https://en.wikipedia.org/wiki/Commitment_scheme)）
* 唯一标识符 (Unique identifiers)

随着我们深入研究系统的各个层级，我们会在以太坊中发现许多这类应用。


#### 以太坊的密码学哈希函数：Keccak-256 (Ethereum's Cryptographic Hash Function: Keccak-256)

以太坊在许多地方都使用了 `Keccak-256` 密码学哈希函数。`Keccak-256` 最初是作为 [NIST](https://www.nist.gov/)（美国国家标准与技术研究院）在 2007 年举办的 [SHA-3 密码学哈希函数竞赛](https://csrc.nist.gov/projects/hash-functions/sha-3-project)的候选算法设计的。`Keccak` 最终成为了获胜算法，并于 2015 年被正式标准化为联邦信息处理标准 [FIPS 202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf)。

然而，在以太坊开发期间，NIST 的标准化进程尚未最终完成。据称，为了提高效率，NIST 在标准流程结束后调整了 `Keccak` 的某些参数。与此同时，英雄般的举报人 [Edward Snowden](https://en.wikipedia.org/wiki/Edward_Snowden) 披露的文件暗示，NIST 可能受到了美国国家安全局（NSA）的不当影响，故意削弱了 [Dual_EC_DRBG](https://en.wikipedia.org/wiki/Dual_EC_DRBG) 随机数生成器（RNG）标准，从而在标准 RNG 中植入了后门。这场争议导致了对提议修改的抵制，并显著推迟了 [SHA-3](https://en.wikipedia.org/wiki/SHA-3) 的标准化进程。当时，以太坊基金会决定采用其发明者最初提交的原始 `Keccak` 算法，而不是由 NIST 修改后的 `SHA-3` 标准。

> [!WARNING]
> 虽然你可能会在以太坊的文档和代码中看到提及 “SHA-3”，但其中许多（即便不是全部）实例实际上是指 `Keccak-256`，而不是最终定稿的 FIPS-202 `SHA-3` 标准。两者在实现上的差异非常细微，主要涉及**填充（Padding）参数**，但这些差异意义重大，因为对于相同的输入，`Keccak-256` 会产生与 FIPS-202 `SHA-3` 完全不同的哈希输出。

#### 我使用的是哪种哈希函数？ (Which Hash Function Am I Using?)

如果两者都可能被统称为 “SHA-3”，你该如何判断你所使用的软件库实现的是 [FIPS-202 SHA-3](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf) 还是 `Keccak-256`？

一种简单的判断方法是使用**测试向量**（Test vector），即针对给定输入的预期输出。哈希函数最常用的测试输入是空输入。如果你以空字符串作为输入运行哈希函数，你应该看到以下结果：

* **Keccak-256("")** = `c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`
* **SHA-3("")** = `a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a`

无论函数被称作什么，你都可以通过运行这个简单的测试来验证它是原始的 `Keccak-256` 还是最终的 NIST 标准 FIPS-202 `SHA-3`。请记住，尽管在代码中经常被称为 `SHA-3`，但以太坊使用的是 `Keccak-256`。

> [!NOTE]
> 由于以太坊所使用的哈希函数（Keccak-256）与最终定稿标准（FIPS-202 SHA-3）之间的差异引起了混乱，所有代码、操作码（Opcodes）和库中的 `sha3` 实例都已重命名为 `keccak256`。详情请参阅 [ERC-59](https://github.com/ethereum/EIPs/issues/59)。

接下来，让我们研究 `Keccak-256` 在以太坊中的第一个应用：从公钥生成以太坊地址。

### 以太坊地址 (Ethereum Addresses)

以太坊地址是使用 `Keccak-256` 单向哈希函数从公钥或合约中派生出的唯一标识符。

在之前的示例中，我们从一个私钥开始，利用椭圆曲线乘法派生出了公钥。

**私钥 k：**
`k = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315`

**公钥 K**（ 和  坐标拼接后的十六进制显示）：
`K = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0`

> [!NOTE]
> 值得注意的是，在计算地址时，公钥**并不包含**十六进制前缀 `04`。

我们使用 `Keccak-256` 来计算该公钥的哈希值：
`Keccak256(K) = 2a5bc342ed616b5ba5732269001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

然后，我们只保留最后的 **20 字节**（最低有效字节），这便是我们的以太坊地址：
`001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

你最常看到的以太坊地址带有 `0x` 前缀，这表示它们是十六进制编码的，如下所示：
`0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

#### 以太坊地址格式 (Ethereum Address Formats)

以太坊地址是十六进制数字，是从公钥的 [Keccak-256](https://keccak.team/keccak.html) 哈希值的最后 20 字节派生出来的标识符。

与比特币地址不同，比特币地址在所有客户端的用户界面中都经过编码，包含内置的**校验和**（Checksum）以防止地址输入错误；而以太坊地址最初以原始十六进制形式呈现，没有任何校验和。这一决策背后的理由是：以太坊地址最终将被系统更高层级的抽象（如域名服务）所隐藏，如果需要校验和，应当在更高层级添加。

但在现实中，这些高层级的开发速度过于缓慢，这一设计选择在生态系统早期引发了诸多问题，包括因地址输入错误和输入验证失败导致的资金损失。此外，由于以太坊域名服务的开发进度慢于最初预期，钱包开发者采纳替代编码方案的速度也极其缓慢。接下来我们将了解几种编码选项。

> [!NOTE]
> 值得一提的是 [以太坊域名服务 (ENS)](https://ens.domains/)，它由 Alex Van de Sande 和 Nick Johnson 于 2017 年推出。**ENS** 提供了一种链上解决方案，可将易于人类阅读的名称（例如 `masteringethereum.eth`）转换为以太坊地址。

---

> [!TIP] **译者注**：
> 1. **静默失败的代价**：从后端开发视角看，缺乏内置校验和意味着如果你在 API 传参时把 `0xabc...123` 误打成了 `0xabc...122`，没有任何数学层面的保护会报错。在处理涉及真金白银的提币逻辑时，开发者必须在前端和后端代码中手动引入校验逻辑（如 [EIP-55](https://eips.ethereum.org/EIPS/eip-55)），否则一个简单的“手抖”就会造成永久性的资产损毁。
> 2. **ENS 的解析逻辑**：虽然 **ENS** 让地址变得易读，但后端服务在与合约交互前，依然需要通过解析器（Resolver）将其还原为原始的 20 字节地址。作为后端架构师，不仅要存储 `.eth` 域名，还要定期更新缓存的对应地址，以防止用户通过更改 **ENS** 记录造成的转账指向错误。
> 
> 



---

#### 大小写混合编码校验和 (ERC-55)

由于域名服务部署缓慢，[ERC-55](https://eips.ethereum.org/EIPS/eip-55) 提出了一项标准。`ERC-55` 通过修改十六进制地址的大小写，为以太坊地址提供了一种向后兼容的校验和。其核心思想是：以太坊地址在解析上是不区分大小写的，所有钱包都应该接受大写或小写表示的地址，解释结果没有区别。通过修改地址中字母字符的大小写，我们可以传达一个校验和，用于保护地址的完整性，防止输入或读取错误。

不支持 `ERC-55` 校验和的钱包会直接忽略地址中大小写混合的事实，但支持它的钱包可以进行验证，并以 **99.986%** 的准确率检测出错误。

这种混合大小写的编码非常微妙，你最初可能不会注意到它。我们的示例地址是：
`0x001d3f1ef827552ae1114027bd3ecf1f086ba0f9`

经过 `ERC-55` 混合大小写校验和处理后，它变成了：
`0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9`

你能看出区别吗？十六进制编码中的部分字母（A–F）现在变成了大写，而其他的保持小写。

`ERC-55` 的实现非常简单。我们对小写的十六进制地址进行 `Keccak-256` 哈希计算。这个哈希值充当了地址的数字指纹，为我们提供了一个方便的校验和。输入（地址）的任何微小变化都会导致生成的哈希（校验和）发生巨大变化，从而使我们能够有效地检测错误。哈希值随后被编码到地址本身的大小写中。

让我们分步拆解：

1. **对不带 `0x` 前缀的小写地址进行哈希：**
`Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0f9") = 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9695d9a19d8f673ca991deae1`
2. **根据哈希值修改大小写：**
如果哈希值中对应的十六进制位大于或等于 `0x8`，则将地址中的对应字母大写。将地址和哈希值对齐显示会更直观：
```text
Address: 001d3f1ef827552ae1114027bd3ecf1f086ba0f9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...
```


* 我们的地址第四位是字母 `d`。哈希值的第四个字符是 `6`，小于 8，所以保持 `d` 小写。
* 下一个字母是第六位的 `f`。哈希值的第六个字符是 `c`，大于 8，因此我们将地址中的 `f` 大写为 `F`，以此类推。由于地址只有 20 字节（40 个十六进制字符），我们只需使用哈希值的前 40 位。



自行检查最终生成的混合大小写地址，看看哪些字符被大写了，以及它们对应哈希值中的哪些位：

```text
Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0F9
Hash   : 23a69c1653e4ebbb619b0b2cb8a9bad49892a8b9...

```

---

#### 检测 ERC-55 编码地址中的错误

现在，让我们看看 `ERC-55` 地址如何帮助我们发现错误。假设我们打印了一个 `ERC-55` 编码的地址：
`0x001d3F1ef827552Ae1114027BD3ECF1f086bA0F9`

现在让我们在读取地址时犯一个基础错误。倒数第二个字符是大写的 `F`，假设我们将其误读为大写的 `E`，并在钱包中输入了以下（错误的）地址：
`0x001d3F1ef827552Ae1114027BD3ECF1f086bA0E9`

幸运的是，我们的钱包符合 `EIP-55` 标准！它注意到了混合大小写并尝试验证该地址。钱包将其转换为全小写并计算校验哈希：
`Keccak256("001d3f1ef827552ae1114027bd3ecf1f086ba0e9") = 5429b5d9460122fb4b11af9cb88b7bb76d8928862e0a57d46dd18dd8e08a6927`

如你所见，尽管地址只改变了一个字符（实际上只改变了 1 位，因为 `e` 和 `f` 在二进制上仅 1 位之差），但地址的哈希值发生了翻天覆地的变化。这就是哈希函数的特性，也是它们在校验和中如此有用的原因！

现在，我们将输入的地址与新计算的哈希对齐：

```text
Input Address: 001d3F1ef827552Ae1114027BD3ECF1f086bA0E9
New Hash     : 5429b5d9460122fb4b11af9cb88b7bb76d892886...

```

完全对不上！多个字母的大小写都是错误的。请记住，大小写本身就是正确校验和的编码方式。我们输入的地址大小写与刚刚计算出的校验和不匹配，这意味着地址已被篡改或引入了错误。

---
### 验证者密码学 (Validators' Cryptography)

在本节中，我们将探讨在基于 [PoS](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/)（权益证明）的新共识协议中，验证者所使用的密码学技术。虽然其核心思想始终是能够对消息进行数字签名并进行验证，但由于共识层存在一些特殊的需求，其设计选择和最终实现与以太坊用于交易或地址的密码学有着显著的不同。[^3]

#### 简介 (Introduction)

在以太坊使用 `Ethash`（当时的 [PoW](https://ethereum.org/en/developers/docs/consensus-mechanisms/pow/) 共识算法）时，没有理由要求区块提议者（当时的矿工）对其生产的区块进行签名。事实上，基于 PoW 的共识算法不需要知道是谁创建了区块就能正常运行。如果区块提议者行为不当，协议会通过让他们浪费电力、时间和金钱来隐式地惩罚他们。

让我们以一个试图通过同时创建两个区块来进行“双花”（Double spend）的矿工为例。为了更好地理解这种“攻击”的核心思想，想象一个矿工想买车，并同意用 ETH 支付（假设是 10 ETH）。该矿工同时创建了两个区块。假设它们都是有效的：在第一个区块中，矿工添加了向经销商发送 10 ETH 的交易；而在另一个区块中，他没有添加。矿工正试图将链分叉为两个部分。

取决于（几乎是）随机的因素，车行经销商可能会先收到矿工支付了 10 ETH 的那个区块。因此，经销商可能认为支付成功了。但他们还没有把车交给矿工。事实上，经销商知道在 PoW 系统中，通常需要等待若干个区块确认后，才认为交易最终结算。

大约 12 秒后，另一名矿工在**不包含** 10 ETH 支付的那个区块之上生产了一个新区块。这完全是可能的，因为这通常取决于下一名矿工先收到了哪个区块。现在出现了一条更长的区块链，根据**最重链规则**（Heaviest chain rule，也被误称为最长链规则），该链被所有节点视为唯一有效的链。

经销商看到有效的区块链中并不包含之前收到的那个有 10 ETH 支付记录的区块，因此他们认为支付未完成，不把车给矿工。

请记住，在 PoW 系统中，矿工必须投入真实的能源和时间来生产一个通过 PoW 检查的有效区块（即区块哈希值低于动态阈值）。因此，他们耗费能源和时间创建区块，却看到自己的区块被整个网络拒绝，这本身就是一种**隐式惩罚**。他们损失了宝贵的能源和时间，而这些资源本可以更好地用于创建遵循所有规则、不尝试作弊的有效区块。

[PoS](https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/) 系统对于行为不当的区块生产者（即验证者）没有这种相同的隐式惩罚。相反，它们使用一种显式的方法：**罚没**（Slashing）。

**罚没**是指通过扣除验证者部分（或全部）质押的 ETH，来惩罚不遵守规则的验证者的行为。这解释了为什么验证者必须质押最低数量的 ETH 才能成为活跃验证者。如果他们没有质押任何东西，当他们开始采取恶意行动时，协议将无法对他们进行惩罚。

要显式惩罚不遵守规则的验证者，需要确切知道每个验证者都在做什么。为此，验证者发送的每条消息（包括区块）都必须使用其**数字签名**进行身份验证。

让我们重现之前矿工的类似例子。现在我们有一个验证者同时提议两个区块。在 PoW 中，矿工需要花费两倍的能源和时间来同时产生两个有效区块，但在 PoS 中，这几乎是完全免费的。

但这就是“罚没”登场的地方。**双重签名**（Double-signing）——即同时提议两个区块——是一个可罚没事件，因此该验证者会立即受到惩罚（在这个特定例子中，其所有质押的 ETH 都会被销毁）。

既然我们知道了为什么验证者必须对所有消息进行身份验证，我们可以深入研究用于此目的的密码学：[**BLS 签名**](https://en.wikipedia.org/wiki/BLS_digital_signature)。在下一节中，我们将了解导致最终决定使用 BLS 密码学的需求。


#### 需求 (Requirements)

针对“验证者之间发送的每条消息都需要身份验证”这一问题，你首先想到的方案可能是沿用以太坊在交易中已经使用的数字签名算法：**椭圆曲线数字签名算法**（[ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)）。

然而，面对以太坊庞大的验证者群体（目前已超过 100 万），`ECDSA` 无法胜任。事实上，这种数字签名算法必须满足一个核心要求：**必须能够压缩签名**，以减少区块中占用的空间，并缩短节点验证所有验证者签名所需的时间。

目前，每位验证者在每个 **Epoch**（纪元，即 32 个 **Slots** / 时段，详见第 15 章）内可以投一票——即一条需要身份验证的消息。这些消息需要通过 P2P 传闻层（Gossip layer）传输给其他验证者和节点，由每个节点验证签名的有效性，最后插入区块中。

这里的瓶颈显而易见：加入网络的验证者越多，节点需要处理的消息就越多。区块也会变得越来越大，因为需要预留越来越多的空间来存储这些验证者的签名。

> [!NOTE]
> 你可以根据活跃验证者的数量轻松计算出节点每秒需要处理的消息数：
>  = 活跃验证者数量
> 1 条消息 / 1 Epoch  =
> = 1 条消息 / 32 Slots  = （一个 Epoch 由 32 个 Slots 组成）
> = 1 条消息 / (32  12 秒)  = （每个 Slot 持续 12 秒）
> = 1 条消息 / 384 秒  =
>  条消息/秒 
> 因此，我们每秒大约产生 0.0026 条消息，乘以网络中活跃验证者的数量 ：
> *  每秒约 2.6 条消息
> *  每秒约 26 条消息
> *  每秒约 260 条消息
> *  每秒约 2,600 条消息
> 
> 
目前，以太坊 PoS 协议每秒需要处理约 2,600 条消息。

出于这些原因，大多数 PoS 区块链的验证者集合非常小，通常最多只有几十个或几百个。甚至以太坊最初的提案（见 [EIP-1011](https://eips.ethereum.org/EIPS/eip-1011)）也将目标定为最多 900 名验证者，并要求至少质押 1,500 ETH 才能进入活跃验证者集合。

如果不是以太坊基金会研究员 Justin Drake 在 2018 年 5 月于 [ethresearch 网站](https://ethresear.ch/)发表的[长文](https://oreil.ly/EbBib)中提出了 **BLS 签名聚合**（BLS signature aggregation）的想法，这可能就是以太坊 PoS 协议的最终规范了。

---

> [!TIP] **译者注**：
> 1. **吞吐量与复杂度的权衡**：从后端架构师的角度看，这是一个典型的“扇入”（Fan-in）瓶颈。2,600 TPS 的签名验证请求看似不高，但如果每个验证都需要独立的 CPU 密集型椭圆曲线运算，节点会瞬间满载。`ECDSA` 的验证成本是O(n) ，即验证 n 个签名需要 n 次运算；而追求 **BLS** 的目标是将验证成本降至接近O(1) 。
> 2. **去中心化的门槛**：最初提案要求的 1,500 ETH（按现价计算是天文数字）反映了技术瓶颈对去中心化的限制。**BLS 聚合技术**的应用，直接将参与门槛降低到了 32 ETH，使得验证者数量从数百暴增至百万量级，这在分布式系统设计中是一个质的飞跃。
> 
> 
---

#### BLS 数字签名 (BLS Digital Signatures)

**BLS 签名**是以其作者的名字命名的。**BLS** 代表 Boneh、Lynn 和 Shacham，分别指代三位密码学家 [Dan Boneh](https://en.wikipedia.org/wiki/Dan_Boneh)、[Ben Lynn](https://www.google.com/search?q=https://en.wikipedia.org/wiki/Ben_Lynn_(cryptographer)) 和 [Hovav Shacham](https://en.wikipedia.org/wiki/Hovav_Shacham)。他们在 2001 年发表的一篇名为《基于 Weil 配对的短签名》（[Short Signatures from the Weil Pairing](https://www.iacr.org/archive/asiacrypt2001/22480516.pdf)）的论文中引入了这种签名方案。

与 [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)（将在第 6 章进一步解释）一样，**BLS 签名**仍然基于椭圆曲线密码学。特别地，以太坊使用了 **BLS12-381** 曲线，这是由 Sean Bowe 在 2017 年为 [Zcash](https://z.cash/) 协议工作时设计的。该曲线由以下函数定义：
```
y^2 = x^3 + 4
```
其定义域是在模q的整数域上，其中q是一个 115 位（十进制）的数字：`0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab`。

---

> [!TIP] **译者注**：
> 1. **曲线家族的差异**：作为后端开发者，你会发现以太坊地址用的 `secp256k1` 曲线方程是 ，而这里共识层用的 `BLS12-381` 是 。虽然方程看起来只是常数项变了，但 `BLS12-381` 属于“配对友好型（Pairing-friendly）”曲线。这种特性允许我们在不暴露私钥的情况下，通过某种复杂的双线性映射来验证两个加密点之间的乘法关系，这是实现“聚合签名”的数学基础。
> 2. **安全强度权衡**：`BLS12-381` 名字中的 381 代表其素数域的位宽（Bit-width）。虽然它的位宽比 `secp256k1` 更大（381 位 vs 256 位），但由于针对这类曲线的特定数学攻击（如数域筛选法）效率更高，它的实际安全性大致等同于 128 位安全强度。在后端工程实践中，这意味着处理 BLS 密钥需要更大的存储空间和不同位宽的大数库。
> 
> 

---
#### 它的工作原理 (How Does It Work?)

BLS 签名的核心思想与 [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) 非常相似：存在一个私钥，并由此派生出公钥。随后，使用私钥对每条消息进行签名，其他所有人都可以使用对应的公钥来验证消息的完整性。

**私钥 (sk)** 是一个介于 1 到 r-1 之间的整数，其中 r 是一个巨大的数字：`0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001`。它足有 77 位（十进制）之长！

**公钥 (pk)** 是通过执行 `sk * g1` 得到的，这是一个椭圆曲线点乘运算。其中 `g1` 是被称为 G1 群的生成元（Generator）。公钥以压缩和序列化的格式表示，结果为一个48字节的字符串。

被签名的**消息 (m)** 总是被映射到椭圆曲线上的一个点，该点属于另一个被称为 G2 的群。你可以将这种映射看作是一种哈希函数，它接收消息 `m`（即验证者的实际见证数据），并输出 G2 群中的一个点 `H(m)`。其压缩序列化形式为一个 **96 字节**的字符串。

最后，我们通过计算 `sk * H(m)` 得到消息 `m` 的**签名 (σ)**，这是  中的一个新的椭圆曲线点。

`ECDSA` 和 `BLS` 之间的关键区别在于这两个协议的底层细节——即它们用于验证签名正确性的数学技术。事实上，`ECDSA` 涉及的是椭圆曲线上的标量乘法和加法等线性数学计算，而 **BLS 签名**则依赖于更为复杂的**椭圆曲线双线性配对**（Elliptic curve bilinear pairings）算术。

事实上，当且仅当以下等式成立时，签名 σ 才有效：
```
e(g1,σ) = e(pk, H(m))
```
其中e是一个椭圆曲线双线性配对函数。


#### 深入椭圆曲线特性 (Inside Elliptic Curve Properties)

完全理解前面的等式需要对椭圆曲线、配对（Pairing）以及整个深奥的领域有深入的了解。但一种简单的方法是直接遵循以下步骤。虽然你可能无法掌握配对为何具有该特性的所有细节，但它仍能帮助你熟悉它：
```
e(pk, H(m)) = e(sk * g1,H(m)) = ← pk = sk * g1
= e(g1, H(m))^sk = ← thanks to a pairing property
= e(g1, sk * H(m)) = ← thanks to the same property
= e(g1,σ) ← σ = sk * H(m)
```
正如 Vitalik Buterin 在一篇 [Medium 文章](https://medium.com/@VitalikButerin/exploring-elliptic-curve-pairings-c73c1864e627)中指出的：

> 如果你将椭圆曲线上的点看作是“单向加密”后的数字，`encrypt(p) = p * G = P`，其中G是生成点，那么传统椭圆曲线数学仅允许你检查数字之间的线性约束（例如：如果 `P = G * p, Q = G * q` 并且 `R = G * r`，那么验证 `5 * P + 7 * Q = 11 * R`实际上就是在验证`5 * p + 7 * q = 11 * r`）;配对技术（Pairings）允许你检查二次约束（即乘法关系），（例如：验证 `e(P, Q) * e(G, G * 5) = 1`实际上是在检查`p * q + 1 * 5 = 0`）

你可以想象，更复杂的算术也意味着生成和验证签名需要更多时间。以太坊对验证者使用 BLS 签名的唯一原因，是因为它们具有极其重要的特性：**签名聚合**（Signature aggregation）。

事实上，如果你将两个 `ECDSA` 签名相加，你得不到任何有意义的结果。如果你尝试用该结果来证明最初签名消息的完整性，你将无法通过任何测试。

相反，如果你将两个 BLS 签名相加，你只是在进行椭圆曲线加法。结果是一个新的椭圆曲线点（位于G2中），你可以将其与两个对应公钥的和（这仍然是G1中的一个椭圆曲线点）进行验证，从而正确地验证最初签名消息的完整性。

> [!NOTE]
> 聚合签名和聚合公钥与单个签名和单个公钥是无法区分的，因此你可以使用完全相同的算法来验证聚合签名的正确性。
>
> **聚合签名和公钥:**
>```
>σagg = σ1 + σ2 + σ3 + … + σn
>pkagg = pk1 + pk2 + pk3 + … + pkn
>```
> **聚合签名验证:**
> ```
> e(pkagg,H(m)) =
>= e(pk1 + pk2 + pk3 + ... + pkn,H(M)) =
>= e((sk1 + sk2 + sk3 + ... + skn) * g1,H(m)) =
>= e(g1,H(m))^(sk1 + sk2 + sk3 + ... + skn) =
>= e(g1,(sk1 + sk2 + sk3 + ... + skn) * H(m)) =
>= e(g1,σ1 + σ2 + σ3 + ... + σn) =
>= e(g1,σagg)
> ```
---

> [!TIP] **译者注**：
> 1. **从O(N)到O(1)的跨越**：作为后端开发者，请注意聚合后的验证成本。在 `ECDSA` 中，验证 1000 个签名需要 1000 次昂贵的运算；而在 BLS 聚合方案中，无论参与签名的验证者是 10 个还是 1000 个，最终在区块中只占一个点的大小（96 字节），且只需进行**一次**配对函数运算（Pairing）即可完成验证。这种极高的吞吐效率是以太坊能支持百万级验证者的技术基石。
> 2. **线性性质的陷阱**：虽然 BLS 的加法特性非常美妙，但也带来了“流氓公钥攻击（Rogue-key attack）”的风险。简单来说，攻击者可以通过构造一个特殊的公钥来抵消掉他人的签名。在后端实现中（如以太坊的 [Beacon Chain](https://ethereum.org/en/roadmap/beacon-chain/)），我们通过要求验证者在入驻时提交“所有权证明（Proof of Possession）”，即对其公钥进行一次额外的签名，来确保公钥是真实存在的，从而规避这种数学漏洞。
> 
---
#### 总结 (In Summary)

密码学是一门非常高深的学科，它需要深厚的数学背景。本书并非专门为密码学家编写，因此有必要对前几节简要提及的内容进行总结。我们解释了 **BLS 签名**的工作原理，以及为什么选择它作为基于 **PoS**（权益证明）的新共识协议中验证者使用的数字签名算法：其**聚合特性**（Aggregation property）允许将多个数字签名压缩为一个，从而在不降低安全性的前提下，减少存储空间并缩短验证时间。

我们可以通过一个简单的例子来演示验证者在“现实生活”中如何使用 **BLS** 算法，以及签名聚合是如何发挥作用的。图 4-6 展示了一个场景：有三位验证者想要对一个区块（区块 A）表达投票。于是他们投出选票，对其进行签名，并相互分享。
![Figure 4-6](<./images/figure 4-6.png>)
**图 4-6. BLS 签名聚合：三位验证者投票并签名**

如果没有 **BLS**，你需要将所有三份已签名的选票全部存入区块中以实现永久存储。而有了 **BLS**，你可以将所有三份已签名的选票聚合为一份新的**聚合选票**（Aggregated vote），并仅将这一份存入区块。

这不仅节省了空间，还大幅减少了所有以太坊节点在验证所有签名选票时所需的时间和计算量，因为节点可以直接验证聚合后的选票，而无需对每份单独的签名选票执行验证。**BLS** 密码学的神奇之处在于，聚合结果与普通签名完全无异：这意味着验证聚合签名的难度并不比验证单个签名更高。因此，通过显著减少需要验证的签名选票数量，且每份验证所需的计算量保持不变，全节点必须执行的计算总量（以及所需的时间）远低于不使用 **BLS** 聚合签名的情况，如图 4-7 所示。
![Figure 4-7](<./images/figure 4-7.png>)
**图 4-7. BLS 签名聚合缩短验证时间**

如果验证者不遵守规则会怎样？如果验证者表现出恶意行为——例如**双重签名**（Double-signing），即同时对两个不同的区块进行投票——协议可以检测到这种行为并对验证者进行相应的惩罚，如图 4-8 所示。
![Figure 4-8](<./images/figure 4-8.png>)
**图 4-8. BLS 签名支持检测恶意验证者**

事实上，由于所有选票都使用 **BLS 签名**方案进行了数字签名，识别出对不当行为负责的验证者并对其进行相应的**罚没**（Slashing）是非常简单的。

---




[^1]: 椭圆曲线的无穷远点 (Point at Infinity, O) 是一个虚拟点，用于在射影坐标系中补全加法群的封闭性。P + (-P) = O
[^2]: 其实就是点乘或者标量乘法，在椭圆曲线密码学（ECC）中，最核心的问题是椭圆曲线离散对数问题 (ECDLP)。这里，我们知道 \(T=mS\) 中的点 \(T\) 和 \(S\)，但要求解整数 \(m\)，这个 \(m\) 就被称为离散对数或指数，因为它在计算中扮演了“次数”的角色，类似于普通数论中的指数。
[^3]: 第一版中没有这部分内容，这是很好的补充。
