# 第四章：密码学

以太坊的基础技术之一是密码学（Cryptography），它是计算机安全领域广泛应用的一个数学分支。在希腊语中，Cryptography 的意思是“秘密书写”（secret writing），但密码学的研究范畴远不止秘密书写，后者通常被称为加密（Encryption）。

例如，密码学还可以用于在不泄露秘密的情况下证明对秘密的知晓（如通过数字签名 / Digital Signature），或者证明数据的真实性（如通过数字指纹，也称为哈希 / Hashes）。这些类型的密码学证明是维持以太坊平台（以及所有区块链系统）运行的关键数学工具，同时也广泛应用于以太坊应用程序中。

请注意，截至本书出版时，以太坊协议的任何部分都不涉及加密（Encryption）；也就是说，与以太坊平台的所有通信以及节点之间的通信（包括交易数据）都是未加密的，任何人（必然地）都可以读取。这样做是为了让每个人都能验证状态更新的正确性，从而达成共识。

未来，诸如零知识证明（Zero-Knowledge Proofs）和全同态加密（Homomorphic Encryption）等先进的密码学工具将投入使用，它们允许在保持共识的同时，将一些加密计算记录在区块链上；虽然已经为此做好了准备，但这些技术尚未完全部署。

在本章中，我们将介绍以太坊中使用的一些密码学知识，即非对称加密或公钥密码学（Public Key Cryptography, PKC），它以私钥和地址的形式用于控制资金的所有权。

### 密钥与地址 (Keys and Addresses)

正如本书前面所述，以太坊有两种不同类型的账户：外部账户（**EOAs**）和合约账户（**Contracts**）。**EOAs** 对以太币（**Ether**）的所有权是通过数字**私钥**（Private Keys）、以太坊**地址**（Addresses）和数字**签名**（Signatures）建立的。

私钥是用户与以太坊进行所有交互的核心。事实上，账户地址是直接由私钥派生出来的：一个私钥唯一地决定了一个以太坊地址，这也通常被称为一个账户。

在以太坊系统中，私钥绝不会被直接使用；它们从不在以太坊上传输或存储。也就是说，私钥必须保持私密，绝不能出现在发送给网络的任何消息中，也不应存储在链上。在以太坊系统中传输和存储的只有账户地址和数字签名。

对资金的访问和控制是通过数字签名实现的，而数字签名同样是使用私钥创建的。以太坊交易必须包含有效的数字签名才能被纳入区块链。任何持有私钥副本的人都拥有对相应账户及其持有的以太币的控制权。只要用户妥善保管私钥，以太坊交易中的数字签名就能证明资金的真实所有者，因为签名证明了对私钥的持有权。

在基于公钥加密（**PKC**）的系统中（如以太坊），密钥成对出现，由一个**私钥（秘密密钥）**和一个**公钥**组成。你可以将公钥类比为银行账号，将私钥类比为秘密取款密码（**PIN**）；后者提供对账户的控制权，而前者用于向他人标识该账户。以太坊用户很少能直接看到私钥本身；在大多数情况下，私钥（以加密形式）存储在特殊文件中，并由以太坊钱包软件进行管理。

在以太坊交易的支付部分，收款人由以太坊地址表示，其用法与银行转账中的受益人账户明细相同。正如我们稍后将详细看到的，**EOA** 的以太坊地址是由密钥对中的公钥部分生成的。然而，并非所有以太坊地址都代表公钥-私钥对；它们也可以代表合约。我们将在第 7 章看到，合约并不受私钥支持。

在这一章接下来的部分中，我们将：

* 深入探讨密码学的基础，并探索其在以太坊中的数学原理。
* 研究密钥生成、存储和管理的过程。
* 审阅私钥、公钥和地址所使用的各种编码格式。
* 调研验证者密钥（**Validator Key**）密码学和 **KZG** 承诺方案，这些代表了以太坊密码学基础设施的最新更新。

### 公钥密码学 (PKC) 与加密货币 (Cryptocurrency)

**公钥密码学**（PKC，也称为**非对称加密** / Asymmetric Cryptography）是现代信息安全的基石。由 Martin Hellman、Whitfield Diffie 和 Ralph Merkle 在 20 世纪 70 年代首次发表的**密钥交换协议**（Key exchange protocol）是一项划时代的突破，它引发了公众对密码学领域的第一次大规模关注。在 20 世纪 70 年代之前，强大的密码学知识一直被政府视为最高机密。

**PKC** 使用唯一的密钥来保护信息。这些密钥基于具有特殊性质的数学函数：**正向计算容易，但逆向推导极难**。基于这些函数，密码学能够创建受数学定律保护的数字秘密和不可伪造的数字签名。

例如，将两个巨大的质数相乘是非常简单的。但是，如果给定这两个大质数的乘积，要找到它们的质因数却极其困难（这个问题被称为**质因数分解** / Prime factorization）。假设我们给出一个数字 `8,018,009` 并告诉你它是两个质数的乘积，那么你寻找这两个质数的难度，要远大于我将它们相乘得出该结果的难度。

如果已知某些秘密信息，其中一些数学函数可以很容易地被求逆。在上述例子中，如果我告诉你其中一个质因数是 `2,003`，你就可以通过简单的除法轻松找到另一个：。这类函数通常被称为**陷门函数**（Trapdoor functions），因为除非获得可以作为逆转函数“捷径”的秘密信息，否则它们极难求逆。

密码学中一类更有用的高级数学函数是基于**椭圆曲线**（Elliptic Curve）的算术运算。在椭圆曲线算术中，模素数乘法（Multiplication modulo a prime）很简单，但其逆运算——除法——在实际操作中几乎是不可能的。这被称为**离散对数问题**（Discrete logarithm problem），且目前尚无已知的“陷门”。**椭圆曲线密码学**（ECC）广泛应用于现代计算机系统，也是以太坊（以及其他加密货币）使用私钥和数字签名的基础。

> [!NOTE]
> 如果您有兴趣阅读更多关于现代密码学中使用的数学函数，请参考以下资源：
> * 密码学 (Cryptography)
> * 陷门函数 (Trapdoor function)
> * 质因数分解 (Prime factorization)
> * 离散对数 (Discrete logarithm)
> * 椭圆曲线密码学 (Elliptic curve cryptography)
> 
> 

在以太坊中，我们使用 **PKC** 来创建本章一直在讨论的公私钥对。它们被视为一个“对”，是因为公钥是从私钥派生出来的。它们共同代表了一个以太坊账户：公钥提供了一个公开可访问的账户标识（地址），而私钥则提供了对账户中以太币访问权限的私密控制，以及在使用智能合约时所需的任何身份验证。私钥通过作为创建数字签名所需的唯一信息来控制访问权限，而签署交易以动用账户资金必须提供数字签名。数字签名也用于验证合约所有者或用户，我们将在第 7 章看到这一点。

> [!TIP]
> 在大多数钱包实现中，为了方便，私钥和公钥是作为密钥对存储在一起的。然而，由于公钥可以从私钥轻松计算出来，因此仅存储私钥也是可行的。

数字签名可以为任何消息创建。对于以太坊交易，交易细节本身就被用作“消息”。密码学的数学原理——在这里是椭圆曲线密码学——提供了一种将消息（即交易细节）与私钥结合的方法，从而产生一个只有通过私钥知识才能生成的代码。这个代码就被称为**数字签名**。

请注意，以太坊交易本质上是访问具有特定以太坊地址的特定账户的请求。当交易被发送到以太坊网络以转移资金或与智能合约交互时，必须附带由该以太坊地址对应的私钥创建的数字签名。椭圆曲线数学意味着任何人都可以通过检查数字签名是否与交易细节以及请求访问的以太坊地址匹配，来验证交易的有效性。**验证过程完全不涉及私钥**；私钥始终保持私密。然而，验证过程可以确凿无疑地判定，该交易只能来自于持有与该以太坊地址背后的公钥相对应的私钥的人。这就是 **PKC** 的“魔力”所在。

> [!TIP]
> 以太坊协议本身不包含任何加密——所有作为以太坊网络运行的一部分发送的消息（必然地）都可以被所有人读取。因此，私钥仅用于创建用于交易身份验证的数字签名。


### 私钥 (Private Keys)

私钥本质上只是一个随机选取的数字。对私钥的所有权和控制权是用户控制相关以太坊地址下所有资金，以及访问授权该地址的合约的根基。私钥用于创建支出以太币所需的签名，以此证明交易中所用资金的所有权。私钥必须始终保持机密，因为将其泄露给第三方等同于将该私钥保护下的以太币和合约控制权拱手相让。私钥还必须进行备份，并防止意外丢失。如果私钥丢失，它将无法找回，其保护下的资金也将永远丢失。

> [!TIP]
> 以太坊私钥就是一个数字。随机选取私钥的一种方法是直接使用硬币、铅笔和纸：抛 256 次硬币，你就得到了一个可以在以太坊钱包中使用的随机私钥的二进制位（大概可以，详见下文）。随后即可从该私钥生成公钥和地址。

生成密钥的第一步也是最重要的一步，是寻找一个安全的**熵**（Entropy）源，即随机性来源。创建一个以太坊私钥本质上涉及在  到  之间选取一个数字。只要这个数字是不可预测且非确定性的，你使用什么具体方法来选取它并不重要。以太坊软件使用底层操作系统的**随机数生成器**（RNG）来产生 256 位随机位。通常，操作系统的 **RNG** 是通过人为的随机源进行初始化的，这就是为什么你可能会被要求随意移动几秒钟鼠标，或在键盘上随机敲击按键。另一种替代方案可以是计算机麦克风通道上的宇宙辐射噪声。

更准确地说，私钥可以是  到略小于  的任意非零数字——这是一个巨大的 78 位数字，约为 。这个精确数字的前 38 位与  相同，它被定义为以太坊所使用的椭圆曲线的**阶**（Order）。为了创建私钥，我们随机选取一个 256 位的数字，并检查它是否在有效范围内。在编程层面，这通常是通过将更长的随机位字符串（采集自密码学安全的随机源）输入到 **Keccak-256** 或 **SHA-256** 等 256 位哈希算法中来实现的，这两种算法都能方便地生成一个 256 位的数字。如果结果在有效范围内，我们就得到了一个合适的私钥。否则，我们只需换一个随机数再次尝试。

> [!NOTE]
> 以太坊私钥空间的大小————是一个超乎想象的天文数字。它在十进制下大约是 ，即一个 78 位的数字。作为对比，可见宇宙估计包含  个原子。因此，私钥的数量几乎多到可以给宇宙中的每个原子分配一个以太坊账户。如果你随机选取一个私钥，没有任何可行的方法让别人猜到它或撞巧选中它。

请注意，生成私钥的过程是离线的；它不需要与以太坊网络进行任何通信，事实上也不需要与任何人通信。因此，要选取一个别人永远选不到的数字，它必须是真正随机的。如果你自己手动挑选数字，别人也尝试到这个数字（并卷走你的以太币）的概率就太高了。使用拙劣的 **RNG**（如大多数编程语言中的伪随机函数 `rand`）甚至更糟，因为它是显而易见且极易复现的。就像在线账户的密码一样，私钥必须是不可猜测的。幸运的是，你永远不需要记住你的私钥，所以你可以采用选取私钥的最佳方法：**真随机性**（True randomness）。

> [!WARNING]
> 不要编写自己的代码来创建随机数，也不要使用编程语言提供的“简单”**RNG**。请注意，浏览器钱包中基于 **JavaScript** 的 **RNG** 可能是不安全的，除非有操作系统熵源的支持。至关重要的是，你必须使用**密码学安全的伪随机数生成器**（CSPRNG），并配合具有足够熵源的种子。请仔细研读你所选随机数库的文档，确保其在密码学上是安全的。**CSPRNG** 库的正确实现对密钥的安全性至关重要。

以下是一个十六进制格式显示的随机生成私钥（256 位显示为 64 个十六进制字符，每个字符代表 4 位）：

`f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315`


### 公钥 (Public Keys)

以太坊公钥是椭圆曲线上的一个点，这意味着它是一组满足椭圆曲线方程的  和  坐标。

简单来说，以太坊公钥是由两个数字拼接而成的。这两个数字通过一种**单向计算**从私钥生成。这意味着如果你拥有私钥，计算公钥是轻而易举的；但你无法从公钥反推回私钥。

> [!WARNING]
> 数学高能预警！请保持冷静。如果你在接下来的段落中感到困惑，可以跳过后续几小节。市面上有许多工具和库可以帮你完成这些复杂的数学计算。

公钥是通过**椭圆曲线乘法**（Elliptic Curve Multiplication）从私钥计算得出的，这种运算在实际操作中是不可逆的：。其中  是私钥， 是一个被称为**生成点**（Generator Point）的常数点， 是生成的公钥，而  是特殊的椭圆曲线“乘法”运算符。

请注意，椭圆曲线乘法不同于普通的乘法。除了在函数特性上与普通乘法有相似之处外，两者基本没有共同点。例如，其逆运算（在普通数字中是除法）被称为“求解离散对数”——即在已知  的情况下计算 。其难度相当于尝试  的所有可能值（这种暴力搜索所需的时间可能超过宇宙的寿命）。

通俗地说，椭圆曲线上的算术与“常规”整数算术完全不同。点（）可以乘以一个整数（）得到另一个点（）。但由于不存在“除法”运算，因此不可能通过简单地用公钥  “除以”点  来计算出私钥 。这就是我们在前文“PKC 与加密货币”一节中提到的单向数学函数。

> [!NOTE]
> 椭圆曲线乘法是密码学家所称的“单向函数”的一种：它在一个方向上（乘法）很容易执行，而在相反方向上（除法）则无法实现。私钥持有者可以轻松生成公钥并将其分享给全世界，因为他知道没人能通过逆向推导从公钥计算出私钥。这一数学技巧成为了不可伪造且安全的数字签名的基石，用于证明对以太坊资金的所有权及对合约的控制权。

在我们演示如何从私钥生成公钥之前，让我们先更详细地了解一下椭圆曲线密码学。

#### 椭圆曲线密码学详解 (Elliptic Curve Cryptography Explained)

椭圆曲线密码学（Elliptic Curve Cryptography, ECC）是一种基于离散对数问题（Discrete Logarithm Problem）的非对称或公钥密码学（Public Key Cryptography），该问题通过椭圆曲线点上的加法和乘法运算来体现。图 4-1 是一个椭圆曲线的示例，类似于以太坊所使用的曲线。

> [!NOTE]
> 以太坊使用的椭圆曲线与比特币完全相同，称为 `secp256k1`。这使得重用比特币的许多椭圆曲线库和工具成为可能。
![Figure 4-1](<./images/figure 4-1.png>)
>
图 4-1. 一个椭圆曲线

以太坊使用特定的椭圆曲线和一组数学常数，这些常数由美国国家标准与技术研究院（NIST）建立的名为 `secp256k1` 的标准定义。`secp256k1` 曲线由以下产生椭圆曲线的函数定义：
```
y^2 = (x^3 + 7) over (Fp)
```

或者：
```
y^2 mod p = (x^3 + 7) mod p
```

其中 `mod p`（模素数 ）表示该曲线位于素数阶为 p 的有限域（Finite Field）上，也写作`Fp` ，其中 p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1, 。这是一个非常大的素数。

由于这条曲线是定义在素数阶有限域上而非实数域（Real Numbers）上，它看起来像是在二维空间中散落的点阵模式，这使得它难以直观可视化。然而，其数学原理与实数域上的椭圆曲线完全一致。作为示例，图 4-2 展示了在素数阶为 17 的更小有限域上的同一条椭圆曲线，呈现为网格上的点阵模式。以太坊的 `secp256k1` 曲线可以被想象成在一个难以想象的巨大网格上呈现的、更为复杂的点阵模式。
![Figure 4-2](<./images/figure 4-2.png>)
图 4-2. 椭圆曲线密码学：可视化  上的椭圆曲线

例如，以下是一个坐标为  的点 ，它是 `secp256k1` 曲线上的一个点：
```
Q = (49790390825249384486033144355916864607616083520101638681403973749255924539515, 59574132161899900045862086493921015780032175291755807399284007721050341297360)
```
示例 4-1 展示了如何使用 **Python** 自行验证这一点。变量 `x` 和 `y` 是点  的坐标，如前例所示。变量 `p` 是椭圆曲线的素数阶（用于所有模运算的素数）。**Python** 代码的最后一行是椭圆曲线方程（**Python** 中的 `%` 运算符是模运算符）。如果 `x` 和 `y` 确实是椭圆曲线上某个点的坐标，那么它们将满足方程，结果为零。你可以尝试在命令行输入 `python`（或 `python3`）并复制列表中的每一行（在提示符 `>>>` 之后）来进行测试。

**示例 4-1. 使用 Python 确认该点位于椭圆曲线上**

```python
Python 3.12.4 (main, Jun  6 2024, 18:26:44) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 49790390825249384486033144355916864607616083520101638681403973749255924539515
>>> y = 59574132161899900045862086493921015780032175291755807399284007721050341297360
>>> (x ** 3 + 7 - y**2) % p
0
```

#### 椭圆曲线算术运算 (Elliptic Curve Arithmetic Operations)

许多椭圆曲线数学看起来和运作起来都非常像我们在学校学到的整数算术。具体来说，我们可以定义一个**加法运算符**（addition operator），它不是沿着数轴跳跃，而是跳跃到曲线上的其他点。一旦我们有了加法运算符，我们就可以定义点与整数之间的**乘法**（multiplication），这等同于重复的加法。

椭圆曲线加法的定义是：给定椭圆曲线上的两个点P1和P2，存在第三个点P3，该点同样位于椭圆曲线上。

从几何上看，这第三个点是通过在P1和P2之间画一条直线来计算的。令人惊叹的是，这条直线将与椭圆曲线交于且仅交于一个额外的地方。将这个点记为P3′ = (x, y)。然后关于x轴进行对称反射，得到P3，如图 4-3 所示。
[Figure 4-3](<./images/figure 4-3.png>)
**图 4-3. 椭圆曲线加法：在椭圆曲线上将两点相加**

如果P1和P2是同一个点，那么P1和P2“之间”的直线应该延伸为曲线在该点P1处的切线。这条切线将恰好与曲线交于一个新的点，如图 4-4 所示。你可以使用微积分技术来确定切线的斜率。有趣的是，尽管我们将关注点限制在具有两个整数坐标的曲线上，这些技术依然有效！
[Figure 4-4](<./images/figure 4-4.png>)
图 4-4. 椭圆曲线加法：点与其自身相加（二倍点）

在椭圆曲线数学中，还存在一个被称为**无穷远点**（point at infinity）的点，它大致对应于加法中数字0的角色。在计算机上，它有时由 `x = y = 0` 表示（虽然这不满足椭圆曲线方程，但这是一个易于检查的特殊情况）。有几个特殊情况解释了对无穷远点的需求。

在某些情况下（例如，如果P1和P2具有相同的x值但y值不同，如图 4-5 所示），直线将是垂直的，在这种情况下P3 = 无穷远点。
[Figure 4-5](<./images/figure 4-5.png>)
图 4-5. 椭圆曲线加法：导致无穷远点的特殊情况

如果P1是无穷远点，则P1+P2=P2 。同样地，如果P2是无穷远点，则P1+P2=P1。这展示了无穷远点如何扮演“正常”算术中零的角色[^1]。

事实证明，加法运算符 `+` 满足**结合律**（associative），这意味着  `(A + B) + C = A + (B + C)`。这代表我们可以无歧义地写作 `A + B + C`（不加括号）。

现在我们已经定义了加法，我们可以通过扩展加法的标准方式来定义**乘法**[^2]。对于椭圆曲线上的点 ，如果k是一个整数，那么`k * P = P + P + P + … + P`（共k次）。请注意，在这种情况下， k有时（可能会令人困惑地）被称为**指数**（exponent）。

---

> [!TIP]
> **译者注**：
> 1. **计算效率优化**：在后端底层实现（如 `libsecp256k1`）中，计算  并非真的执行k次加法。开发者通常使用 **双倍加算法**（Double-and-Add），其时间复杂度为 。这与快速幂算法的逻辑一致，是保证以太坊签名验证毫秒级响应的关键。
> 2. **常量时间执行**：在编写处理私钥（即 ）的底层代码时，必须确保算术运算是**常量时间**（Constant Time）的。如果由于  的二进制位不同导致计算时长有细微差异，攻击者可以通过“侧信道攻击”（Side-channel attack）根据耗时推导出私钥。
> 
> 

---
#### 生成公钥 (Generating a Public Key)

从一个随机生成的数字形式的私钥 `k` 开始，我们将其与曲线上一个预定义的点——**生成点**（generator point）`G` 相乘，从而在曲线上的其他位置产生另一个点，这就是对应的公钥 `K`：
```
K = k * G
```
生成点是在 `secp256k1` 标准中指定的；对于所有 `secp256k1` 的实现来说，它都是相同的，并且所有从该曲线派生出的密钥都使用同一个点 `G`。由于生成点对所有以太坊用户都是固定的，因此私钥 `k` 与 `G` 相乘将始终得到相同的公钥 `K`。`k` 和 `K` 之间的关系是确定的，但只能沿一个方向计算，即从 `k` 到 `K`。这就是为什么以太坊地址（由 `K` 派生）可以与任何人分享，而不会泄露用户的私钥（`k`）。

正如我们在前一节中所描述的，`k * G` 的乘法等同于重复加法，即 `G + G + G + … + G`，重复 `k` 次。总而言之，为了从私钥 `k` 产生公钥 `K`，我们将生成点 `G` 自身相加 `k` 次。



> [!TIP]
> 私钥可以转换为公钥，但公钥无法转换回私钥，因为数学运算是单向的。

让我们利用这一计算过程，为我们在“私钥”（Private Keys）章节中展示的特定私钥寻找公钥：

`K = f8f8a2f43c8376ccb0871305060d7b27b0554d2cc72bccf41b2705608452f315 * G`

密码学库可以利用椭圆曲线乘法帮助我们计算 `K`。生成的公钥 `K` 被定义为一个点：

`K = (x, y)`

其中：
```
x = 6e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b
y = 83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0
```
在以太坊中，你可能会看到公钥被表示为 130 个十六进制字符（65 字节）的序列化字符串。这是采用了工业联盟高效密码组（Standards for Efficient Cryptography Group, SECG）在《高效密码标准》（SEC1）文档中提出的标准序列化格式。该标准定义了四种可能的出前缀，用于识别椭圆曲线上的点，如表 4-1 所示。

表 4-1. 序列化椭圆曲线公钥前缀
![Table 4-1](<./images/table 4-1.png>)

以太坊仅使用**未压缩公钥**（uncompressed public keys），因此唯一相关的前缀是十六进制的 `04`。序列化过程将公钥的 `x` 坐标和 `y` 坐标拼接在一起：

`04 + x 坐标 (32 字节 / 64 位十六进制) + y 坐标 (32 字节 / 64 位十六进制)`

因此，我们之前计算的公钥序列化结果为：

`046e145ccef1033dea239875dd00dfb4fee6e3348b84985c92f103444683bae07b83b5c38e5e2b0c8529d7fa3f64d46daa1ece2d9ac14cab9477d042c84c32ccd0`

#### 椭圆曲线库 (Elliptic Curve Libraries)

在加密货币相关项目中，有几种常用的 `secp256k1` 椭圆曲线实现：

### 椭圆曲线库 (Elliptic Curve Libraries)

在加密货币相关项目中，有几种常用的 [secp256k1](https://www.secg.org/sec2-v2.pdf) 椭圆曲线实现：

[**OpenSSL**](https://www.openssl.org/)
OpenSSL 库提供了一套全面的密码学原语，包括完整的 `secp256k1` 实现。例如，可以使用 [`EC_POINT_mul`](https://www.openssl.org/docs/manmaster/man3/EC_POINT_mul.html) 函数来从私钥派生公钥。

[**libsecp256k1**](https://github.com/bitcoin-core/secp256k1)
Bitcoin Core 的 `libsecp256k1`是一个用 C 语言编写的 `secp256k1` 椭圆曲线及其他密码学原语的实现。它最初是为了在 Bitcoin Core 软件中取代 OpenSSL 而从零编写的，在性能和安全性方面都被认为更加优越。

---



---


[^1]: 椭圆曲线的无穷远点 (Point at Infinity, O) 是一个虚拟点，用于在射影坐标系中补全加法群的封闭性。P + (-P) = O
[^2]: 其实就是点乘或者标量乘法，在椭圆曲线密码学（ECC）中，最核心的问题是椭圆曲线离散对数问题 (ECDLP)。这里，我们知道 \(T=mS\) 中的点 \(T\) 和 \(S\)，但要求解整数 \(m\)，这个 \(m\) 就被称为离散对数或指数，因为它在计算中扮演了“次数”的角色，类似于普通数论中的指数。
