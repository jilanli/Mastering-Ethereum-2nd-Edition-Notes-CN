# 第十四章：以太坊虚拟机

以太坊虚拟机（EVM）是以太坊协议和运行的核心。正如你从名字中猜到的那样，它是一个计算引擎，与微软 .NET 框架的虚拟机或 Java 等其他字节码编译语言的解释器并没有本质区别。
在本章中，我们将深入探讨 EVM 的指令集、架构及其在以太坊状态更新背景下的运作方式。

## 什么是 EVM
EVM（以太坊虚拟机）是以太坊中负责处理智能合约部署与执行的核心部分。从实际操作层面来看，从一个外部账户（EOA）到另一个外部账户的简单价值转账交易并不需要它参与；
除此之外，几乎所有的操作都会涉及由 EVM 计算的状态更新。从宏观角度来看，运行在以太坊区块链上的 EVM 可以被视为一台全球化的去中心化计算机，
它包含数百万个可执行对象，每个对象都有其独立的永久数据存储库。

EVM 是一个**准图灵完备**（Quasi-Turing-Complete）状态机：之所以说它是“准”完备，是因为所有的执行过程都受限于气数（Gas）的额度，
而 Gas 限制了任何给定智能合约执行的计算步数。因此，**停机问题**（Halting Problem）得到了“解决”（所有程序的执行最终都会停止），
从而避免了执行过程（因意外或恶意）永久运行并导致整个以太坊平台陷入停滞的情况。我们将在本章稍后部分更详细地探讨停机问题。

EVM 采用栈式架构（Stack-Based Architecture），将所有内存中的数值存储在栈（Stack）上。
它的字长（Word Size）为 256 位，这主要是为了便于进行原生的哈希运算和椭圆曲线运算。它拥有以下几个可寻址的数据组件：
* 不可变的程序代码 ROM：加载了待执行智能合约的字节码。
* 易失性内存（Memory）：每个位置在初始状态都被显式地置为零。
* 瞬时存储（Transient Storage）：仅在单笔交易期间存在（且不属于以太坊状态的一部分）。
* 永久存储（Storage）：是以太坊状态的一部分，初始状态同样被置为零。

此外，在执行期间还有一组环境变量和数据可供调用。我们将在本章稍后部分详细介绍这些内容。
![Figure 14-1](<./images/figure 14-1.png>)

图 14-1. EVM 架构与执行上下文

## 与现有技术的比较
“虚拟机”一词通常应用于对真实计算机的虚拟化——通常由 VirtualBox 或 QEMU 等管理程序（Hypervisor）实现；
或者是对整个操作系统实例的虚拟化，如 Linux 的 KVM。这些技术必须分别提供对实际硬件、系统调用以及其他内核功能的软件抽象。

EVM 的运行领域则受限得多：它仅仅是一个计算引擎，因此仅提供对计算和存储的抽象，这一点类似于 Java 虚拟机（JVM）规范。
从宏观角度看，JVM 旨在提供一个与底层主机操作系统或硬件无关的运行环境，从而实现跨多种系统的兼容性。
诸如 Java、Scala（使用 JVM）或 C#（使用 .NET）等高级编程语言，都会被编译成各自虚拟机的字节码指令集。
同样地，EVM 执行其专有的字节码指令集（将在下一节描述），而 Solidity、Vyper 和 Yul 等高级智能合约编程语言也会被编译成这种字节码。

因此，EVM 不具备调度能力，因为执行顺序是在其外部组织的：以太坊客户端通过扫描经过验证的区块交易，
来确定哪些智能合约需要执行以及按何种顺序执行。从这个意义上说，以太坊世界计算机是单线程的，类似于 JavaScript。
EVM 也不具备任何“系统接口”处理或“硬件支持”——因为它没有物理机器可以进行接口交互。以太坊世界计算机是完全虚拟的。

## 其他区块链在做什么？

EVM 绝对是加密货币领域应用最广泛的虚拟机。大多数竞争性 L1（第一层）和 L2（第二层）区块链都采用 EVM，以保持与现有工具和框架的兼容性，
并直接从以太坊社区吸引项目和开发者。

尽管如此，近年来也涌现出了一批各具特色的虚拟机：Solana VM、Wasm VM、Cairo VM 和 Move VM 可能是其中最著名且最有趣的，
它们各有利弊。这些虚拟机在智能合约开发路线上采取了不同的方案：

**自定义语言**

一些平台（如 Cairo 和 Move）创建了专门用于编写智能合约的编程语言。这类似于以太坊为其虚拟机 EVM 使用 Solidity 和 Vyper。

**标准语言**

其他平台（如 Solana 和使用 WebAssembly (Wasm) 的平台）允许开发者使用广泛通用的编程语言编写智能合约。
例如，这些平台通常支持使用 Rust 进行开发。

这些替代虚拟机与 EVM 的另一个不同之处在于交易的并行化（Parallelization）。我们已经提到过，EVM 按顺序处理交易，没有任何形式的并行化。
一些项目针对这一缺陷进行了改进。例如，Solana VM 和 Move VM 都能处理交易的并行执行，尽管这并非在所有情况下都可行——也就是说，
当两笔交易通过与同一个合约交互来修改同一块存储空间时，它们无法并行执行。

必须说明的是，这些改进虚拟机性能的努力并不仅仅发生在以太坊之外。事实上，许多团队正致力于突破 EVM 的当前限制，
尝试引入并行化以及其他酷炫功能，例如将 EVM 字节码**提前编译**（AOT）或**即时编译**（JIT）为原生机器码。

## EVM 指令集（字节码操作）
EVM 指令集提供了你所预期的大多数操作，包括：
* 算术及位逻辑运算
* 执行上下文查询
* 栈（Stack）、内存（Memory）及存储（Storage）访问
* 流程控制操作
* 日志、调用及其他操作符

除了典型的字节码操作外，EVM 还可以访问账户信息（如地址和余额）和区块信息（如区块高度和当前气价）。

让我们通过查看可用的操作码（Opcodes）及其功能，开始对 EVM 进行更深入的探索。正如你所预料的，所有操作数（Operands）均取自栈顶，而执行结果（如果适用）通常会被重新压回栈顶。

可用的操作码可以分为以下几类：
### 算术运算 (Arithmetic Operations)
算术操作码指令包括：
```
ADD // 将栈顶的两个项相加
MUL // 将栈顶的两个项相乘
SUB // 将栈顶的两个项相减
DIV // 整数除法
SDIV // 有符号整数除法
MOD // 取模（余数）运算
SMOD // 有符号取模运算
ADDMOD // 对任意数取模的加法运算
MULMOD // 对任意数取模的乘法运算
EXP // 指数运算
SIGNEXTEND // 扩展补码有符号整数的长度
SHA3 // 计算内存块的 Keccak-256 哈希值
```
除非另有说明，所有算术运算均在模 $2^{256}$ 的前提下进行，且 $0^0$ 的值取为 1。

### 栈操作
栈、内存及存储管理指令包括：
```
POP // 从栈顶移除一个项
MLOAD // 从内存中加载一个字（32 字节）到栈
MSTORE // 将一个字从栈保存到内存
MSTORE8 // 将一个字节从栈保存到内存
SLOAD // 从永久存储中加载一个字到栈
SSTORE // 将一个字从栈保存到永久存储
TLOAD // 从瞬时存储中加载一个字到栈
TSTORE // 将一个字从栈保存到瞬时存储
MSIZE // 获取当前活跃内存的大小（以字节为单位）
PUSH0 // 将数值 0 压入栈顶
PUSHx // 将 x 字节的项目压入栈顶，其中 x 为 1 到 32（全字）之间的任意整数
DUPx // 复制第 x 个栈项，其中 x 为 1 到 16 之间的任意整数
SWAPx // 交换第 1 个和第 (x+1) 个栈项，其中 x 为 1 到 16 之间的任意整数
```

### 流程控制操作
用于控制执行流程的指令包括：
```
STOP // 停止执行
JUMP // 将程序计数器（PC）设置为任意值
JUMPI // 有条件地修改程序计数器（即条件跳转）
PC // 获取程序计数器的当前值（在该指令本身引起的增量之前的值）
JUMPDEST // 标记一个有效的跳转目标地址
```

### 系统操作 
用于执行程序的系统级操作码包括：
```
LOGx // 附加一条带有 x 个主题（Topics）的日志记录，其中 x 为 0 到 4 之间的任意整数。
CREATE // 创建一个带有相关代码的新账户（即部署新合约）。
CALL // 对另一个账户进行消息调用，即运行另一个账户的代码。
CALLCODE // 在当前账户环境中运行另一个账户的代码（已基本被替代）。
RETURN // 停止执行并返回输出数据。
DELEGATECALL // 在当前账户环境中运行另一个账户的代码，但保留原始发送者（Sender）和价值（Value）信息。
STATICCALL // 对账户进行静态消息调用，即不允许修改任何账户的状态。
REVERT // 停止执行并回滚状态更改，但返回错误信息并退还剩余气数（Gas）。
INVALID // 指定的无效指令。
SELFDESTRUCT // 停止执行；如果在创建合约的同一笔交易中执行，则将账户注册为待删除。请注意，目前强烈不建议使用此指令，且该操作码已被视为“废弃”状态。
```

### 逻辑运算（Logic operations）
用于比较和位逻辑运算的操作码包括：
```
LT // 小于（Less-than）比较
GT // 大于（Greater-than）比较
SLT // 有符号小于比较
SGT // 有符号大于比较
EQ // 等于（Equality）比较
ISZERO // 简单的非（NOT）运算符，检查值是否为 0
AND // 按位与（AND）运算
OR // 按位或（OR）运算
XOR // 按位异或（XOR）运算
NOT // 按位取反（NOT）运算
BYTE // 从一个 256 位全宽字（Word）中提取单个字节
```

### 环境操作 (Environmental Operations)
处理执行环境信息的操考码包括：
```
GAS // 获取当前可用的气数（Gas）余额（扣除本条指令的消耗后）。
ADDRESS // 获取当前正在执行的账户地址。
BALANCE // 获取指定账户的以太币余额。
ORIGIN // 获取发起本次 EVM 执行的外部账户（EOA）地址（即交易的原始发起者）。
CALLER // 获取直接发起本次执行的调用者地址。
CALLVALUE // 获取本次调用由调用者存入的以太币金额。
CALLDATALOAD // 获取调用者发送的输入数据（Calldata）。
CALLDATASIZE // 获取输入数据的字节大小。
CALLDATACOPY // 将输入数据复制到内存中。
CODESIZE // 获取当前环境运行的代码大小。
CODECOPY // 将当前环境运行的代码复制到内存中。
GASPRICE // 获取原始交易指定的单位气价。
EXTCODESIZE // 获取指定外部账户的代码大小。
EXTCODECOPY // 将指定外部账户的代码复制到内存中。
RETURNDATASIZE // 获取当前环境下上一次调用返回的输出数据大小。
RETURNDATACOPY // 将上一次调用的输出数据复制到内存中。
```

### 区块操作 (Block Operations)

用于获取当前区块信息的操考码包括：
```
BLOCKHASH // 获取最近完成的 256 个区块之一的哈希值。
COINBASE // 获取该区块奖励的受益人地址（即打包该区块的验证者地址）。
TIMESTAMP // 获取该区块的时间戳。
NUMBER // 获取当前区块的高度（区块编号）。
PREVRANDAO // 获取前一个区块的 RANDAO 混合值。自“合并（The Merge）”硬分叉以来，该操作码取代了原有的 DIFFICULTY（难度）操作码。
GASLIMIT // 获取该区块的气数限制（Gas Limit）。
```

## 以太坊状态
EVM 的工作是根据以太坊协议的定义，通过计算智能合约代码执行产生的有效状态转换来更新以太坊状态。
这一特性使得以太坊被描述为一种基于交易的状态机 (Transaction-based State Machine)，
反映了外部参与者（即账户持有者和验证者）通过创建、接受和排序交易来启动状态转换的事实。此时，了解什么构成了以太坊状态是很有帮助的。

在顶层，我们有以太坊全局状态 (Ethereum World State)。全局状态是自以太坊地址（160 位数值）到账户的映射。在底层，每个以太坊地址代表一个账户，包含以下内容：
以太币余额 (Ether Balance)：以该账户拥有的 Wei 数量存储。
Nonce：如果是外部账户（EOA），代表从该账户成功发送的交易数量；如果是合约账户，则代表由其创建的合约数量。
账户存储 (Account Storage)：仅供智能合约使用的永久数据存储库。
账户程序代码 (Program Code)：同样仅存在于智能合约账户中。

传统上，EOA 既没有代码也没有存储。然而，[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)（于 2025 年 5 月的 Pectra 升级中激活）改变了这一假设，允许 EOA 将代码执行委托给智能合约。当 EOA 选择委托时，其代码字段会被设为一个 23 字节的委托标识 (Delegation Designation)，格式为 `0xef0100 || address`，其中 address 是目标合约的 20 位地址。根据 [EIP-3541](https://eips.ethereum.org/EIPS/eip-3541)，`0xef` 字节是一个被禁用的操作码，确保此标识不会与可部署的合约代码混淆。当 EVM 遇到对已委托 EOA 的调用时，它会在该 EOA 的上下文中加载并执行目标地址的代码。这意味着对委托 EOA 执行 EXTCODESIZE 会返回 23（委托标识的大小），而在委托代码内执行 CODESIZE 则返回目标合约代码的大小。EOA 在执行委托代码时也可以使用存储，尽管协议建议使用 [ERC-7201](https://eips.ethereum.org/EIPS/eip-7201) 命名空间存储布局，以防止在迁移委派合约时发生冲突。重要的是，已委托的 EOA 仍然可以发起交易——它们依然是可以签名发送交易的 EOA，只是现在具备了智能合约的能力。通过委托给零地址可以清除该委托（`0x0000000000000000000000000000000000000000`）。

当一笔交易触发智能合约代码执行时，一个 EVM 实例会被初始化，并包含当前创建区块及所处理交易相关的所有必要信息。特别地，EVM 的程序代码 ROM 会加载被调用合约账户的代码，程序计数器置零，从合约账户加载存储，内存全部置零，并设置所有区块和环境变量。一个关键变量是本次执行的 Gas 供应量。随着代码执行，Gas 供应量根据操作消耗而减少。如果在任何时刻 Gas 供应量小于零，就会触发 Gas 耗尽 (OOG) 异常：执行立即停止，交易被放弃。除了发送者的 Nonce 增加且余额减少（用于支付资源消耗）外，不会对以太坊状态应用任何更改。此时，你可以将 EVM 视为在以太坊全局状态的沙盒副本上运行，如果执行失败，该沙盒版本将被彻底丢弃。只有在执行成功时，真实世界状态才会更新以匹配沙盒版本。

代码执行是一个递归过程。一个合约可以调用其他合约，每次调用都会围绕新的调用目标实例化另一个 EVM。每个实例的沙盒世界状态都由上一层 EVM 的沙盒状态初始化。每个实例（上下文）也会被分配特定数量的 Gas 供应量（当然不会超过上一层剩余的 Gas），因此它也可能因 Gas 不足而异常停止。在这种情况下，该层的沙盒状态被丢弃，执行返回到上一层 EVM。


## 以太坊无状态性 (Ethereum Statelessness)

尽管在撰写本文时（2025 年 6 月），所有以太坊节点都必须计算并维护最新的状态——即我们之前提到的“全局状态（World State）”——以便通过重新执行区块中包含的所有交易来校验每一个新区块的正确性，但目前已有计划在一定程度上摆脱这一限制。

其核心思路是：让一组受限的角色（如搜索者 Searchers 和构建者 Builders）仍然持有完整状态以创建并发布新区块，而所有其他节点可以在不持有状态的情况下，通过密码学手段验证这些区块。这被称为无状态性（Statelessness）。

无状态性在以太坊路线图中仍处于较远的位置，因为它需要对核心协议进行一些关键修改：

**Enshrined proposer-builder separation (ePBS)**

将填充交易以创建区块的工作与向 P2P 网络提议区块的工作分离。 第一项工作由被称为“搜索者（Searchers）”和“构建者（Builders）”的高度专业化实体完成，他们能够创建极其优化的区块；而第二项工作则由以太坊验证者（Validator）节点完成。尽管这一机制尚未在协议层正式确立（即“原生化”），但在主网上已成为现实。事实上，目前绝大多数以太坊区块已经由极少数的大型构建者所构建。

**Verkle trees**

对以太坊当前用于存储状态的数据结构——默克尔-帕特里夏树（Merkle-Patricia Trie）进行更换。 这将大幅缩减验证状态正确性所需的密码学证明（Proof）的大小，并使验证速度比传统的默克尔-帕特里夏树更快。

> [!Note]
> 目前也在测试其他基于哈希的二叉树，以作为维尔克树（Verkle trees）的潜在替代方案。 其核心思路始终如一：即为状态构建一种数据结构，使其能够生成小型证明，并确保这些证明的验证过程既快速又简便。

这两项升级的结合将催生这样一种场景：只有那些拥有强大硬件、并希望创建区块的大型实体才需要存储和访问完整的状态。 在生成新区块的同时，他们还会创建一个密码学证人（Cryptographic Witness）：这是一组最小化的数据集，能够证明新状态是基于区块中所包含的交易正确计算得出的。

所有其他节点（包括验证者节点）仅存储状态根（State Root），即整个状态的哈希值。当它们接收到一个新区块时，只需利用相关的“证人”即可验证其正确性。

这使得运行以太坊节点变得非常轻量化，因为你既不需要存储完整状态，甚至不需要（在 EVM 内部）重新执行所有交易，但你依然能够验证一切是否正确，从而无需信任第三方。你甚至可以在智能手机上运行一个节点……

尽管研究进展神速，但距离在主网上实现无状态性可能仍有数年之久。

## 默克尔-帕特里夏树 (Merkle-Patricia Trie)

目前，以太坊的状态是使用一种非常特殊的数据结构来存储的，称为改进后的默克尔-帕特里夏树（Modified Merkle-Patricia Trie，简称 MPT）。我们在前一节中简要提到了它，但深入理解它的工作原理、设计初衷，以及以太坊如何利用它来存储状态（不仅限于此）是非常重要的，因为同样的逻辑也适用于未来的 Verkle 树。在深入研究 MPT 之前，你需要先了解默克尔树（Merkle Trees），因为它们是构建 MPT 的基石。

### 默克尔树 (Merkle Trees)

默克尔树是一种历史悠久的数据结构，由 Ralph Merkle 于 1988 年发明，最初旨在构建更优的数字签名。当你需要验证某些数据是否存在于数据库中且未被篡改，同时又不想发送整个数据库来证明时，这种结构非常高效。

从一组数据集合开始创建默克尔树非常简单。首先，你需要将数据分成若干个块（Chunks）；接着，将这些数据块两两配对进行哈希运算；然后递归地重复最后这一步骤，直到最终只剩下一个数据块。这个块即代表默克尔根（Merkle Root）：它是用于创建这棵树的所有数据的一种数字指纹。

让我们从头开始构建一个二叉默克尔树（Binary Merkle Tree）——这是默克尔树最简单的形式——以便你更深入地了解它。我们从 8 个数据块开始（你可以把它们想象成 8 个不同的英语单词）。我们使用特定的哈希函数对每个数据块进行哈希处理（正如第 4 章提到的，以太坊使用 Keccak-256 哈希函数），从而得到默克尔树的叶子节点（Leaves），在图 14-2 中分别表示为 hash_1、hash_2 等。接着，我们将每两片叶子连接（Concatenate）在一起并再次哈希，生成 hash_12、hash_34 等。我们将这种连接并哈希的过程再重复两次，直到得到一个最终结果，即我们的默克尔根：hash_12345678。
![Figure 14-2](<./images/figure 14-2.png>)

图 14-2. 二叉默克尔树

现在，你可能会问：为什么我们需要用默克尔树来存储数据？这难道不比直接把每个数据块存进传统数据库更复杂吗？

答案是肯定的，这确实比将数据块存入键值对（Key-Value）数据库或 SQL 数据库要复杂得多。我们之所以使用这类数据结构，唯一的逻辑在于：它们能以极低的成本提供密码学证明（Cryptographic Proof），从而证实某个特定数据块确实存在于整个集合中，且未被篡改。事实上，如果我们使用普通数据库存储数据，当被要求证明我们拥有某个特定数据块时，我们必须公开整个数据集，这样读取者才能确信我们没有撒谎。

让我们用之前的例子来看看这在实践中是如何运作的。假设我们想证明 data_1 包含在数据集中。

朴素方法：提供整个数据集，从 data_1 到 data_8：总共 8 个项。

默克尔树方法：我们只需要提供 hash_2、hash_34 和 hash_5678。接着，任何人都可以自行计算默克尔根，并将其与我们最初计算（并公开分享）的根进行比对。如果两者匹配，你就可以完全确定 data_1 是原始数据集的一部分，如图 14-3 所示。
![Figure 14-3](<./images/figure 14-3.png>)

图 14-3. 用于验证 data_1 包含在树中的默克尔证明

> [!Tip]
> 重构默克尔树（验证证明）可以遵循以下步骤：
> 1. 对 data_1 进行哈希，得到 hash_1。
> 2. 将 hash_1 与提供的 hash_2 拼接并哈希，得到 hash_12。
> 3. 将 hash_12 与提供的 hash_34 拼接并哈希，得到 hash_1234。
> 4. 将 hash_1234 与提供的 hash_5678 拼接并哈希，得到最终的默克尔根（Merkle root）。

请注意，我们仅使用了三个项，而如果不使用默克尔树的朴素方法，则需要使用全部八个项。这还只是一个简单的示例——当数据量巨大时，节省的成本会呈指数级增长。从数学角度来看，默克尔树提供的是 $O(\log n)$ 的复杂度，而朴素方法则是线性复杂度 $O(n)$，如图 14-4 所示。
![Figure 14-4](<./images/figure 14-4.png>)
图 14-4. $O(n)$ 线性复杂度（上方）与 $O(\log n)$ 复杂度（下方）的对比

在以太坊的世界里，这意味着为某个地址的余额、某笔交易的结果，或是某个特定智能合约的字节码提供密码学证明，都会变得更加廉价且容易。

### 比特币中的默克尔树 (Merkle trees in Bitcoin)

比特币开创了在区块链技术中使用默克尔树的先河。事实上，每一个比特币区块都包含了该区块内所有交易的默克尔根（Merkle root），因此，任何一笔交易都无法被修改，否则将导致整个区块头发生变化（这也会破坏该区块的工作量证明 PoW 结果）。

### 以太坊中的默克尔-帕特里夏树 (Merkle-Patricia Trie in Ethereum)

以太坊沿用了同样的理念并将其应用于自身，但针对其特定需求进行了一些修改。默克尔树（Merkle Trees）非常适合处理永不改变的永久性数据，例如比特币的交易记录。然而，以太坊的“状态”是在不断变化的，因此我们需要对默克尔树进行调整，使其在允许频繁更改底层数据的同时，依然能保持其原有的实用特性。

这就是**默克尔-帕特里夏树**（Merkle-Patricia Trie，简称 MPT）登场的时刻。这个名字结合了默克尔树、Patricia（一种高效检索字母数字编码信息的算法）以及 trie（源自检索“retrieval”一词，提醒我们这种结构的优化目标）三个概念。

本质上，MPT 是经过改良的默克尔树，每个节点拥有 16 个子节点。它们非常适合处理像以太坊状态这样拥有大量“键值对（Key-Value）”项的数据（其中“键”是地址，“值”是对应地址的账户信息，如余额、Nonce 以及可能存在的代码）。这是因为键（Key）本身就被编码在通往树中正确位置所必须遵循的路径里。

假设我们要存储以下键值项： 
```
car → Schumacher
```
“car”的十六进制编码为 `0x636172`。因此，你需要从默克尔根节点开始，先选择第 6 个子节点，接着向下选择第 3 个子节点，重复这一过程，直到到达最终位置，在那里你可以读取到与该键相关联的值——在本例中就是“Schumacher”，如图 14-5 所示。

![Figure 14-5](<./images/figure 14-5.png>)

图 14-5. 键值项 car → Schumacher 在默克尔-帕特里夏树中的编码方式

具体而言，以太坊使用了四种默克尔-帕特里夏树（MPT）：

**状态树 (State Trie)**

用于存储以太坊的全部全局状态。

**交易树 (Transaction Trie)**

用于存储区块中包含的所有交易。

**收据树 (Receipt Trie)**

用于存储该区块内所有交易的执行结果（收据）。

**存储树 (Storage Trie)**

用于存储智能合约的内部数据。

每个以太坊区块头 (Block Header) 都包含了状态树、交易树和收据树的默克尔根；而每个账户 (Account)（包含在状态树中）则存储着它自己专属的存储树默克尔根。


## 深入解析 EVM 组件 (A Deep Dive into the Components of the EVM)
在本节中，我们将详细探讨 EVM 每个组件的工作原理。最后，我们将通过一个真实案例来观察各组件是如何协同工作的。

### 栈 (Stack)

栈是一个非常简单的数据结构，遵循后进先出 (LIFO) 的原则来执行操作。在栈中，每个项都是一个 32 字节 的对象。它最多可以同时存放 1,024 个 项。

EVM 可以通过各种操作码将项“推入 (Push)”或“弹出 (Pop)”栈空间，并能灵活调整其内部元素的顺序，如图 14-6 所示。

![Figure 14-6](<./images/figure 14-6.png>)

图 14-6. 遵循后进先出 (LIFO) 操作顺序的 EVM 栈

### 内存 (Memory)
EVM 内存是一个按字节寻址 (Byte-addressable) 的数据结构：本质上是一个非常长的字节数组。实际上，内存中的每一个字节都可以使用一个 32 字节（256 位）的键（索引）来访问，这意味着它的理论容量上限可达 $2^{256}$ 字节。内存是易失性 (Volatile) 的——也就是说，它在执行结束后会被删除——并且在初始状态下总是被置为 0。虽然可以从内存中读取或向其中写入单个字节，但大多数操作通常涉及读取或写入更大的数据块，通常是 32 字节 的块，如图 14-7 所示。

![Figure 14-7](<./images/figure 14-7.png>)

> [!Note]
> 从技术角度讲，你无法从 EVM 内存中直接读取单个字节。你只能读取一整个 32 字节的“字”（Word）。为了达到读取单个字节的效果，EVM 需要先加载包含该字节的整个字，然后通过位运算对其进行“裁剪”，从而仅返回所选的那个字节。

### 存储 (Storage)

EVM 存储是一个键值对（Key-Value）数据结构，其中的键（通常称为插槽 Slots）和值均为 32 字节长。这是每个智能合约的持久化内存：所有保存在其中的数值都会在不同的交易和区块之间无限期保留。每个智能合约只能访问和修改属于自己的存储空间。如果你尝试访问一个尚未存入任何数值的插槽，它将始终返回 0 而不会抛出任何错误。图 14-8 展示了两个合约存储结构的简化示意图。
![Figure 14-8](<./images/figure 14-8.png>)

图 14-8. EVM 存储是一种具有键值对结构的永久性内存

此外，还有通过 EIP-1153 引入的瞬态存储 (Transient Storage)。它的行为方式与普通存储完全一致，唯一的区别在于它会在交易执行结束后被彻底丢弃。正因如此，它的使用成本比普通存储要廉价得多。

### 调用数据 (Calldata)

调用数据是一个不可变（Immutable）的数据结构，它始终包含作为输入发送至下一个调用帧 (Call Frame)（即沙盒化的 EVM 环境）的字节。例如，在创建合约的交易中，calldata 包含即将部署的合约字节码。它也可以是空的，比如在简单的 ETH 转账交易中。

## 让我们通过一个具体案例来整合所有知识
你正在执行一笔作用于合约 A 的交易，并且拥有以下 EVM 字节码：`60425F525F3560AB145F515500`。

同时，你还拥有如下初始调用数据（Calldata）：
```
00000000000000000000000000000000000000000000000000000000000000ab
```
让我们以人类可读的格式来表示这段 EVM 字节码：
```
[00]            PUSH1            42
[02]            PUSH0
[03]            MSTORE
[04]            PUSH0
[05]            CALLDATALOAD
[06]            PUSH1            AB
[08]            EQ
[09]            PUSH0
[0a]            MLOAD
[0b]            SSTORE
[0c]            STOP
```

> [!Note]
> 每个 EVM 操作码（Opcode）都由一个唯一的 1 字节数值标识（范围从 0x00 到 0xFF）。例如，0x60 是 PUSH1 操作码，0x5F 是 PUSH0，依此类推。如需查看所有操作码及其十六进制表示的完整列表，请参考 [EVM Codes 网站](https://www.evm.codes/)。

让我们看看 EVM 如何执行这些操作码，以及它是如何操纵栈、内存和存储的。图 14-9 展示了 EVM 的初始状态。

![Figure 14-9](<./images/figure 14-9.png>)

图 14-9. EVM 初始状态

第一个操作码将 0x42 推入栈中（图 14-10）。请注意，所有的 PUSH 操作码都会从字节码中紧随其后的可用字节里提取（待推入的）数据。

![Figure 14-10](<./images/figure 14-10.png>)

图 14-10. 执行 PUSH1 0x42 后的 EVM

接着，PUSH0 将 `0x00` 推入栈中（图 14-11）。

![Figure 14-11](<./images/figure 14-11.png>)

图 14-11. 执行 PUSH0 后的 EVM

MSTORE 从栈中弹出两个项，将第一个项解释为偏移量（以字节为单位），第二个项解释为要写入内存的值，并从该偏移量开始写入。请注意，在内存中的字节 0x42 之前有很多前导零（31 个字节为零）。这是正确的，因为栈中的每个值都是 32 字节 的。大多数时候，我们在书写时可以忽略前导零（在图 14-12 中，你可以看到项 0x42），但你应该始终记住它们是 32 字节的值。

![Figure 14-12](<./images/figure 14-12.png>)

图 14-12. 执行 MSTORE 后的 EVM

随后，再次执行 PUSH0，将 0x00 推入栈中（图 14-13）。

![Figure 14-13](<./images/figure 14-13.png>)

图 14-13. 执行 PUSH0 后的 EVM

CALLDATALOAD 从栈中取出一个元素作为偏移量，返回调用数据（Calldata）中从该偏移量开始的 32 字节 数值，并将其推入栈中。在本例中，它返回了 0xab（注意，我们可以忽略所有不具实际意义的前导零），如图 14-14 所示。

![Figure 14-14](<./images/figure 14-14.png>)

图 14-14. 执行 CALLDATALOAD 后的 EVM

PUSH1 将 0xab 推入栈中（图 14-15）。

![Figure 14-15](<./images/figure 14-15.png>)

图 14-15. 执行 PUSH1 0xab 后的 EVM

EQ 从栈中弹出两个项并进行比较：如果相等则返回 1，否则返回 0。在此示例中，由于两个数值相等，它返回了 0x01，如图 14-16 所示。

![Figure 14-16](<./images/figure 14-16.png>)

图 14-16. 执行 EQ 后的 EVM

再次执行 PUSH0，将 0x00 推入栈中（图 14-17）。

![Figure 14-17](<./images/figure 14-17.png>)

图 14-17. 执行 PUSH0 后的 EVM

MLOAD 从栈中取出一个元素作为偏移量，读取内存中从该偏移量开始的 32 字节数据，然后将结果推入栈中（图 14-18）。

![Figure 14-18](<./images/figure 14-18.png>)

图 14-18. 执行 MLOAD 后的 EVM

现在，SSTORE 从栈中弹出两个项，将第一个项解释为插槽 (Slot)，第二个项解释为要存入该合约存储（对应插槽编号）的数值，如图 14-19 所示。

![Figure 14-19](<./images/figure 14-19.png>)

图 14-19. 执行 SSTORE 后的 EVM

最后，执行 STOP 操作码使执行挂起，EVM 成功返回，如图 14-20 所示。

![Figure 14-20](<./images/figure 14-20.png>)

图 14-20. 执行 STOP 后的 EVM

> [!Tip]
> 在前面的示例中，我们使用了操作码 PUSH0。需要注意的是，并非所有兼容 EVM 的区块链都集成了这个操作码，因此在部署跨链合约时请务必留意。[EVM Diff](https://www.evmdiff.com/) 是一个非常酷的网站，展示了各大兼容 EVM 的链之间所有这些微妙的差异。

## 将 Solidity 编译为 EVM 字节码 (Compiling Solidity to EVM Bytecode)

我们已在第 7 章探讨过 Solidity。现在，我们将了解它是如何被编译成可供 EVM 解释执行的 EVM 字节码的。

将 Solidity 源文件编译为 EVM 字节码可以通过多种方法实现。在第 2 章中，我们使用了在线的 Remix 编译器。而在本章中，我们将使用命令行下的 solc 可执行程序。如需在计算机上安装 Solidity，请[按照步骤操作](https://oreil.ly/JW--z)。

运行以下命令可查看选项列表：
```
$ solc --help
```
通过 --opcodes 命令行选项，可以轻松生成 Solidity 源文件的原始操作码流。虽然这种操作码流会省略某些信息（使用 --asm 选项可生成完整信息），但对于本次讨论而言已经足够。例如，编译一个名为 Example.sol 的示例 Solidity 文件，并将操作码输出到名为 BytecodeDir 的目录中，可以使用以下命令：
```
$ solc -o BytecodeDir --opcodes Example.sol
```
你也可以使用 --asm 来产生更具可读性的输出：
```
$ solc -o BytecodeDir --asm Example.sol
```
以下命令将为我们的示例程序生成字节码二进制文件：
```
$ solc -o BytecodeDir --bin Example.sol
```
生成的输出操作码文件将取决于 Solidity 源文件中包含的具体合约。我们的简单示例文件 Example.sol 仅包含一个名为 Example 的合约：
```Solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.27;

contract Example {
  address contractOwner;
  
  function test() public {
    contractOwner = msg.sender;
  }
}
```
如你所见，该合约所做的全部工作就是维护一个持久化的状态变量，其数值被设置为最后一个运行该合约的账户地址。

如果你查看 BytecodeDir 目录，你会看到操作码文件 Example.opcode，它包含了该示例合约的 EVM 操作码指令。在文本编辑器中打开 Example.opcode 文件，将显示以下内容：
```
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xE JUMPI PUSH0 PUSH0 REVERT JUMPDEST POP PUSH1 0xA9 DUP1 PUSH1 0x1A PUSH0 CODECOPY PUSH0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH1 0xE JUMPI PUSH0 PUSH0 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH1 0x26 JUMPI PUSH0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH4 0xF8A8FD6D EQ PUSH1 0x2A JUMPI JUMPDEST PUSH0 PUSH0 REVERT JUMPDEST PUSH1 0x30 PUSH1 0x32 JUMP JUMPDEST STOP JUMPDEST CALLER PUSH0 PUSH0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH200xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 JUMPI 0xBB RETURNDATACOPY SWAP15 CALLVALUE 0xB3 0xB1 SMOD BLOBHASH STATICCALL MCOPY PUSH10 0x856E7132D8FEED4D83B6 0xB2 0xBE PUSH30 0x8B43532C818BFD64736F6C634300081B0033000000000000000000000000
```
使用 --asm 选项编译该示例会在我们的 BytecodeDir 目录下生成一个名为 Example.evm 的文件。该文件包含了对 EVM 字节码指令稍高层次的描述，并附带了一些非常有用的注释：
```
/* "Example.sol":61:171  contract Example {... */
  mstore(0x40, 0x80)
  callvalue
  dup1
  iszero
  tag_1
  jumpi
  revert(0x00, 0x00)
tag_1:
  pop
  dataSize(sub_0)
  dup1
  dataOffset(sub_0)
  0x00
  codecopy
  0x00
  return
stop

sub_0: assembly {
        /* "Example.sol":61:171  contract Example {... */
      mstore(0x40, 0x80)
      callvalue
      dup1
      iszero
      tag_1
      jumpi
      revert(0x00, 0x00)
    tag_1:
      pop
      jumpi(tag_2, lt(calldatasize, 0x04))
      shr(0xe0, calldataload(0x00))
      dup1
      0xf8a8fd6d
      eq
      tag_3
      jumpi
    tag_2:
      revert(0x00, 0x00)
        /* "Example.sol":109:169  function test() public {... */
    tag_3:
      tag_4
      tag_5
      jump    // in
    tag_4:
      stop
    tag_5:
        /* "Example.sol":154:164  msg.sender */
      caller
        /* "Example.sol":138:151  contractOwner */
      0x00
      0x00
        /* "Example.sol":138:164  contractOwner = msg.sender */
      0x0100
      exp
      dup2
      sload
      dup2
      0xffffffffffffffffffffffffffffffffffffffff
      mul
      not
      and
      swap1
      dup4
      0xffffffffffffffffffffffffffffffffffffffff
      and
      mul
      or
      swap1
      sstore
      pop
        /* "Example.sol":109:169  function test() public {... */
      jump    // out
    auxdata: 0xa264697066735822122057bb3e9e34b3b10749fa5e69856e7132d8feed4d83b6b2be7d8b43532c818bfd64736f6c634300081b0033
}
```
`--bin` 选项会生成机器可读的十六进制字节码。
```
6080604052348015600e575f5ffd5b5060a980601a5f395ff3fe6080604052348015600e575f5ffd5b50600436106026575f3560e01c8063f8a8fd6d14602a575b5f5ffd5b60306032565b005b335f5f6101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555056fea264697066735822122057bb3e9e34b3b10749fa5e69856e7132d8feed4d83b6b2be7d8b43532c818bfd64736f6c634300081b0033
```

你可以利用“EVM 指令集（字节码操作）”中提供的操作码列表，深入研究这里发生的每一个细节。不过，这是一项相当艰巨的任务，所以让我们先从分析前四条指令开始：
```
PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE
```
首先，我们看到 PUSH1 后面跟着一个值为 0x80 的原始字节。这条 EVM 指令会提取程序代码中紧随操作码之后的一个字节（作为字面量值）并将其推入栈中。栈内最高支持推入 32 字节大小的数值，例如：
```
PUSH32 0x436f6e67726174756c6174696f6e732120536f6f6e20746f206d617374657221
```
在 example.opcode 中的第二个 PUSH1 操作码将 0x40 存储到栈顶（同时将已存在的 0x80 向下挤一个槽位）。

接下来是 MSTORE，这是一个内存存储操作，用于将数值保存到 EVM 的内存中。它需要两个参数，并且与大多数 EVM 操作一样，它从栈中获取这些参数。对于每个参数，栈都会执行“弹出（Pop）”操作——即取出栈顶的值，并将栈中的所有其他值向上移动一个位置。MSTORE 的第一个参数是数值在内存中存储的目标地址（按字计）。在这个程序中，由于栈顶是 0x40，它被移出栈并作为内存地址使用。第二个参数是要保存的值，即此处的 0x80。执行 MSTORE 操作后，我们的栈再次变为空，但在内存地址 0x40 处拥有了数值 0x80（十进制为 128）。

下一条操作码是 CALLVALUE，这是一个环境类操作码，它会将发起本次执行的消息调用所携带的以太币数量（以 wei 为单位）推入栈顶。

我们可以继续以这种方式逐步剖析程序，直到完全理解这段代码引起的底层状态变化，但这在现阶段对我们帮助不大。我们将在本章稍后部分再回过头来讨论它。

## 合约部署代码 (Contract Deployment Code)
在以太坊平台上创建和部署新合约时，所使用的代码与合约自身的代码之间存在一个重要但微妙的区别。要创建一个新合约，需要发送一笔特殊的交易，其 to 字段为空（null），而 data 字段被设置为合约的初始化代码 (Initiation Code)。

当处理这种合约创建交易时，新合约账户中最终存储的代码并不是交易 data 字段中的那段代码。相反，系统会实例化一个 EVM，将交易 data 字段中的代码加载到其程序代码只读存储器（ROM）中，然后将该部署代码执行后的输出结果作为新合约账户的正式代码。这样设计是为了让新合约在部署时能利用当时的以太坊世界状态进行程序化初始化，例如设置合约存储的初始值、发送以太币，甚至创建更多的新合约。

当进行离线编译时（例如在命令行使用 solc），你可以获得部署字节码 (Deployment Bytecode) 或 运行时字节码 (Runtime Bytecode)。部署字节码涵盖了新合约账户初始化的方方面面，既包括交易调用该新合约时实际执行的字节码（即运行时字节码），也包括根据合约构造函数进行初始化的代码。相比之下，运行时字节码恰恰是新合约被调用时所执行的完整字节码，且仅此而已；它并不包含部署期间初始化合约所需的字节码。

让我们以之前章节创建的简单 Faucet.sol 合约为例：

```Solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.27;

contract Faucet {
  // Give out ether to anyone who asks
  function withdraw(uint256 _withdrawAmount, address payable _to) public {
    // Limit withdrawal amount
    require(_withdrawAmount <= 1000000000000);
    // Send the amount to the address that requested it
    _to.transfer(_withdrawAmount);
  }
  
  // Function to receive Ether. msg.data must be empty
  receive() external payable {}
  
  // Fallback function is called when msg.data is not empty
  fallback() external payable {}
}
```
若要获取部署字节码，我们会运行 `solc --bin Faucet.sol`。如果相反，我们只需要运行时字节码，则运行 `solc --bin-runtime Faucet.sol`。如果你对比这两个命令的输出结果，就会发现运行时字节码是部署字节码的一个子集。换句话说，运行时字节码完全包含在部署字节码之中。


### CREATE 与 CREATE2：链上合约部署的两种方式
CREATE 和 CREATE2 是仅有的两个允许你在链上部署新合约的操作码。它们之间的主要区别在于新创建合约的生成地址。

使用 CREATE 时，目标地址的计算公式如下：
```
address = keccak256[rlp(sender_address ++ sender_nonce)][12:]
```
它是发送者地址及其随机数（Nonce）进行 RLP 编码后，取 Keccak-256 哈希值的最右侧 20 个字节。

CREATE2 是在 2019 年的君士坦丁堡（Constantinople）硬分叉期间引入的，旨在让开发者创建新合约时，生成的地址不依赖于发送者的状态（即 Nonce）。实际上，它的行为与 CREATE 完全相同，但目标地址的计算方式如下：
```
address = keccak256(0xff ++ sender_address ++ salt ++ keccak256(init_code))[12:]
```
其中：
* init_code 是新合约的部署字节码。
* salt（盐） 是一个由开发者指定的 32 字节数值（从栈中获取）。



## 反汇编字节码 (Disassembling the Bytecode)

反汇编（Disassembling）EVM 字节码是理解高级语言 Solidity 在 EVM 中如何运作的绝佳方式。你可以使用以下几种反汇编工具来完成这项工作：


* [Ethersplay](https://oreil.ly/xW6fH)：这是一个针对 Binary Ninja（一款商业反汇编器）的 EVM 插件。顺便提一下，要使用该插件，你需要购买完整版的 Binary Ninja 应用程序。
* [Heimdall](https://oreil.ly/klTJ3)：这是一个先进的 EVM 智能合约工具包，专门用于字节码分析以及从未经验证的合约中提取信息。

在本节中，我们将使用 Heimdall 来生成图 14-21。在获取 Faucet.sol 的运行时字节码后，我们可以将其输入 Heimdall，以查看 EVM 指令的结构。

![Figure 14-21](<./images/figure 14-21.png>)

图 14-21. 反汇编 Faucet 运行时字节码

### 安装 Heimdall

首先，你需要确保计算机上已安装 Rust 环境。如果尚未安装，请运行以下命令：
```
$ curl https://sh.rustup.rs -sSf | sh
```
接着，依次运行以下两条命令：
```
$ curl -L http://get.heimdall.rs | bash
$ bifrost
```
现在，你应该已经正确安装了 Heimdall。可以通过运行以下命令进行验证：
```
$ heimdall --version
```
你应该会看到类似如下的输出：
```
$ heimdall --version
heimdall 0.8.4
```

> [!Note]
> 有关如何安装 Heimdall 的最新信息，请参阅其 [GitHub 仓库](https://oreil.ly/klTJ3) 中的官方文档。

### 使用 Heimdall 反汇编字节码
现在我们已经正确安装了 Heimdall，准备生成你在图 14-21 中看到的那个图表。以 Faucet.sol 合约的运行时字节码为起点，你可以运行以下命令：
```
$ heimdall cfg <在此插入运行时字节码>
```
以下是该命令执行时的示例：
```
$ heimdall cfg 608060405260043610610…
```
现在，你应该能看到一个名为 output 的新文件夹。进入该文件夹，再进入生成的名为 local 的文件夹。在这里，你会找到 cfg.dot 文件：
```
$ cd output
$ cd local
$ ls # 此时你应该能看到该文件
```
由于这是一个 .dot 文件，我们需要一个专门的程序来正确打开它。在本例中，我们将使用一个网站，它可以让我们粘贴 .dot 文件的内容并为我们生成图表。

首先，你需要复制 .dot 文件的内容：
```
$ cat cfg.dot
```
此命令会将文件的全部内容打印到屏幕上；复制它，打开一个 [控制流图 (CFG) 在线生成器](https://oreil.ly/swOsK)，并将其粘贴到网页的左侧，如图 14-22 所示。

![Figure 14-22](<./images/figure 14-22.png>)

图 14-22. Faucet.sol 合约的控制流图 (CFG)

图 14-23 展示了 Faucet.sol 合约的初始字节码。如你所见，它以与之前的 Example.sol 合约相同的模式开头：PUSH1 0x80 PUSH1 0x40 MSTORE。

![Figure 14-23](<./images/figure 14-23.png>)

图 14-23. CFG 图表第一部分的放大视图

当你向一个兼容 ABI 的智能合约（你可以假设所有合约都是如此）发送交易时，交易首先与该合约的分发器 (Dispatcher) 交互。分发器读取交易的 data 字段，并将相关部分发送给相应的函数。我们可以在反汇编后的 Faucet.sol 运行时字节码开头看到一个分发器的例子。在熟悉的 MSTORE 指令之后，我们看到了以下指令：
```
PUSH1 0x04
CALLDATASIZE
LT
PUSH2 0x0020
JUMPI
```

正如我们所见，PUSH1 0x04 将 0x04 置于原本为空的栈顶。CALLDATASIZE 获取随交易发送的数据（即 calldata）的字节大小，并将该数字推入栈中。执行这些操作后，栈的状态如下：
```
Stack
<来自交易的 calldata 长度>
0x4
```
下一条指令是 LT，即“小于 (less than)”的缩写。LT 指令检查栈顶项是否小于栈中的下一项。在我们的案例中，它检查 CALLDATASIZE 的结果是否小于 4 字节。

为什么 EVM 要检查交易的 calldata 是否至少有 4 字节？这是由于函数标识符 (Function Identifiers) 的工作机制。每个 Solidity 函数都由其 Keccak-256 哈希值的前 4 个字节来标识。通过将函数名称及其所有参数放入 keccak256 哈希函数，我们可以推导出其函数标识符。在我们的案例中：
```
keccak256("withdraw(uint256,address)") = 0x00f714ce...
```
因此，withdraw(uint256,address) 函数的标识符是 0x00f714ce。函数标识符始终为 4 字节长，因此如果发送到合约的交易数据字段总长度小于 4 字节，那么除非定义了回退函数（fallback function），否则该交易不可能与任何函数通信。因为我们在 Faucet.sol 中实现了这样一个回退函数，所以当 calldata 长度小于 4 字节时，EVM 会跳入该函数。

LT 从栈中弹出前两个值，如果交易的数据字段小于 4 字节，则向栈推入 1；否则推入 0。在我们的示例中，假设交易的数据字段小于 4 字节。

PUSH2 0x0020 指令将字节 0x0020 推入栈中。执行此指令后，栈的状态如下：
```
Stack
0x0020
0x1
```
下一条指令是 JUMPI，代表“如果...则跳转 (jump if)”。其工作方式如下：
```
jumpi(label, cond) // 如果 "cond" 为真，则跳转到 "label"
```
在我们的案例中，label 是 0x0020，这是回退函数在智能合约中的位置。cond 参数是 1，即早前 LT 指令的结果。用一句话概括这个序列：如果交易数据少于 4 字节，合约将跳转到回退函数。

在 0x20 处，经过两条 JUMPDEST 指令后，紧接着只有一条 STOP 指令。这是因为虽然我们声明了回退函数，但将其保持为空。正如你在图 14-24 中看到的，如果我们没有实现回退函数，合约将会抛出异常。

![Figure 14-24](<./images/figure 14-24.png>)

图 14-24. 导向回退（fallback）函数的 JUMPI 指令

> [!Note]
> Heimdall 表示字节码时从偏移量 0x01 开始，尽管 EVM 实际上是从偏移量 0x00 开始解释的。在前面的示例中，JUMPI 指令告诉 EVM 如果条件为真则跳转到偏移量 0x20，但在图中，偏移量 0x20 被表示为 0x21。根据经验，你只需将 EVM 的每个偏移量加 1，即可在图中找到对应位置。

让我们检查分发器的中心代码块。假设我们收到的调用数据（calldata）长度大于 4 字节，JUMPI 指令将不会跳转到回退函数。相反，代码执行将进入以下指令：
```
PUSH0 0x0
CALLDATALOAD
PUSH1 0xe0
SHR
DUP1
PUSH3 0xf714ce
EQ
PUSH2 0X23
JUMPI
```
PUSH0 将 0 推入栈中（此时栈内再次只有这一个元素）。CALLDATALOAD 接收一个索引作为参数，并从该索引处开始读取智能合约接收到的 32 字节调用数据（calldata），如下所示：
```
calldataload(p) // 从字节位置 p 开始加载 32 字节的 calldata
```
由于传递给它的索引是来自 PUSH0 命令的 0，因此 CALLDATALOAD 从字节 0 开始读取 32 字节的 calldata，并将其推入栈顶（在弹出原始的 0x0 之后）。执行 PUSH1 0xe0 指令后，栈的状态如下：
```
栈 (Stack)
0xe0
<从字节 0 开始的 32 字节 calldata>
```
SHR 指令对栈上的 32 字节元素执行 逻辑右移 (Logical Right Shift)，位移量为 0xe0 位（即 224 位，28 字节）。通过将 calldata 向右移动 28 字节，它成功隔离了 calldata 的前 4 个字节。事实上，在执行右移时，移动到第一位之前的所有位都会被丢弃，而新腾出的位会被设为 0。请记住，calldata 的前 4 个字节代表了我们想要触发的函数标识符。

### 逻辑位移示例 (Logical Bit Shift Example)

通过一个例子可以更好地理解这一点。假设当前的栈状态如下：
```
栈 (Stack)
0x1234567890 // 一个 5 字节的元素
```
我们只想获取前两个字节（即 0x1234）。要仅使用 EVM 操作码实现这一点，我们可以执行：
```
PUSH1 0x18 // 0x18 在十六进制中代表数字 24；24 位 = 3 字节
SHR
```
实际上，通过将栈顶项向右移动 3 个字节（请记住，此处每 2 个十六进制数字代表 1 个字节），我们得到了如下项：
```
0x0000001234 | 567890（此处的分割线仅为演示）
```
567890 部分被丢弃，剩下的内容为：
```
Stack
0x1234
```
所有前导零都可以忽略，因为它们没有实际意义。

---
当前的新栈状态为
```
Stack
<数据中发送的函数标识符>
```
下一条指令是 DUP1，它会复制栈顶的第一项。此时栈的状态如下：
```
Stack
<数据中发送的函数标识符>
<数据中发送的函数标识符>
```
现在执行 PUSH3 指令，随后跟着要推送的数据 0xf714ce。该操作码只需将（推送）数据压入栈中。执行完该操作码后，栈的状态如下：
```
Stack
0xf714ce
<数据中发送的函数标识符>
<数据中发送的函数标识符>
```
现在，这个 0xf714ce 看起来是不是很眼熟？还记得我们 withdraw(uint256,address) 函数的标识符是多少吗？它是 0x00f714ce…。请注意，它们是同一个数字，因为前导零可以忽略。

下一条指令 EQ 会弹出栈顶的前两项并进行比较。这就是分发器履行其核心职责的时刻：它通过比对交易中 msg.data 字段发送的函数标识符，来确认其是否与 withdraw(uint256,address) 相匹配。如果两者相等，EQ 向栈中推入 1，这最终将被用于跳转到 withdraw 函数的逻辑块；否则，EQ 向栈中推入 0。

假设发送到我们合约的交易确实以 withdraw(uint256,address) 的函数标识符开头，此时我们的栈状态变为：
```
Stack
1
<数据中发送的函数标识符>（已知为 0x00f714ce）
```
接下来执行 PUSH2 0x23，这是 withdraw(uint256,address) 函数在合约代码中所处的地址（偏移量）。执行此指令后，栈的状态如下：
```
Stack
0x23
1
<msg.data 中发送的函数标识符>
```
紧接着是 JUMPI 指令，它再次接受栈顶的两个元素作为参数。在这种情况下，我们执行的是 JUMPI(0x23, 1)，这告诉 EVM 执行跳转到 withdraw(uint256,address) 函数所在的位置，随后该函数的代码逻辑便开始执行。

## 图灵完备性与 Gas (Turing Completeness and Gas)

正如我们已经提及的，简单来说，如果一个系统或编程语言能够运行任何程序，它就是图灵完备 (Turing complete) 的。然而，这种能力带有一个非常重要的限制：某些程序运行起来没完没了。其中一个关键点在于，我们无法仅通过观察程序就判断它是否会永远运行下去。我们必须实际执行该程序并等待它运行结束才能得出结论。当然，如果它真的会永远运行，我们就得等上一辈子才能知道结果。这就是所谓的停机问题 (Halting Problem)，如果不加以解决，它将给以太坊带来巨大的隐患。

由于停机问题的存在，以太坊“世界计算机”面临着被要求执行一个永不停止的程序的风险。这可能是由于代码疏忽，也可能是恶意攻击。我们曾描述过以太坊就像一台没有任何调度器的单线程机器，因此如果它陷入死循环，就意味着整个以太坊网络将变得瘫痪，无法使用。

不过，有了 Gas，我们就有了一个解决方案：如果程序在执行完预设的最大计算量后仍未结束，EVM 就会强制停止该程序的执行。这使得 EVM 成为一个准图灵完备 (Quasi-Turing-complete) 的机器：它可以运行你输入的任何程序，但前提是该程序必须在特定的计算量限制内终止。在以太坊中，这个限制并不是固定不变的——你可以通过付费来增加它，直到达到一个上限（称为区块 Gas 限制），而且所有人都可以达成共识随时间推移提高这个上限。尽管如此，在任何特定时刻，限制总是存在的，执行过程中消耗过多 Gas 的交易会被强行中止。

在接下来的章节中，我们将详细研究 Gas 及其运作机制。

### 什么是 Gas？
Gas 是以太坊中用于衡量在区块链上执行操作所需的计算和存储资源的单位。与比特币仅根据交易的字节大小（KB）来计算手续费不同，以太坊必须对交易和智能合约代码执行中的每一个计算步骤进行审计。

交易或合约执行的每项操作都有固定的 Gas 成本。根据以太坊《黄皮书》（Yellow Paper）的规定，一些示例如下：
* 两个数字相加：消耗 3 Gas
* 计算 Keccak-256 哈希：消耗 30 Gas + 每 256 位被哈希数据额外增加 6 Gas
* 发送一笔交易：消耗 21,000 Gas

Gas 是以太坊的核心组成部分，承担着双重角色：它是（波动剧烈的）以太币价格与验证者工作报酬之间的缓冲垫，同时也是防御 DoS（拒绝服务）攻击的防线。为了防止网络中出现意外或恶意的死循环或其他计算浪费，每笔交易的发起者都被要求为其愿意支付的计算量设置一个上限。因此，Gas 系统通过让攻击者为其消耗的计算、带宽和存储资源支付相应比例的费用，从经济上遏制了发送“垃圾邮件”交易的行为。

### 执行过程中的 Gas 计费(Gas Accounting During Execution)
当需要 EVM 来完成一笔交易时，首先会为其分配一笔 Gas 供应量，其数额等于交易中指定的 Gas 限制 (Gas Limit)。执行的每一个操作码（Opcode）都有相应的 Gas 成本，因此随着 EVM 逐步执行程序，Gas 供应量会不断减少。在执行每项操作之前，EVM 都会检查是否有足够的 Gas 来支付该操作的执行费用。如果 Gas 不足，执行将被中止，交易将被回滚。

如果 EVM 成功执行完毕且没有耗尽 Gas，所消耗的 Gas 成本将作为交易手续费支付给验证者，并根据交易中指定的 Gas 价格（Gas Price）转换为以太币：

$$validator\ fee = gas\ cost \times gas\ price$$

Gas 供应量中剩余的 Gas 将退还给发送者，同样根据交易中的 Gas 价格转换为以太币：

$$remaining\ gas = gas\ limit – gas\ cost$$

$$refunded\ ether = remaining\ gas \times gas\ price$$

如果交易在执行过程中“耗尽了 Gas”（Out of Gas），操作将立即终止并引发 OOG 异常。交易会被回滚，所有对状态的更改都会恢复原状。尽管交易执行失败，发送者仍将被收取交易费，因为验证者到那一刻为止已经完成了相应的计算工作，必须为此获得补偿。

#### Gas 计费的考量 (Gas Accounting Considerations)

EVM 各项操作的相对 Gas 成本经过了深思熟虑的设计，旨在最大程度地保护以太坊区块链免受攻击。计算密集型操作的 Gas 成本更高。例如，执行 SHA3（现称 KECCAK256）函数的成本（30 Gas）是 ADD（加法）操作（3 Gas）的 10 倍。更重要的是，某些操作（如 EXP 指数运算）需要根据操作数的大小支付额外费用。此外，使用 EVM 内存以及在合约的链上存储中存入数据也都需要支付 Gas 费用。

Gas 成本与现实世界资源消耗相匹配的重要性在 2016 年得到了证实。当时，一名攻击者发现并利用了成本失配的漏洞。该攻击生成的交易计算极其复杂，导致以太坊主网几乎陷入瘫痪。这种失配最终通过一次代号为“橘色哨声”（Tangerine Whistle）的硬分叉得到了解决，该分叉对各项操作的相对 Gas 成本进行了微调。

#### 以太坊 Gas 计费的未来 (Gas Accounting in the Future of Ethereum)

Gas 计量过去是、现在依然是以太坊处理全网交易负载的核心机制。至关重要的一点是，我们要理解 Gas 成本是引导特定行为的关键激励手段。在未来，不同操作码（Opcodes）所消耗的 Gas 量可能会发生变化。

例如，在引入 EIP-4844“分片 Blob 交易”的坎昆（Cancun）升级之前，所有的 Layer 2（L2）方案都将数据作为交易的 calldata 发布到以太坊上。这些数据会永久存储在所有以太坊节点中。现在，由于 L2 有了通过 Blob 交易发布数据的更优方式，未来 calldata 的成本可能会变得比现在更高，以此鼓励 Rollup 方案使用 Blob 交易，并减轻节点永久存储这些数据的负担。

#### Gas 成本与 Gas 价格 (Gas Cost versus Gas Price)

虽然 Gas 成本 (Gas Cost) 是衡量交易在 EVM 中消耗的计算和存储资源的指标，但 Gas 本身也有一个以太币（Ether）计量的价格 (Price)。在进行交易时，发送者需指定他们愿意为每单位 Gas 支付的 Gas 价格（以以太币计），从而让市场决定以太币价格与计算操作成本（以 Gas 计量）之间的关系：

$$transaction\ fee = total\ gas\ used \times gas\ price\ paid\ (in\ ether)$$

在构建新区块时，以太坊网络上的验证者可以从待处理交易中进行选择，优先挑选那些愿意支付更高 Gas 价格的交易。因此，提供更高的 Gas 价格会激励验证者优先处理你的交易，使其更快得到确认。

在实践中，交易发送者会设置一个大于或等于预期消耗量的 Gas 限制 (Gas Limit)。如果设置的 Gas 限制高于实际消耗的 Gas 量，发送者将收到多余部分的退款，因为验证者仅根据他们实际完成的工作获得报酬。

明确 Gas 成本与 Gas 价格之间的区别至关重要。简要回顾如下：
* Gas 成本 (Gas Cost)：执行特定操作所需的 Gas 单位数量。
* Gas 价格 (Gas Price)：当你向以太坊网络发送交易时，你愿意为每单位 Gas 支付的以太币金额。

> [!Tip]
> 尽管 Gas 有价格，但它不能被“拥有”或“持有”。Gas 仅存在于 EVM 内部，作为计算工作量的计数。系统向发送者收取以太币形式的手续费，在 EVM 计费时将其转换为 Gas，最后再转回以太币作为支付给验证者的手续费。

#### 负 Gas 成本 (Negative Gas Costs)

以太坊通过退还合约执行期间使用的部分 Gas，鼓励开发者删除不再使用的存储变量。在 EVM 中，只有一种操作具有负 Gas 成本：将存储地址从非零值更改为零值（即 `SSTORE[x] = 0`）会获得 Gas 退款。退还的 Gas 金额并非固定，而是取决于该存储插槽在操作前后的具体状态。为了防止退款机制被滥用，单笔交易的最大退款额度被限制为总 Gas 消耗量的五分之一（向下取整）。

在过去，还有另一种具有负 Gas 成本的操作：SELFDESTRUCT（自毁）。通过 SELFDESTRUCT 删除合约曾可获得 24,000 Gas 的退款。目前，SELFDESTRUCT 操作码已被弃用（Deprecated），建议不再使用。

> [!Tip]
> Gas 退款是在交易结束时统一结算的。因此，如果一笔交易没有足够的 Gas 运行到执行结束，交易就会失败，且不会发放任何退款。

### 区块 Gas 限制 (Block Gas Limit)

区块 Gas 限制是指一个区块内所有交易所能消耗的 Gas 总量上限。它决定了一个区块中能够容纳多少笔交易。

例如，假设我们有五笔交易，它们的 Gas 限制分别设置为 30,000、30,000、40,000、50,000 和 50,000。如果区块 Gas 限制为 180,000，那么这五笔交易中的任意四笔都可以装入一个区块，而第五笔则必须等待未来的区块。如前所述，验证者决定将哪些交易纳入区块。不同的验证者可能会选择不同的交易组合，这主要是因为他们从网络中接收交易的顺序不同。

如果验证者试图纳入一笔所需 Gas 超过当前区块 Gas 限制的交易，该区块将被网络拒绝。大多数以太坊客户端会通过发出类似于“交易超过区块 Gas 限制”的警告来阻止你发出此类交易。根据 [Etherscan 的数据](https://etherscan.io/)，在撰写本文时（2025 年 6 月），以太坊主网的区块 Gas 限制为 3600 万 Gas，这意味着一个区块大约可以容纳 1,428 笔基础交易（即每笔消耗 21,000 Gas 的 ETH 转账）。

#### 谁来决定区块 Gas 限制？

在 2021 年 8 月 5 日 EIP-1559 引入之前，矿工（当时以太坊采用基于工作量证明 PoW 的共识算法）拥有一种内置机制，可以对区块 Gas 限制进行投票，从而在随后的区块中增加或减少容量。每个区块的矿工可以投票将区块 Gas 限制向任意方向调整 1/1024 (0.0976%)。其结果是，区块大小可以根据网络需求并遵循矿工算力的意愿进行动态调整。

现在，验证者则是对 Gas 目标值 (Gas Target) 进行投票——即一个区块平均应当消耗多少 Gas——而 Gas 限制 (Gas Limit) 则被定义为该目标值的两倍。每位验证者必须遵守的 1/1024 调整因子仍与以前保持一致。

#### 为什么区块 Gas 限制不持续调高？

你可能会想，如果验证者可以对 Gas 目标值进行投票（这直接转化为 Gas 限制），那为什么区块 Gas 限制不直接涨到 10 亿，而是几乎固定在 3000 万左右呢？更大的区块 Gas 限制意味着单个区块可以容纳更多交易，从而降低终端用户的交易成本。

答案是，提高 Gas 限制会对网络的去中心化产生负面影响。事实上，虽然更大的区块可以包含更多交易，但这也意味着区块在规定时间内验证的难度增加。这可能导致使用普通硬件构建的以太坊节点难以为继，最终只有高性能服务器才能验证完整区块。不仅如此，更大的区块还意味着更快的状态增长 (State Growth)。最终结果如前所述：大服务器将成为唯一能够完整运行节点的实体。

从历史上看，区块 Gas 限制通常在协议升级期间一次性调高，如图 14-25 所示。其数值通常设定在核心开发者建议的水平，以确保所有客户端都能处理交易负载并准时处理区块。

![Figure 14-25](<./images/figure 14-25.png>)
图 14-25. 以太坊平均 Gas 限制走势图

#### 为什么不调高区块 Gas 限制？

尽管区块 Gas 限制在过去三年多里看起来似乎被“固定”在 3000 万，但随着 PBS（提议者-构建者分离，参见“以太坊无状态性”） 机制的引入，情况发生了变化。在这种机制下，拥有精密硬件的角色——构建者 (Builders)——负责构建区块，并将其发送给提议者 (Proposers，即验证者) 发布到 P2P 网络中。这产生了一种激励，促使人们倾向于无限调高区块 Gas 限制，同时让实际使用的 Gas 量几乎保持恒定。

事实上，根据 EIP-1559 的规则，如果区块 Gas 目标值远高于实际使用的 Gas 量，基础费 (Base Fee) 就会持续下降。这会导致几乎所有的 Gas 费用都流向验证者，而不是被销毁（基础费会被销毁，从而将这些 ETH 从供应总量中移除）。

因此，对于验证者来说，这种做法有两个好处：
* 利益自留：他们可以将 Gas 费用留给自己，而不是将其销毁并减少 ETH 供应量。
* 捕获 MEV：在必要时，他们可以创建更大的区块来捕获大量的 MEV（最大可提取价值） 活动，从而为自己赚取更多的费用。

如果你对此感兴趣，可以阅读 [James Prestwich 的文章](https://oreil.ly/EImcE)深入了解。

## 具体实现 (Concrete Implementations)

每一个以太坊节点都拥有本章所述 EVM 的具体实现。以下是目前最知名且使用最广泛的实现列表：

**Go-ethereum (Geth) EVM**

Geth 是采用率最高且历史最悠久的执行客户端。它包含了一个完全由 Go 语言编写的 EVM 实现。

**Execution-specs EVM**

以太坊基金会在 GitHub 上维护着一个 Python 仓库，其中包含了与以太坊执行客户端相关的规范。它拥有一个完整的 Python 版 EVM 实现。

**Revm**

由于其极高的可定制性和适应性，Revm 是标准以太坊客户端之外使用最广泛的 EVM 实现之一（通常被用于 Rust 生态及测试框架 Foundry 中）。

**Evmone**

Evmone 可能是目前速度最快的 EVM 实现。它由以太坊基金会的 Ipsilon 团队使用 C++ 编写并维护。

**Besu EVM**

Besu 是由 Consensys 维护的执行客户端。它拥有一个完全由 Java 编写的 EVM 实现。

**Nethermind EVM**

Nethermind 是一款使用 C# 编写的执行客户端，它也维护着一套完整的 EVM 实现。

## EVM 最重大的升级：EVM 对象格式 (EOF)

EVM 对象格式 (EVM Object Format, EOF) 是自 2015 年诞生以来 EVM 迎来最重大的升级。事实上，尽管过去对 EVM 进行过多次修改（主要集中在 Gas 计量方面或引入新的操作码），但现在的 EVM 与 Gavin Wood 最初创建时的架构几乎完全一致。

目前的 EVM 依然非常出色。今天以太坊（以及所有其他 EVM 兼容链）上发生的一切活动都归功于它。但它也并非完美，在近几年中，智能合约开发者不得不应对它的各种局限性，并学习各种奇技淫巧来克服其约束。

EOF 是一种为 EVM 设计的、可扩展且带版本控制的容器格式，它在部署时进行一次性验证。在本节中，我们将探讨 EVM 目前面临的主要限制，以及 EOF 打算如何克服这些问题。

> [!Note]
> 截至本书最后修订时（2025 年 6 月），由于以太坊社区内部尚未达成充分共识，EOF 升级已被无限期推迟。目前尚无明确的实施时间表，甚至最终可能永远不会被采纳。尽管如此，我们认为本节内容对于理解 EOF 将如何影响 EVM 及其生态系统仍具有重要价值。

### Jumpdest 分析 (Jumpdest Analysis)
传统的（Legacy）EVM 在合约创建时并不会对发布到链上的字节码进行校验。一方面，这看起来似乎不错，因为它允许你发布任何你想要的合约：你可以部署包含不存在的操作码的字节码，或者添加一段永远不会被执行的代码，甚至可以在 PUSH 操作中途截断而不提供其执行所需的立即值。

然而，这种做法实际上引入了大量的低效。事实上，EVM 必须在**运行时（Runtime）**检查所有内容，这增加了复杂性并降低了整体性能。以下是一个在 EVM 字节码中包含不存在的操作码的例子：
```
600C600052602060000C
```
以下是将该字节码转换为人类可读的操作码：
```
[00]            PUSH1            0C
[02]            PUSH1            00
[04]            MSTORE
[05]            PUSH1            20
[07]            PUSH1            00
[09]            NOT-EXISTING
```
操作码 0C 并不存在。当 EVM 执行到该位置时，会触发异常（Panic）并提前返回。请注意，在前面的字节码中，第二个字节也是 0C，但 EVM 并没有在那里报错。区别在于：最后一个 0C 字节被解释为操作码，因其无效而导致失败；而另一个 0C 则被解释为 Push 数据，因为它是第一条 PUSH1 操作码的立即值。

这种运行时检查的一个关键部分是 Jumpdest 分析。在传统（Legacy）EVM 中，每当合约被执行时，每个客户端都必须在运行时进行这项分析。让我们花点时间深入了解什么是 Jumpdest 分析，以及为什么它在 Legacy EVM 中是不可或缺的。

> [!Tip]
> 为了避免每次调用合约时都在运行时进行 Jumpdest 分析，一些以太坊节点实现会为每个合约保存一份 Jumpdest 映射表 (Jumpdest Map)。这份映射表在合约部署时创建，并存储在节点的数据库中。

在传统的（Legacy）EVM 中，仅通过动态跳转（Dynamic Jumps）（即 JUMP 和 JUMPI 操作码）来管理字节码的控制流。这非常方便，因为你只需通过两个操作码就能改变操作的正常流程。然而，缺点在于动态跳转的成本极其昂贵，并且需要在运行时进行深度验证。尽管大多数情况下，跳转并不真正需要是动态的。事实上，跳转的目标值通常在执行 JUMP 操作码之前就已经被推入栈中了。以下是一个简单的例子：
```
…6009566006016101015b6001…
```
这里是将该“伪动态”跳转字节码翻译为人类可读操作码的示例：
```
[00]            PUSH1            09
[02]            JUMP
[03]            PUSH1            06
[05]            ADD
[06]            PUSH2            0101
[09]            JUMPDEST
[0a]            PUSH1            01
```
如你所见，跳转目标（即跳转偏移量 0x09）在执行 JUMP 操作码之前，刚通过 PUSH1 操作码被推入栈中。EVM 先将 0x09 推入栈，随后执行 JUMP 操作码；该操作码将此前推入的 0x09 作为输入，并将执行流程移至该偏移量处的指令。在偏移量 0x09 处，存在一个 JUMPDEST 操作码，因此它被视为有效的跳转目标，程序得以继续正确执行。

为了防止跳转到无效目标，运行时验证是必不可少的。有效的跳转目标仅限于那些不属于 Push 数据一部分的 JUMPDEST 指令。理解这一点至关重要：传统（Legacy）EVM 并没有实现代码与数据的真正分离。因此，每当你在字节码中遇到字节 0x5b（即 JUMPDEST 操作码）时，如果不从整体上分析整个合约，你无法百分之百确定它是一个真正的操作码，还是仅仅是 Push 数据的一部分。

请看下面的例子，它展示了这种微妙的区别：
```
…6009566006016101015b6001…
…6009566006016201015b6001…
```
这两段字节码看起来几乎完全相同；事实上，它们之间仅有一个位的差别。但这一点点的不同就足以导致结果产生巨大的差异。第一段字节码与前一个例子中的完全一致。而第二段字节码翻译成人类可读的格式后如下：
```
[00]            PUSH1            09
[02]            JUMP
[03]            PUSH1            06
[05]            ADD
[06]            PUSH3            01015b
[0a]            PUSH1            01
```
如果你尝试执行这段代码，它会因为无效的跳转目标而失败。这看起来可能有点奇怪，因为在偏移量 0x09 处，仍然存在 0x5b 这个字节（代表 JUMPDEST 操作码）。问题在于，在这种情况下，0x5b 字节是 Push 数据的一部分，因此不能被视为有效的跳转目标。这就是执行在此处失败的原因。

Jumpdest 分析就是分析合约以确定哪些跳转目标有效、哪些无效的过程。这样，当 EVM 执行合约时，它能够检测出无效的跳转目标并触发异常（Panic）。

假设你发送了一笔与“合约 A”交互的交易。当 EVM 加载该合约时，它会立即执行 Jumpdest 分析，以保存有效跳转目标的映射表，随后才开始真正的交易执行。
```
…6009566006016101015b60016015566006016201015b6001…
```
这里是其人类可读的操作码格式：
```
[00]            PUSH1            09
[02]            JUMP
[03]            PUSH1            06
[05]            ADD
[06]            PUSH2            0101
[09]            JUMPDEST
[0a]            PUSH1            01
[0c]            PUSH1            15
[0e]            JUMP
[0f]            PUSH1            06
[11]            ADD
[12]            PUSH3            01015b
[16]            PUSH1            01
```
正如你在图 14-26 中看到的，EVM 会快速扫描整个字节码，并创建一个映射表（Map），将每一个 0x5b 字节标记为有效或无效的跳转目标。

![Figure 14-26](<./images/figure 14-26.png>)

图 14-26. 客户端创建 Jumpdest 映射表以区分有效与无效的跳转目标

### 新增与弃用功能 (Adding and Deprecating Features)
新增或弃用一个操作码或特定功能，远没有看起来那么简单。虽然以太坊过去确实增加过许多操作码（如 BLOBHASH、BLOBBASEFEE、BASEFEE 等），但由于 EVM 字节码缺乏结构化且未经校验，这类改动总是显得非常复杂。

让我们看看下面这个包含无效操作码 0x0C 的例子。假设这是一个已经部署在以太坊主网上的真实合约：
```
600C600052602060000C
```
以下是其人类可读的格式：
```
[00]            PUSH1            0C
[02]            PUSH1            00
[04]            MSTORE
[05]            PUSH1            20
[07]            PUSH1            00
[09]            NOT-EXISTING
```
如果你尝试在 EVM 中执行这段短小的字节码，你会发现当执行到那个不存在的操作码时，程序会报错失败。

现在，假设未来的某次升级增加了一个名为 MAX 的新操作码，其功能是从栈中弹出两个元素并返回其中较大的那个，而分配给它的字节码恰好是 0x0C。请再次考虑前面的那段字节码（记住，我们假设它是已经部署在主网上的合约）：
```
[00]            PUSH1            0C
[02]            PUSH1            00
[04]            MSTORE
[05]            PUSH1            20
[07]            PUSH1            00
[09]            MAX
```
现在，这段字节码的结果截然不同了。事实上，它不再报错，而是成功返回。如果某些合约原本依赖于“该合约因（此前）不存在的操作码而必然失败”这一假设，这就会引发严重问题。

弃用（废除）一项功能甚至更难，因为你无法依靠传统 EVM 的版本控制系统。如果你移除一个操作码或改变其工作方式，使用它的旧合约可能会直接损坏，除了手动干预（创建一个新合约）之外，没有任何办法可以修复它。

当 [EIP-2929](https://oreil.ly/_9kTv) 引入以改变状态访问操作码的 Gas 计量规则时，一些合约崩溃了，因为它们硬编码了固定数量的 Gas 使用量或预期值。使它们重新工作的解决方案是引入访问列表 (Access Lists)，允许你预加载交易将触及的账户和存储插槽，从而降低 Gas 成本。

导致 Legacy EVM 升级困难的其他重要因素还包括 Gas 可观测性 (Gas Observability) 和 代码自省 (Code Introspection)。Gas 可观测性：通过 GAS 操作码或所有将 Gas 作为输入的 `*CALL` 类操作码实现。代码自省：通过 CODESIZE、CODECOPY、EXTCODESIZE、EXTCODECOPY 和 EXTCODEHASH 等操作码实现。

问题在于，如果 EVM 能够访问执行到某一点时的剩余 Gas，智能合约的逻辑就可能依赖于此。如果未来某些操作码的 Gas 计量发生了变化（这种情况并不罕见），那些依赖旧规则的合约就会出问题。代码自省也是同理。

> [!Note]
> 如果没有代码自省，未来的 EOF 版本甚至可以将底层虚拟机完全更换为 Cairo VM、Wasm 或其他虚拟机，方法是将所有合约代码自动转换为具有相同功能的新虚拟机代码。

### 代码与数据分离 (Code and Data Separation)

传统的（Legacy）EVM 并未对发布到链上的字节码强制执行特定的结构。在“真实代码”与该代码所使用的“数据”之间没有明确的界限。一切皆为字节，EVM 在执行过程中仅对其进行逐步解析。

如果不完整地分析整个合约，我们无法断定字节码的某一部分究竟是代码还是数据。请看下面的例子：
```
…730102030405060708090a0b0c0d0e0f101112131431…
[00]            PUSH20    0102030405060708090a0b0c0d0e0f1011121314
[15]            BALANCE
```
如果不深入研究代码逻辑，你无法立即判定 `0102030405060708090a0b0c0d0e0f1011121314` 这一串字节不应被解释为一系列操作码（例如 0x01 代表 ADD，0x02 代表 MUL 等），而实际上它们只是 Push 数据，代表了一个我们想要查询余额的固定地址。这种情况对于静态分析工具和形式化验证非常不利，同时也增加了智能合约在链上直接正确处理可执行代码的难度。

### 堆栈过深 (Stack Too Deep)

接下来我们要探讨的是 EVM 最令人深恶痛绝的限制之一：“堆栈过深 (Stack Too Deep)”错误。如果你尝试编译下面这个智能合约，你会立即触发该错误：

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

contract StackTooDeep {
    function add(
        uint256 a,uint256 b,uint256 c,uint256 d,uint256 e,uint256 f,uint256 g,uint256 h,uint256 i
    ) external pure returns(uint256) {
        return a+b+c+d+e+f+g+h+i;
    }
}
```
尝试编译该合约时的输出结果如下：
```
solc StackTooDeep.sol --bin
Error: Stack too deep. Try compiling with `--via-ir` (cli) or the equivalent `viaIR: true` (standard JSON) while enabling the optimizer. Otherwise, try removing local variables.
 --> StackTooDeep.sol:8:16:
  |
8 |         return a+b+c+d+e+f+g+h+i;
  |                                ^
```

这个错误非常微妙，因为它是 EVM 工作机制的直接产物。事实上，尽管你最多可以将 1,024 个元素推入堆栈，但 EVM 只能通过 DUP1..16 和 SWAP1..16 等操作码，便捷地访问堆栈顶部的 16 个元素。

在我们的 StackTooDeep 示例中，add 函数接收 9 个不同的参数，每个参数都需要放入堆栈。随后，它执行 8 次加法操作以获得最终结果。问题就出在这些细节中：虽然最终的操作看起来像是一次大型的单一加法，但在现实中，编译器必须对每一步进行拆分，并创建一个临时变量来保存需要存入堆栈的中间结果。因此，我们最终需要 9 个参数加上 8 个中间结果，总共需要 17 个堆栈槽位。当编译器尝试引用堆栈中第 17 个或更深位置的变量时，由于没有任何操作码能够轻松访问它，编译便会失败。

为了更直观地理解这个问题，你可以查看图 14-27，它详细展示了每一步的堆栈组成。你可以清晰地看到变量 i 在执行结束时处于第 17 层的深度。编译器不允许局部变量或参数在函数作用域内无法被便捷访问，因此抛出了“stack too deep”错误。

![Figure 14-27](<./images/figure 14-27.png>)

图 14-27. 每一步的堆栈组成示意图

这只是一个展示智能合约开发者日常工作中必须克服的难题的简单例子。尽管编译器在自动分析和管理这类情况方面已经变得越来越出色，但 EVM 基于其当前的工作方式，依然强加了一些难以逾越的硬件级限制。

### EOF (EVM Object Format)

EOF 通过引入一种带部署时验证、版本控制系统以及代码与数据完全分离的 EVM 字节码容器格式，解决了上述所有问题。以下是一个符合 EOF 规范的字节码示例：
```
EF00010100040200010008030001003004002000008000045F5FD1005FEC0000EF00010100040200010004030001001404000000008000025F5FEE00EF00010100040200010001040000000080000000000102030405060708090a0b0c0d0e0f10111213141516171819101a1b1c1d1e
```
以下是其翻译成人类可读格式的内容：
```
Magic bytes                      EF00
EOF version                      01
Stack validation data            01 0004
Code sections                    02 0001 0008
Subcontainer section size        03 0001 0030
Data section size                04 0020
Header terminator                00
Stack: #ins, #outs, max stack    00 80 0004
Code                             5F5FD1005FEC0000
Subcontainers                    EF00010100040200010004030001001404000000008000025F5FEE00
                                 EF00010100040200010001040000000080000000
Data                             000102030405060708090a0b0c0d0e0f10111213141516171819101
                                 a1b1c1d1e
```
先稍等片刻——我们将在接下来的章节中详细解释这一切。

#### 改进之处 (Improvements)
EOF 彻底移除了 Jumpdest 分析以及所有 Gas 和代码自省（Code Introspection） 操作码，这些操作码现在被视为“未定义”。代码段中的所有操作码必须合法，立即值（如 Push 数据）必须完整存在于代码中，且不得包含不可达的指令。同时，堆栈验证也会在创建时执行。这使得执行期间不可能发生堆栈下溢或溢出，从而消除了运行时进行这些检查的必要性，因为 EVM 可以假定合约在部署时已通过验证，完全符合所有规则。

> [!Tip]
> 这些验证保证显著提高了将 EVM 字节码通过 AOT（预编译） 或 JIT（即时编译） 转换为机器原生代码的可行性。

动态跳转也被移除，并引入了三种带有立即值的静态相对跳转操作码：RJUMP、RJUMPI 和 RJUMPV。注意，由于不再需要进行 Jumpdest 分析，且所有内容都在创建时而非运行时检查，EOF 使得添加带有立即值的新指令成为可能。

正如前一节的 EOF 容器所示，EOF 引入了**函数**（Functions）的概念（即代码段），并为每个函数隔离了堆栈。传统的 Legacy EVM 只能通过动态跳转来模拟这种行为：在 Legacy EVM 中，Solidity 或 Vyper 的函数仅仅是编译器内部的表示形式。

为此，EOF 增加了三个操作码 —— CALLF、RETF 和 JUMPF，以及一个返回栈（Return Stack）（完全独立于 EVM 常用的操作数栈）。特别地，返回栈用于在跳转进入函数前保存执行信息，以便在返回调用者时不丢失数据。图 14-28 可以帮助你更直观地理解这一机制。

![Figure 14-28](<./images/figure 14-28.png>)

图 14-28. EOF 引入了函数或代码段的概念

“堆栈过深 (Stack too deep)”问题通过引入三个新操作码得到了解决：DUPN、SWAPN 和 EXCHANGE。前两个指令与旧有的 `DUP1..16` 和 `SWAP1..16` 类似，唯一的区别在于它们接受一个立即值作为参数，代表要复制或交换的元素索引。该索引最高可达 256，远超此前 16 的硬性限制。

EXCHANGE 是一个全新的操作码，允许你交换堆栈中两个不同的元素（注意，SWAPN 总是将第 $n$ 个元素与栈顶元素交换，而 EXCHANGE 可以交换任意两个元素）。这对于实现**堆栈调度算法**（Stack-scheduling algorithms）的编译器特别有用，这些算法旨在根据变量集和使用分析来最小化堆栈交互开销。

在 EOF 合约中，CREATE 和 CREATE2 已被废弃。取而代之的是 EOFCREATE 和 RETURNCONTRACT，它们提供了创建新 EOF 合约的标准方式。

最后，引入了新的 CALL 指令来替换已被移除的旧指令：EXTCALL、EXTDELEGATECALL、EXTSTATICCALL 以及 RETURNDATALOAD。这些新指令不允许指定 Gas 限制（消除了 Gas 可观测性），也不再需要预留输出缓冲区（Output Buffer）来让 EVM 保存子调用的返回数据。引入 RETURNDATALOAD 的具体原因就是为了将最后一次执行的子调用的返回数据加载到调用者的堆栈中。

#### EOF 实战解析

让我们来深入分析本节开头展示的那个 EOF 合约：
```
EF00010100040200010008030001003004002000008000045F5FD1005FEC0000EF00010100040200010004030001001404000000008000025F5FEE00EF00010100040200010001040000000080000000000102030405060708090a0b0c0d0e0f10111213141516171819101a1b1c1d1e
```
首先是 EOF 头部，由以下部分组成：
```
Magic bytes                    EF00

```
幻数 (Magic bytes)用于区分 EOF 合约与传统合约（得益于 EIP-3541，以太坊主网上没有其他合约会以 EF00 开头）。

随后是 EOF 版本号，它能让 EOF 格式在未来以一种优雅的方式进行升级：

```
EOF version                    01
```

紧接着是堆栈验证数据，它总是以标识符 01 开头，后跟“堆栈”部分的长度。在本例中，我们有一个 4 字节长的堆栈段：

```
Stack validation data            01 0004
```

代码段则以标识符 02 开头，后跟代码段（即函数）的数量及其相关的大小。在这里，我们有一个 8 字节长的代码段：

```
Code sections                02 0001 0008
```

子容器段大小以标识符 03 开头，后跟子容器的数量及其相关大小。在这里，我们有一个 48 字节长的子容器（记住，这始终是十六进制格式，即 0x30）：

```
Header terminator                00
```
堆栈段（Stack Section）展示了每个代码段的输入、输出数量以及最大堆栈高度（本例中仅有一个代码段）。我们这里是零输入，且为一个非返回函数（80 是代表非返回函数的特殊字节），堆栈的最大高度等于 4：

```
Stack: #ins, #outs, max stack        00 80 0004
```

以下是包含由 EVM 执行的 EVM 字节码的所有代码段：

```
Code                        5F5FD1005FEC0000
```

我们只有一个函数（代码段），其中包含以下操作码：

```
PUSH0 PUSH0 DATALOADN 0 PUSH0 EOFCREATE 0 STOP

```
这段代码首先利用前两个 PUSH0 操作码将 0-0 推入栈中。接着，它从偏移量 0（紧跟在代码中的立即值）开始读取数据段中的 32 字节，并将其推入栈。随后，通过最后一个 PUSH0 又推入了一个 0。最后，调用 EOFCREATE 并以 0 作为其立即操作数，这将触发对第一个子容器中第一个代码段的调用：
```
Subcontainers                EF00010100040200010004030001001404000000008000025F5FEE00EF0001
                             0100040200010001040000000080000000
```
子容器段 (Subcontainers Section) 包含了 EOF 字节码中所涵盖的所有 EOF 子容器。在本例中，我们有一个子容器。子容器本身也是符合 EOF 格式的字节码：其核心思想是将一个 EOF 容器嵌套在另一个 EOF 容器内部。这种设计对于工厂合约 (Factory Contracts) 非常有用。

最后是数据段 (Data Section)，它包含了合约执行所需的所有静态数据。在本例中，我们拥有 32 字节的数据：

```
Data                        000102030405060708090a0b0c0d0e0f10111213141516171819101a1b1c1d1e
```

这种分析方法可以递归地应用于该 EOF 字节码的子容器，从而完全理解其具体行为。但如果你有兴趣深入探究 EVM 的“兔子洞”，我们将这部分留给读者自行探索。

## EVM 的未来 (The Future of the EVM)

除了 EOF 之外，EVM 的未来仍充满不确定性，这将取决于开发者和不同项目如何使用 EVM。不过，有一些有趣的领域值得 EVM 扩展，例如 zk-EVM，它将为每个区块提供零知识证明，以证明其执行的正确性。此外，[EVMMAX](https://oreil.ly/ioqSx) 和 [SIMD](https://oreil.ly/7q0Dq)（单指令多数据流）将为 EVM 带来更强大的性能，使其在处理大量加密运算时速度大幅提升。这对于依赖加密技术的应用（如隐私协议或 L2 扩容方案）尤为有利。

## 总结 (Conclusion)

在本章中，我们深入探索了 EVM，追踪了各种智能合约的执行过程，并了解了 EVM 如何解析和执行字节码。我们还研究了 Gas —— EVM 的计费机制，并见证了它如何解决停机问题并保护以太坊免受 DoS 攻击。此外，我们分析了 EOF，探讨了它如何尝试修复传统（Legacy）EVM 的各种缺陷。

接下来，在第 15 章中，我们将探索以太坊实现去中心化共识的机制。




