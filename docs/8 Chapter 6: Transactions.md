# 第六章： 交易

交易是由外部账户（EOA）发起的签名消息，经由以太坊网络传输，并最终记录在以太坊区块链上。这个基本定义背后隐藏着许多令人着迷的细节。换个角度来看，交易是唯一能够触发状态变更或导致合约在以太坊虚拟机（EVM）中执行的行为。以太坊是一个全球唯一的单体状态机，而交易正是让这个状态机“跳动”并改变其状态的脉搏。合约不会自行运行，以太坊也不会自动运转——一切始于交易。

在本章中，我们将剖析交易，展示它们的工作原理并审视其细节。需要注意的是，本章的大部分内容是针对那些有兴趣在底层管理交易的人（例如正在开发钱包应用的开发者）。如果你习惯于使用现有的钱包应用，则无需担心这些细节，尽管你可能会发现这些底层机制非常有趣。

## 交易结构（The Structure of a Transaction）
首先，让我们看看交易在以太坊网络中进行序列化和传输时的基本结构。每个接收到序列化交易的客户端都会使用其内部的数据结构将其存储在内存中，并可能添加一些网络序列化交易本身并不存在的元数据。网络序列化（Network Serialization）是交易唯一的标准形式。在以太坊运行初期，只有单一类型的交易。但 EIP-2718 引入了一种处理不同交易类型的方法，并允许以不同的方式处理它们。具体而言，每笔交易都以一个指定交易类型的单字节（Byte）开头：
$$transaction = tx\_type \ || \ tx\_payload$$
在编写本书时（2025 年 6 月），共存在五种交易类型，如表 6-1 所示。

表 6-1. EIP-2718 交易类型
![Table 6-1](<./images/table 6-1.png>)

让我们详细分析这些交易组成部分。

### 遗留交易（Legacy Transactions）
一笔遗留交易[^1]是一个序列化的二进制消息，包含以下数据：
* **链 ID** (Chain ID)：你发送交易的目标网络标识。它是通过 EIP-155 引入的，作为一种简单的重放攻击保护机制。
* **Nonce**：由发起账户（EOA）发出的序列号，用于防止消息重放。[^2]
* **Gas价格** (Gas price)：发起者愿意支付的单位 Gas 单价（以 wei 为单位）。
* **Gas限制** (Gas limit)：发起者愿意为这笔交易购买的最大 Gas 数量。请注意，你只需为实际消耗的 Gas 付费，Gas 限制仅代表你的出价上限。
* **接收者** (Recipient)：目标以太坊地址。
* **数额** (Value)：发送到目的地的以太币数量。
* **数据** (Data)：可变长度的二进制数据负载（Payload）。
* **v, r, s**：发起账户（EOA）的 ECDSA 数字签名的三个组成部分。

交易消息的结构使用**递归长度前缀（RLP）**编码方案进行序列化。RLP 是专为以太坊设计的，旨在实现简单且字节精准的数据序列化。以太坊中的所有数字都编码为大端（big-endian）整数，长度为 8 位（1 字节）的倍数。

请注意，为了清晰起见，这里显示了字段标签（如 to、gas limit 等），但它们并不属于交易序列化数据的一部分。序列化数据仅包含 RLP 编码后的字段值。通常，RLP 不包含任何字段分隔符或标签。它使用长度前缀来识别每个字段的长度，超出定义长度的内容即属于结构中的下一个字段。

虽然这是实际传输的交易结构，但大多数内部表示和用户界面可视化都会添加一些从交易或区块链中派生出的额外信息。关于“From”地址：你可能会注意到地址数据中没有“from”字段。这是因为发起账户（EOA）的公钥可以从 ECDSA 签名的 $v, r, s$ 分量中派生出来。随后，地址又可以从公钥中派生。当你看到交易显示 from 字段时，那是可视化软件自行添加的。其他元数据：客户端软件经常添加的其他元数据包括块号（一旦交易发布并被包含在区块链中）和交易 ID（计算得出的哈希值）。同样，这些数据是从交易中派生出来的，并不构成交易消息本身的一部分。

### EIP-2930 交易
[EIP-2930](https://oreil.ly/1dSza) 交易是首个使用 EIP-2718 类型化交易信封（Typed Transaction Envelope）的交易，其交易类型标识为 0x01。它们在本质上与之前的交易类型相同，但增加了一个名为 访问列表（Access List） 的新字段。这是一个由（地址、存储槽）组成的数组，允许用户为交易将要触达的地址和存储槽进行“预付费”。通过这种方式，在以太坊虚拟机（EVM）的执行过程中，用户被收取的 Gas 费用会更低。

>[!NOTE]
>更准确地说，访问列表中包含的地址及其存储槽分别被计入 accessed_addresses（已访问地址）和 accessed_storage_keys（已访问存储键）中。EVM 利用这些列表来区分热访问（Warm Access）和冷访问（Cold Access）。冷访问收取的 Gas 远高于热访问。例如，SLOAD 操作码在访问热存储槽时仅收取 100 Gas，而冷访问则需收取 2,100 Gas。

这种新交易类型的引入主要是为了解决由 EIP-2929 引起的问题。EIP-2929 提高了状态访问操作码的 Gas 成本，导致一些智能合约在处理交易时因 Gas 不足（Out-of-Gas）错误而失败。通过引入访问列表，用户可以为其交易将访问的地址和存储槽预先付费，从而防止这些执行失败。

### EIP-1559 交易
[EIP-1559](https://oreil.ly/ZBON6) 交易于 2021 年 8 月 5 日在“伦敦”硬分叉中引入，其交易类型标识为 0x02。它们通过引入一个新的协议参数——基础费（Base Fee），彻底改变了以太坊的手续费市场结构。

基础费代表了在以太坊网络上发送交易所需支付的最低费用。在本次升级中，区块 Gas 限制（Block Gas Limit）从 1,500 万翻倍至 3,000 万 Gas，并引入了等于 Gas 限制一半的区块 Gas 目标（Block Gas Target），即 1,500 万 Gas。其核心设计理念是保持以太坊网络平均负载与以往持平，但在需要时允许区块容量变得更大（最高可达两倍）。

为了使区块的平均 Gas 使用量维持在 1,500 万，基础费并不是一个固定值：它会根据区块的利用率动态调整。如果一个区块的实际 Gas 使用量高于目标值，基础费就会增加；如果低于目标值，基础费则会减少。

区块 Gas 限制（几乎）总是会在特定区块被调整为固定的、圆整的数值：1,000 万、1,250 万、1,500 万以及 3,000 万，具体趋势如图 6-1 所示。事实上，尽管验证者（以及旧 PoW 共识协议下的矿工）可以在每个区块微调 Gas 目标（这会直接转化为 Gas 限制），但区块 Gas 限制是一个至关重要的数值，通常所有人都会遵循核心开发者的建议。
![Figure 6-1](<./images/figure 6-1.png>)
图 6-1. 以太坊区块 Gas 限制历史演进
基础费（Base Fee）并不会流向创建区块的验证者（或矿工）；相反，它们会被立即销毁（Burned），从而减少以太坊的总供应量。同时，协议引入了一项新费用——优先费（Priority Fee），你可以将其理解为支付给验证者（或矿工）的小费，用以激励他们将你的交易包含在下一个区块中。
>[!TIP]
>理论上，你可以创建仅支付强制性基础费而“零小费”的交易。协议并不强求你向验证者支付小费。但在现实操作中，你应当始终包含优先费，以确保交易能在合理的时间内得到确认。需要注意的是，钱包通常会自动为你处理基础费和优先费，并将其设置为合适的数值。

一笔 EIP-1559 交易是一个序列化的二进制消息，包含以下数据：

* **链 ID** (Chain ID)：与遗留交易相同。
* **Nonce**：与遗留交易相同。
* **每单位 Gas 的最大优先费** (Max priority fee per gas)：发起者愿意直接支付给验证者的 Gas 单价（以 wei 为单位），作为将其交易纳入区块的小费。
* **每单位 Gas 的最大总费用** (Max fee per gas)：发起者愿意支付的总 Gas 单价（以 wei 为单位），包含基础费和优先费。
* **Gas 限制** (Gas limit)：与遗留交易相同。
* **接收者** (Recipient)：与遗留交易相同。
* **访问列表** (Access list)：与 EIP-2930 交易相同。
* **数额** (Value)：与遗留交易相同。
* **数据** (Data)：与遗留交易相同。
* **v, r, s**：与遗留交易相同。

与所有交易类型一样，其消息结构采用 RLP 编码方案进行序列化。

### EIP-4844 交易
[EIP-4844](https://oreil.ly/JMJmB) 交易随 2024 年 3 月 13 日的“坎昆（Cancun）”硬分叉引入，交易类型标识为 0x03。我们在第四章“KZG 承诺”一节中已经提到过它们，并将在第十六章进行深入探讨。这类交易也被称为携带 Blob 的交易（blob-carrying transactions），因为它们带有一个“边车（sidecar）”——即 Blob。每个 Blob 包含大量数据（约 131,000 字节），这些数据无法被 EVM（以太坊虚拟机）直接访问，但其对应的“承诺（commitment）”是可以被访问的。

为了处理 Blob，协议引入了一种新型 Gas——Blob Gas。它与普通 Gas 完全分离且相互独立。尽管它深受 EIP-1559 的启发并遵循类似的定价规则，但它有自己的目标调节逻辑：如果区块中使用的 Blob Gas 超过了目标值，Blob Gas 的价格就会上涨；反之则下降。

其序列化二进制消息格式与 EIP-1559 类似，但新增了两个字段：

* **每单位 Blob Gas 的最大费用** (Max fee per blob gas)：发起者愿意为 Blob 支付的 Blob Gas 单价（以 wei 为单位）。
* **Blob 版本化哈希列表** (Blob versioned hashes)：一个 32 字节值的列表，代表与该交易所携带的每个 Blob 相关联的 KZG 承诺的版本化哈希。

>[!NOTE]
>随着坎昆硬分叉和 EIP-4844 交易的引入，区块头增加了两个新元素：
>
> **已使用的 Blob Gas** (Blob gas used)：
>
>区块内所有 EIP-4844 交易消耗的 Blob Gas 总量。
>
> **超额 Blob Gas** (Excess blob gas)：
>
>在该区块之前，累积消耗的超出目标值的 Blob Gas 总量。

### EIP-7702 交易
[EIP-7702](https://oreil.ly/W_28X) 交易随 2025 年 5 月 7 日的“Pectra”硬分叉引入，交易类型标识为 0x04。它们允许外部账户（EOA）在自己的账户中设置代码。传统上，EOA 的代码字段是空的；它们只能发起交易，除非与智能合约交互，否则无法执行复杂操作。EIP-7702 改变了这一现状，使 EOA 能够执行如下操作：

* **批量处理**（Batching）：允许同一用户在单笔原子交易中完成多个操作。例如，先进行 ERC-20 授权（Approve），紧接着完成资产消费。这是许多去中心化交易所中非常常见的流程。
* **代付**（Sponsorship）：账户 X 可以代表账户 Y 支付交易费用。
* **权限降级**（Privilege deescalation）：用户可以签署子密钥并赋予其特定的受限权限，这些权限远弱于对账户的全局访问权。例如，限制每天只能消费总余额的 1%，或者只能与特定的应用程序交互。

底层的实现细节相当复杂，如果你感兴趣，我们建议阅读 EIP 官方网站。不过，从高层概述来看，它的原理简单却非常强大。EIP-7702 允许 EOA 为自己分配一个委派标识符（delegation designator）。该标识符指向一个（已存在于以太坊主网上的）智能合约。当一笔交易发送至该 EOA 时，它会执行指定地址的代码，就好像那是该 EOA 自身的实际代码一样，如图 6-2 所示。
![Figure 6-2](<./images/figure 6-2.png>)
图 6-2. EIP-7702 委派机制


## 交易 Nonce（The Transaction Nonce）
Nonce 是交易中最重要但也最常被误解的组成部分之一。在以太坊“黄皮书”中，它的定义如下：

> Nonce：一个标量值，等于从该地址发送出的交易数量；或者对于有关联代码的账户（合约账户）而言，是指由该账户创建的合约数量。

严格来说，Nonce 是发起地址的一个属性——即它仅在发送地址的语境下才有意义。然而，Nonce 并不作为账户状态的一部分显式地存储在区块链上，而是通过计算从该地址发出的已确认交易数量动态得出的。

Nonce 的存在对于两个场景至关重要：一是确保交易按创建顺序被包含的可用性功能，二是防止交易重复攻击的核心安全功能。让我们分别为这两个功能看一个示例场景：

场景1：顺序执行

假设你想进行两笔交易：一笔是 6 ETH 的重要付款，另一笔是 8 ETH 的付款。你先签署并广播了 6 ETH 的交易，因为它更重要。随后你签署并广播了 8 ETH 的交易。遗憾的是，你忽略了账户里只有 10 ETH，因此网络无法同时接受这两笔交易：其中一笔必然失败。

因为你先发送了更重要的 6 ETH 交易，你自然希望这笔成功，而 8 ETH 的被拒绝。但在像以太坊这样的去中心化系统中，节点接收交易的顺序是随机的，无法保证某个节点一定会先收到哪一笔。如果没有 Nonce，哪一笔被接受将变成一场随机的博弈。

但是，有了 Nonce 之后，你发送的第一笔交易 Nonce 为 3（假设），而 8 ETH 交易的 Nonce 就是 4。即便节点先收到了 Nonce 为 4 的交易，它也会将其忽略，直到 Nonce 0 到 3 的交易全部处理完毕。

场景 2：重放保护

假设你的账户里有 100 ETH。你从网上买了一个心仪的零件并支付了 2 ETH。你签署并广播了这笔交易。如果没有 Nonce，当你第二次给同一个地址发送 2 ETH 时，这笔交易看起来和第一笔完全一样。

这意味着任何在网络上看到你交易的人（包括收款人或你的对手），只需简单地复制并粘贴你原始交易的签名数据，就可以一遍又一遍地“重放”这笔交易，直到榨干你账户里所有的钱。然而，由于交易数据中包含了 Nonce 且每笔交易递增，每一笔交易都是唯一的。即使是向同一地址发送相同金额，其 Nonce 也不同，这让任何人都不可能“复制”你的支付行为。

总结，需要特别指出的是，对于以太坊这种基于账户模型的协议，使用 Nonce 是至关重要的；这与比特币协议所使用的 UTXO（未花费交易输出） 机制形成了鲜明对比。

### 追踪 Nonce（Keeping Track of Nonces）
在本节及后续章节中，我们将使用 Foundry 工具套件——特别是 cast 工具。它能以非常便捷的方式与区块链进行交互。如果你想复现以下示例，请务必安装它。

首先，我们需要设置本章将要使用的钱包。打开终端窗口并输入：

```Bash
$ cast wallet new
Successfully created new keypair.
Address:     0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
Private key: 0xd6d2672c6b4489e6bcd4e93b9af620fa0204b639b7d7f93765479c0846be0b58
```
> [!CAUTION]
> 如果你向上述地址发送资金，那是在浪费钱，因为其私钥已公开，任何人都可以利用它将资金转走。

现在，我们需要将私钥导入电脑的密钥库（Keystore），以便稍后轻松调用：

```Bash
$ cast wallet import example \
    --private-key 0xd6d2672c6b4489e6bcd4e93b9af620fa0204b639b7d7f93765479c0846be0b58
Enter password:
`example` keystore was saved successfully. Address: 0x7e41354afe84800680ceb104c5fc99ecb98a25f0
```
你可以选择（并推荐）设置一个密码，在后续使用该账户创建交易时将需要输入此密码。现在我们已正确设置，但账户里还没有任何 ETH。

你可以随时检查余额。首先，获取与账户关联的地址：
```Bash
$ cast wallet address --account example
Enter keystore password:
0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
```
接着，你可以向区块链查询余额。在本章的所有示例中，我们将使用以太坊 Sepolia 测试网：
```Bash
$ cast balance 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0
```
> [!NOTE]
> 请留意上一个 cast 命令中的 --rpc-url 标志。它应该指向你感兴趣的区块链的 RPC 端点。可靠的 RPC 端点通常需要付费，但如果你只是想进>行实验（如本章所述），有很多免费选项，例如：
>
> * Public Node
> * LlamaNodes
> * ChainList

为了获取一些免费的 Sepolia ETH 代币，你可以使用在线水龙头（Faucet）。我们将使用 Google Cloud Web3 水龙头（如图 6-3 所示），它会提供 0.05 ETH。访问 Ethereum Sepolia Faucet，粘贴你的地址并点击 "Receive 0.05 Sepolia ETH" 按钮。你应该很快就能收到 0.05 ETH。
![Figure 6-3](<./figure 6-3.png>)
图 6-3. Google Cloud Web3 水龙头界面

在成功申领测试币后，你可以验证余额已从 0 变为 $0.05 \text{ ETH}$（即 $5 \times 10^{16} \text{ Wei}$ ）：
```Bash
$ cast balance 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
50000000000000000
```
太好了！现在我们已完全准备就绪，可以回到关于交易 Nonce 的实验中。

从实际操作的角度来看，Nonce 是指从某个账户发出的**已确认（即已上链）**交易的最新计数。要查询 Nonce，你可以使用 cast 询问区块链。只需打开一个新的终端窗口并输入：
```Bash
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0
```

> [!TIP]
> Nonce 是一个从零开始的计数器，这意味着第一笔交易的 Nonce 为 0。在本例中，由于尚未发送过交易，返回值为 0。此外，RPC 响应总是指向下一个可用的 Nonce。例如，如果地址已发送 10 笔交易（Nonce 0-9），查询将返回 10。

我们可以实际动手尝试发送一笔以太币（ETH）了。我们将向 `vitalik.eth` 发送 0.001 ETH，这是以太坊联合创始人 Vitalik Buterin 的 ENS（以太坊域名服务）地址：
```Bash
$ cast send --account example vitalik.eth --value 0.001ether --rpc-url https://ethereum-sepolia-rpc.publicnode.com
blockHash               0xa1171309fd406e44e86be9695a597d2bf5c728738d140b9958cfb50276c32b1b
blockNumber             6989355
contractAddress
cumulativeGasUsed       18009816
effectiveGasPrice       11163498011
from                    0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
gasUsed                 21000
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root
status                  1 (success)
transactionHash         0xeb7bb0322858a4e1ed85271a60d2f8353075dc0bcd0c80448ee1d5ca0bb85def
transactionIndex        60
type                    2
blobGasPrice
blobGasUsed
authorizationList
to                      0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
```

你的钱包会为你管理的每个地址自动追踪 Nonce。只要你仅从单一终端（例如只用这台电脑上的 cast）发起交易，这个过程非常简单。但假设你正在编写自己的钱包软件或某些需要发起交易的应用程序，你该如何管理 Nonce？

当你创建一笔新交易时，你会按顺序分配下一个 Nonce。但在该交易被确认（即正式入块）之前，它并不会计入链上的 Nonce 总数。

为了观察这一现象，我们可以尝试快速连续执行以下命令：
```Bash
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
10
$ cast send --account example vitalik.eth --value 0.001ether --async --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0x85f5b0db44407a6e9252590dc809087a2e232e00a951c9cb8853a109da5ddad4
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
10
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
11
```
如你所见，我们发送的交易并没有立即增加 Nonce 计数；即使在发送交易之后，它依然保持为 10。如果我们等待几秒钟，让网络通信稳定下来并将交易包含在区块中，再次调用 Nonce 查询才会返回预期的数字 11。

> [!NOTE]
> 请留意 `cast send` 命令中使用的 `--async` 标志：如果你不使用它，`cast` 会在终端中持续阻塞，直到交易在区块内得到确认。使用该标志后，它会将交易推送到网络并立即返回交易哈希（Transaction Hash），而无需等待入块。

现在让我们看一个不同的例子：
```Bash
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
11
$ cast send --account example vitalik.eth --value 0.001ether --async --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0x63188aa73247ffe06388a9adf399fa715e42fbc37ca53f77642a7860c80feb9d
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
11
$ cast rpc eth_getTransactionCount 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 pending --rpc-url https://ethereum-sepolia-rpc.publicnode.com
"0xc"
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
12
```

在发送交易之前，我们的 Nonce 计数是 11；发送交易后，我们立即查询新的 Nonce。正如从前一个示例中所预期的，由于交易仍处于内存池（Mempool）中待处理，尚未被包含在区块内，因此 Nonce 尚未更新。然而，我们使用了一种新的查询方式，它实际上能够获取到真实的 Nonce 数量，即便交易尚未得到确认（返回的 0xc 是十六进制的 12）。几秒钟后，交易被添加到区块中，此时调用 cast nonce 就会返回新的正确值。

`cast nonce` 与 `eth_getTransactionCount pending` 之间的区别很简单：前者仅考虑已确认的交易（即已入块的交易），而后者则尝试包含那些仍在内存池中待处理（Pending）的交易。

> [!Warning]
> 在使用 eth_getTransactionCount pending 来统计待处理交易时务必小心。事实上，尽管它试图返回一个地址真实的 Nonce 值，但没有任何办法能百分之百确定内存池中是否还隐藏着其他等待确认的待处理交易。
>
> 公共内存池（Public Mempool）并不是一个全球统一的实体。 每个节点都有自己的内存池：这是一种用于存放待处理交易的动态仓库，在它们被正式确认上链前进行临时保存。每个节点都可以通过设置不同的规则（例如不同的最低 Gas 价格限制或账户限制）来定制自己接受或拒绝新交易的逻辑。虽然 RPC 服务商拥有庞大的节点网络，并且理论上应该对所有待处理交易拥有（近乎）完整的视角，但你仍应警惕，不要将该返回值视为 100% 准确。

### Nonce 间隙、重复 Nonce 与确认（Gaps, Duplicates, and Confirmation）
如果你是通过编程方式创建交易，追踪 nonce 就变得至关重要，特别是当你试图从多个独立的进程同时发起交易时。

以太坊网络根据 nonce 严格顺序地处理交易。这意味着，如果你发送了一笔 nonce 为 0 的交易，接着又发送了一笔 nonce 为 2 的交易，那么第二笔交易不会被包含在任何区块中。它会被存储在内存池（mempool）中，此时以太坊网络会等待缺失的 nonce 出现。所有节点都会假设缺失的 nonce 只是被延迟了，而 nonce 为 2 的交易只是乱序到达了。

如果你随后发送了缺失的 nonce 1，那么两笔交易（nonce 1 和 2）都将被处理并包含在区块中（当然前提是它们合法）。一旦你填补了间隙，网络就能打包之前保存在内存池中的乱序交易。

这意味着，如果你按顺序创建了几笔交易，而其中一笔没有被正式包含在区块中，那么所有后续交易都会被“卡住”，等待那个缺失的 nonce。一笔交易可能因为无效或 gas 不足而产生无意的“间隙”。要让交易重新流动，你必须发送一笔具有缺失 nonce 的有效交易。你同样需要警惕：一旦这个“缺失”的 nonce 被网络验证，所有已广播的后续 nonce 交易都会依次生效——撤回一笔已发送的交易是不可能的！

另一方面，如果你不小心重复了 nonce —— 例如发送了两笔具有相同 nonce 但收款人或金额不同的交易 —— 那么其中一笔会被确认，另一笔会被拒绝。哪一笔被确认取决于它们到达第一个接收它们的验证节点的顺序 —— 也就是说，这具有相当大的随机性。

如你所见，追踪 nonce 是必不可少的。如果你的应用程序无法正确管理这一过程，就会遇到麻烦。遗憾的是，正如我们将在下一节看到的，如果你尝试并发执行此操作，情况会变得更加复杂。

### 并发、交易发起与 Nonce（Concurrency, Transaction Origination, and Nonces）
并发是计算机科学中一个复杂的方面，它有时会出人意料地出现，尤其是在像以太坊这样去中心化和分布式的实时系统中。

简单来说，并发是指多个独立系统同时进行计算。这些系统可以在同一个程序中（如多线程）、同一个 CPU 上（如多进程），或者在不同的计算机上（如分布式系统）。从定义上讲，以太坊是一个允许操作（节点、客户端、DApps）并发的系统，但通过共识机制强制执行单体状态（Singleton State）。

现在，想象一下你有多个独立的钱包应用程序，它们正在从同一个或多个地址生成交易。这种情况的一个例子是交易所处理来自其热钱包（hot wallet）的提现。理想情况下，你会希望有多台计算机处理提现，这样它就不会成为瓶颈或单点故障。然而，这很快就会变得棘手，因为多台计算机产生提现会导致一些棘手的并发问题，其中最核心的就是 nonce 的选择。多台从同一个热钱包账户生成、签名并广播交易的计算机如何进行协调？

你可以使用一台计算机按先来后到的顺序，为负责签名交易的计算机分配 nonce。然而，这台计算机现在成了单点故障（single point of failure）。更糟的是，如果分配了几个 nonce，但其中一个由于处理该交易的计算机发生故障而从未被使用，那么所有后续交易都会被卡住。

另一种方法是生成交易但不分配 nonce（因此不签名——请记住，nonce 是交易数据的组成部分，因此必须包含在验证交易的数字签名中）。然后，你可以将它们排队发送到一个负责签名并追踪 nonce 的单一节点。但同样，这会成为流程中的一个瓶颈：在高负载下，签名和追踪 nonce 的部分最容易发生拥塞，而生成未签名交易的部分其实并不真正需要并行化。你虽然实现了一定程度的并发，但在流程的关键部分却缺乏并发能力。

最终，这些并发问题，加上在独立进程中追踪账户余额和交易确认的难度，迫使大多数实现方案趋向于规避并发并创造瓶颈，例如使用单一进程处理交易所的所有提现交易，或者设置多个完全独立工作的热钱包进行提现，仅需定期进行余额重平衡（rebalanced）。

## 交易 Gas（Transaction Gas）
我们在前面的章节中简要提到过 Gas，并将在第 14 章对其进行更详细的讨论。不过，让我们先了解一下交易中 gasPrice 和 gasLimit 组件所起作用的基础知识。

Gas 是以太坊的燃料。Gas 并不是以太币（Ether）：它是一种独立的虚拟货币，拥有自己对以太币的汇率。以太坊使用 Gas 来控制交易可以消耗的资源量，因为交易将在全球数千台计算机上处理。这种开放式（图灵完备）的计算模型需要某种形式的计量，以避免拒绝服务（DoS）攻击或无意间消耗大量资源的交易。

Gas 与以太币分离是为了保护系统免受以太币价值剧烈波动的影响，并以此管理 Gas 所支付的各种资源（计算、内存和存储）成本之间重要且敏感的比例关系。

交易中的 gasPrice 字段允许交易发起者设置他们愿意支付的 Gas 单价。该价格以每单位 Gas 多少 Wei 来衡量。

> [!TIP]
> 知名网站 Etherscan 提供了以太坊主网当前 Gas 价格及其他相关 Gas 指标的实时信息。

钱包可以在其发起的交易中调整 gasPrice，以实现更快的交易确认。gasPrice 设置得越高，交易被确认的速度通常就越快。相反，低优先级的交易可以携带较低的价格，从而导致确认速度变慢。gasPrice 可设置的最小值等于交易被包含区块的基础费用（Base Fee）（我们在 EIP-1559 交易中介绍过这一概念）。

> [!NOTE]
> 在伦敦硬分叉（London Hard Fork）和 EIP-1559 协议实施之前，最低可接受的 gasPrice 是零。这意味着钱包可以生成完全免费的交易。根据当时网络的处理能力，这些交易可能永远不会被确认，但协议本身并不禁止免费交易。在以太坊运行的前几个月里，你可以从区块链上找到好几个成功入块的零费用交易示例。

### EIP-1559：基础费用与优先费用（Base Fee and Priority Fee）
正如我们之前简要解释过的，EIP-1559 通过引入一个新的协议参数——基础费用（Base Fee），彻底改变了以太坊费用市场的结构。它代表了一笔交易若要被视为有效并被包含在区块中，所需支付的最低 Gas 价格。

基础费用与交易实际支付的 Gas 费用之间的差额被称为优先费用（Priority Fee）。这部分费用直接流向创建该交易所属区块的验证者（Validator）。

### 如何确定“正确”的 Gas 价格（How to Know the "Correct" Gas Price）

Cast 可以通过计算多个区块的平均价格来提供 Gas 价格建议：
```Bash
$ cast gas-price --rpc-url https://ethereum-sepolia-rpc.publicnode.com
4845187414
```
与 Gas 相关的第二个重要字段是 gasLimit。简单来说，gasLimit 指的是交易发起者为了完成交易而愿意购买的 Gas 单位的最大数量。对于简单支付（即从一个外部账户 EOA 向另一个 EOA 转账以太币），所需的 Gas 量固定为 21,000 个单位。要计算这笔交易的花费，只需将 21,000 乘以你愿意支付的 gasPrice（如果是 EIP-1559 交易，则乘以 maxFeePerGas）。

如果你的交易目标地址是一个合约，那么所需的 Gas 量可以被估算，但无法被精确确定。这是因为合约可以评估不同的条件，从而导致不同的执行路径，进而产生不同的总 Gas 成本。合约可能只执行简单的计算，也可能执行更复杂的计算，这取决于你无法控制且无法预测的条件。为了证明这一点，让我们看一个例子：我们可以编写一个智能合约，每次被调用时都会递增一个计数器，并执行一个循环，循环次数等于当前的调用次数。也许在第 100 次调用时，它会像抽奖一样发放一份特别奖品，但它需要进行额外的计算来算出这份奖品。如果你调用合约 99 次，会发生一种情况，但在第 100 次调用时，情况会大不相同。你为此支付的 Gas 量取决于在你的交易被包含进区块之前，有多少其他交易调用了该函数。也许你的估算是基于自己是第 99 次交易，但就在你的交易被确认之前，其他人抢先完成了第 99 次调用。现在你成了第 100 次调用的那个人，计算量（以及 Gas 成本）就会高得多。

借用以太坊中常用的一个类比，你可以将 gasLimit 想象成汽车（交易）中油箱的容量。你在油箱中加入你认为旅程（验证交易所需的计算）所需的油量。你可以一定程度上估算这个量，但旅途中可能会出现意外变化，比如绕路（更复杂的执行路径），从而增加了燃料消耗。

然而，油箱的类比在某种程度上是有误导性的。它实际上更像是加油站公司的信用账户，你在行程结束后根据实际消耗的油量进行结算。当你传输交易时，首要的验证步骤之一是检查发起账户是否有足够的以太币来支付 $maxFeePerGas \times gasLimit$（或旧版交易的 $gasPrice \times gasLimit$）的费用。但这笔金额直到交易执行完毕才真正从你的账户中扣除。你只需为交易实际消耗的 Gas 付费，但在发送交易之前，你必须拥有足以支付你所设定的最大金额的余额。

## 交易接收者（Transaction Recipient）
交易的接收者在 to 字段中指定。该字段包含一个 20 字节的以太坊地址。该地址可以是一个外部账户（EOA）或一个合约地址。

以太坊不对该字段进行进一步的验证。任何 20 字节的值都被认为是有效的。如果该 20 字节的值对应的地址没有相应的私钥，或者没有相应的合约，交易依然有效。以太坊无法得知一个地址是否是从现有的公钥（进而从私钥）中正确推导出来的。

> [!WARNING]
> 以太坊协议不会验证交易中的接收地址。你可以将资金发送到一个没有对应私钥或合约的地址，从而“销毁”（burning）这些以太币，使其永远无法被花费。验证工作应当在用户界面（UI）层级完成。

将交易发送到错误的地址很可能会销毁所发送的以太币，使其永远无法访问（无法花费），因为大多数地址都没有已知的私钥，因此无法生成签名来花费它。通常认为地址的验证发生在用户界面层级（参见“ERC-55：带校验和的十六进制编码”）。事实上，销毁以太币也有一些正当理由——例如，作为支付通道或其他智能合约中作弊行为的惩罚手段。由于以太币的总量是有限的，销毁以太币实际上将销毁的价值分配给了所有以太币持有者（与他们持有的以太币数量成正比）。

## 交易金额与数据（Transaction Value and Data）
交易的核心“载荷”包含在两个字段中：value（金额）和 data（数据）。交易可以同时包含金额和数据，也可以只包含其中之一，或者两者都不包含。这四种组合都是有效的。

仅包含金额：这是一笔支付（Payment）。仅包含数据：这是一次调用（Invocation）。同时包含金额和数据：既是支付也是调用。既无金额也无数据：这可能只是在浪费 Gas！但协议层面依然允许。

让我们尝试所有这些组合。我们将像之前一样，使用 cast 在 Sepolia 测试网上发送交易。

我们的第一笔交易只包含金额（支付），没有数据载荷：

```Bash
$ cast send --account example vitalik.eth --value 0.001ether --rpc-url https://ethereum-sepolia-rpc.publicnode.com
```
在图 6-4 中，你可以看到发送的金额为 0.001 ether，而数据载荷（在 Etherscan 上显示为 Input Data）是空的（0x00）。
![Figure 6-4](<./images/figure 6-4.png>)
图 6-4. 仅包含金额的交易（支付）

下一个示例同时指定了金额和数据载荷（尽管由于我们是向外部账户 EOA 发送交易，该载荷将被忽略）：
```Bash
$ cast send --account example vitalik.eth 0x0001 --value 0.001ether --rpc-url https://ethereum-sepolia-rpc.publicnode.com
```
在图 6-5 中，你可以看到输入数据（Input Data）现在包含了一些值，具体为 `0x0001`。
![Figure 6-5](<./images/figure 6-5.png>)
图 6-5. 同时包含金额和数据的交易
接下来的交易包含数据载荷，但指定的金额为零：
```Bash
$ cast send --account example vitalik.eth 0x0001 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
```
图 6-6 显示的确认界面表明，交易中发送的以太币金额为零，而数据载荷等于 `0x0001`。
![Figure 6-6](<./images/figure 6-6.png>)
图 6-6. 仅包含数据的交易（调用）
最后，最后一笔交易既不包含发送金额，也不包含数据载荷：
```Bash
$ cast send --account example vitalik.eth --rpc-url https://ethereum-sepolia-rpc.publicnode.com
```
图 6-7 展示了我们这笔发送了零以太币且载荷为空的交易。
![Figure 6-7](<./images/figure 6-7.png>)
图 6-7. 既无金额也无数据的交易

## 向外部账户 (EOA) 和合约发送金额（Transmitting Value to EOAs and Contracts）
当你构建一笔包含金额（value）的以太坊交易时，这就等同于一笔支付。这类交易的行为取决于目标地址是否为合约地址。

对于 EOA 地址——或者更准确地说，对于任何在区块链上未被标记为合约的地址——以太坊将记录一次状态变更，将你发送的金额增加到该地址的余额中。如果该地址之前从未出现过，它将被添加到客户端的状态表示中，其余额将被初始化为你支付的金额。

如果目标地址（to）是一个合约（或者是此前通过 EIP-7702 交易委托了合约的 EOA），那么 EVM 将执行该合约，并尝试调用交易数据载荷（data payload）中指定的函数。如果你的交易中没有数据，EVM 将调用一个回退函数（fallback function）；如果该函数是可支付的（payable），则会执行它以决定下一步操作。如果没有回退函数，那么交易的效果将是增加该合约的余额，就像向钱包支付一样。

合约可以通过在函数被调用时立即抛出异常，或根据函数中编写的逻辑条件来拒绝接收付款。如果函数成功终止（未产生异常），那么合约的状态将更新，以反映合约以太币余额的增加。

## 向外部账户 (EOA) 或合约传输数据载荷（Transmitting a Data Payload to an EOA or Contract）
当你的交易包含数据（data）时，它极有可能是发往一个合约地址的。这并不意味着你不能向 EOA 发送数据载荷——在以太坊协议中这完全是有效的。然而，在这种情况下，对数据的解释完全取决于你用来访问该 EOA 的钱包。以太坊协议本身会忽略这些数据。大多数钱包也会忽略其控制的 EOA 收到的交易中的任何数据。未来可能会出现允许钱包像合约一样解释数据的标准，从而允许交易调用在用户钱包内运行的函数。关键区别在于，EOA 对数据载荷的任何解释都不受以太坊共识规则的约束，这与合约执行完全不同。

目前，我们假设你的交易是将数据发送到合约地址。在这种情况下，数据将被 EVM 解释为合约调用。大多数合约将这些数据具体用作函数调用，即调用指定的函数并将任何编码后的参数传递给该函数。

发送给符合 ABI（应用二进制接口） 标准合约（你可以假设所有合约都符合该标准）的数据载荷，是以下内容的十六进制序列化编码：

**函数选择器**（Function Selector） 
函数原型（prototype）的 Keccak-256 哈希值的前 4 个字节。这使得合约能够明确识别你想调用哪个函数。

**函数参数**（Function Arguments） 
根据 ABI 规范中定义的各种基本类型的规则进行编码的函数参数。

在示例 2-1 中，我们定义了一个用于提现的函数：
```
function withdraw(uint256 _withdrawAmount, address payable _to) public {
```
一个函数的原型（prototype）被定义为一个字符串，包含函数名称，后接其每个参数的数据类型，参数类型被包含在括号内并用逗号分隔。这里的函数名是 withdraw，它接受两个参数：

* `_withdrawAmount`：其类型为 `uint256`

* `_to`：其类型为 `address`

因此，withdraw 的函数原型应为：
```
withdraw(uint256,address)
```
> [!NOTE]
> 在 Solidity 中，payable 关键字用于指示地址可以接收以太币，但它不参与函数选择器的计算。在函数原型中仅包含基础类型 address。

让我们计算该字符串的 Keccak-256 哈希值：
```Bash
$ cast keccak256 "withdraw(uint256,address)"
0x00f714ce93c4a188ecc0c802ca78036f638c1c4b3ee9b98f3ed75364b45f50b1
```
该哈希的前 4 个字节是 0x00f714ce。这就是我们的**函数选择器**（Function Selector）值，它将告知合约我们要调用哪个函数。

接下来，让我们计算作为参数传递的 _withdrawAmount 和 _to 的值。我们想要提现 0.000001 ether 到地址 vitalik.eth（其对应的地址为 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045）。我们将它们与上一步计算出的函数选择器编码在一起，以获得最终的数据载荷（Data Payload）（也称为 calldata）：
```Bash
$ cast calldata "withdraw(uint256,address)" 0.000001ether 0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
0x00f714ce000000000000000000000000000000000000000000000000000000e8d4a51000000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045
```
这就是我们交易的数据载荷，它调用了 `withdraw` 函数，并请求将 0.000001 ether 作为 `withdraw_amount` 提取到 `vitalik.eth` 指向的地址中。

## 特殊交易：合约创建（Special Transaction: Contract Creation）
有一种我们应当提到的特殊情况，即在区块链上创建并部署新合约以供未来使用的交易。合约创建交易的识别标志是 to 字段为空（null）。当 to 字段为空时，以太坊协议会将其解释为部署新合约的请求，而 data 字段中提供的则是该合约的字节码（bytecode）。

值得注意的是，零地址（0x0000000000000000000000000000000000000000）是一个截然不同的概念：它是一个有效的 20 字节地址，可以接收以太币。向零地址发送交易并不会创建合约，它只是像其他交易一样将以太币转移到该地址。零地址有时会收到来自各种地址的付款。这有两种解释：要么是操作失误导致以太币丢失，要么是故意的以太币销毁（通过发送到无法花费的地址来故意销毁以太币）。然而，如果你想进行有意的以太币销毁，你应该向网络明确你的意图，并使用专门指定的销毁地址：
```
0x000000000000000000000000000000000000dEaD
```
> [!WARNING]
> 任何发送到指定销毁地址的以太币都将变得无法花费，并永久丢失。

合约创建交易只需包含一个 data 载荷，该载荷包含用于创建合约的已编译字节码。此类交易的唯一效果就是创建合约。如果你想为新合约设置初始余额，可以在 value 字段中包含一定数量的以太币，但这完全是可选的。如果你向合约创建地址发送了金额（以太币）但没有数据载荷（没有合约代码），其效果等同于发送到销毁地址——因为没有合约可以接收这笔款项，以太币将会丢失。

例如，我们可以通过手动创建一笔 to 字段为空且 data 载荷为合约字节码的交易，来创建第 2 章中使用的 Faucet.sol 合约。首先，合约需要编译为字节码表示。这可以使用 Solidity 编译器（solc）完成：
```Bash
$ solc --bin Faucet.sol
Binary:
6080604052348015600e575f5ffd5…0033
```
同样的信息也可以从 Remix 在线编译器中获得。

现在我们可以使用二进制输出来创建交易：
```Bash
$ cast send --account example --rpc-url https://ethereum-sepolia-rpc.publicnode.com --create 6080604052348015600e575f5ffd5…0033
```
一旦合约发布，我们就可以在 Etherscan 区块浏览器上看到它，如图 6-8 所示。
![Figure 6-8](<./images/figure 6-8.png>)
图 6-8. Etherscan 上的合约创建交易
我们可以通过查看交易收据（使用交易哈希进行引用）来获取有关该合约的信息：
```Bash
$ cast receipt 0xa6b077d7d0ea21ff5f32a5a7243a81f0ab63e3b5e09c8e388c230fb067967cbb \
    --rpc-url https://ethereum-sepolia-rpc.publicnode.com
blockHash               0x6eb071eac79a84793321b086af96b32c1d861f04b0efc7354d0f6b8d5a8fa36a
blockNumber             7135544
contractAddress         0x4658eD241397F08cba8d5F3a69c7774cebE7f67F
cumulativeGasUsed       28390874
effectiveGasPrice       8867964529
from                    0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
gasUsed                 145123
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root
status                  1 (success)
transactionHash         0xa6b077d7d0ea21ff5f32a5a7243a81f0ab63e3b5e09c8e388c230fb067967cbb
transactionIndex        136
type                    2
blobGasPrice
blobGasUsed            
authorizationList
```

这包括合约的地址（参见 contractAddress 字段），我们可以使用该地址按照前一节所示的方式向合约发送资金或从合约接收资金。

让我们首先将新创建的合约地址保存到一个变量中：
```Bash
$ CONTRACT_ADDRESS=0x4658eD241397F08cba8d5F3a69c7774cebE7f67F
```
现在我们可以为该合约注入一些以太币：
```Bash
$ CONTRACT_ADDRESS=0x4658eD241397F08cba8d5F3a69c7774cebE7f67F
```
最后，让我们使用之前计算的数据载荷（data payload）来调用 withdraw 函数，将 0.000001 ether 提取到 vitalik.eth 地址：
```Bash
$ cast send --account example $CONTRACT_ADDRESS \
0x00f714ce000000000000000000000000000000000000000000000000000000e8d4a51000000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa96045 \
  --rpc-url https://ethereum-sepolia-rpc.publicnode.com
```
过一段时间后，这两笔交易都可以在 Etherscan 上看到，如图 6-9 所示。
![Figure 6-9](<./images/figure 6-9.png>)
图 6-9. 合约注资与提现交易

## 数字签名（Digital Signatures）
到目前为止，我们还没有深入探讨数字签名的细节。在本节中，我们将研究数字签名是如何工作的，以及如何利用它在不泄露私钥的情况下证明对私钥的所有权。

### 椭圆曲线数字签名算法（ECDSA）
以太坊中使用的数字签名算法是椭圆曲线数字签名算法（ECDSA）。它基于椭圆曲线私钥-公钥对，正如“椭圆曲线密码学解释”中所描述的那样。

在以太坊中，数字签名有三个用途（见下文侧栏）。首先，签名证明了私钥的所有者（暗示也是以太坊账户的所有者）已授权支付以太币或执行合约。其次，它保证了不可否认性：授权证明是不可推翻的。第三，签名证明交易数据在签名后没有、也不可能被任何人修改。

#### 数字签名的定义
根据维基百科的说法，数字签名是一种用于表现数字消息或文档真实性的数学方案。一个有效的数字签名使接收者有理由相信：消息是由已知的发送者创建的（身份验证），发送者不能否认发送过该消息（不可否认性），且消息在传输过程中未被篡改（完整性）。

### 数字签名如何工作
数字签名是一种由两部分组成的数学方案。第一部分是使用私钥（签名密钥）从消息（在我们的案例中是交易）中创建签名的算法。第二部分是允许任何人仅使用消息和公钥来验证签名的算法。

#### 创建数字签名
在以太坊的 ECDSA 实现中，被签名的“消息”是交易，或者更准确地说，是交易中经过 RLP 编码数据的 Keccak-256 哈希值。签名密钥是 EOA 的私钥。其结果就是签名：

---
[^1]: 也可以理解为经典交易，不过在以太坊社区中多用遗留交易。
[^2]: 可以简单地理解为交易计数，但是社区更喜欢直接引用原词。
