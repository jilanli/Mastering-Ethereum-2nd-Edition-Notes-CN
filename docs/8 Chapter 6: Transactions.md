# 第六章： 交易

交易是由外部账户（EOA）发起的签名消息，经由以太坊网络传输，并最终记录在以太坊区块链上。这个基本定义背后隐藏着许多令人着迷的细节。换个角度来看，交易是唯一能够触发状态变更或导致合约在以太坊虚拟机（EVM）中执行的行为。以太坊是一个全球唯一的单体状态机，而交易正是让这个状态机“跳动”并改变其状态的脉搏。合约不会自行运行，以太坊也不会自动运转——一切始于交易。

在本章中，我们将剖析交易，展示它们的工作原理并审视其细节。需要注意的是，本章的大部分内容是针对那些有兴趣在底层管理交易的人（例如正在开发钱包应用的开发者）。如果你习惯于使用现有的钱包应用，则无需担心这些细节，尽管你可能会发现这些底层机制非常有趣。

## 交易结构（The Structure of a Transaction）
首先，让我们看看交易在以太坊网络中进行序列化和传输时的基本结构。每个接收到序列化交易的客户端都会使用其内部的数据结构将其存储在内存中，并可能添加一些网络序列化交易本身并不存在的元数据。网络序列化（Network Serialization）是交易唯一的标准形式。在以太坊运行初期，只有单一类型的交易。但 EIP-2718 引入了一种处理不同交易类型的方法，并允许以不同的方式处理它们。具体而言，每笔交易都以一个指定交易类型的单字节（Byte）开头：
$$transaction = tx\_type \ || \ tx\_payload$$
在编写本书时（2025 年 6 月），共存在五种交易类型，如表 6-1 所示。

表 6-1. EIP-2718 交易类型
![Table 6-1](<./images/table 6-1.png>)

让我们详细分析这些交易组成部分。

### 遗留交易（Legacy Transactions）
一笔遗留交易[^1]是一个序列化的二进制消息，包含以下数据：
* **链 ID** (Chain ID)：你发送交易的目标网络标识。它是通过 EIP-155 引入的，作为一种简单的重放攻击保护机制。
* **Nonce**：由发起账户（EOA）发出的序列号，用于防止消息重放。[^2]
* **Gas价格** (Gas price)：发起者愿意支付的单位 Gas 单价（以 wei 为单位）。
* **Gas限制** (Gas limit)：发起者愿意为这笔交易购买的最大 Gas 数量。请注意，你只需为实际消耗的 Gas 付费，Gas 限制仅代表你的出价上限。
* **接收者** (Recipient)：目标以太坊地址。
* **数额** (Value)：发送到目的地的以太币数量。
* **数据** (Data)：可变长度的二进制数据负载（Payload）。
* **v, r, s**：发起账户（EOA）的 ECDSA 数字签名的三个组成部分。

交易消息的结构使用**递归长度前缀（RLP）**编码方案进行序列化。RLP 是专为以太坊设计的，旨在实现简单且字节精准的数据序列化。以太坊中的所有数字都编码为大端（big-endian）整数，长度为 8 位（1 字节）的倍数。

请注意，为了清晰起见，这里显示了字段标签（如 to、gas limit 等），但它们并不属于交易序列化数据的一部分。序列化数据仅包含 RLP 编码后的字段值。通常，RLP 不包含任何字段分隔符或标签。它使用长度前缀来识别每个字段的长度，超出定义长度的内容即属于结构中的下一个字段。

虽然这是实际传输的交易结构，但大多数内部表示和用户界面可视化都会添加一些从交易或区块链中派生出的额外信息。关于“From”地址：你可能会注意到地址数据中没有“from”字段。这是因为发起账户（EOA）的公钥可以从 ECDSA 签名的 $v, r, s$ 分量中派生出来。随后，地址又可以从公钥中派生。当你看到交易显示 from 字段时，那是可视化软件自行添加的。其他元数据：客户端软件经常添加的其他元数据包括块号（一旦交易发布并被包含在区块链中）和交易 ID（计算得出的哈希值）。同样，这些数据是从交易中派生出来的，并不构成交易消息本身的一部分。

### EIP-2930 交易
[EIP-2930](https://oreil.ly/1dSza) 交易是首个使用 EIP-2718 类型化交易信封（Typed Transaction Envelope）的交易，其交易类型标识为 0x01。它们在本质上与之前的交易类型相同，但增加了一个名为 访问列表（Access List） 的新字段。这是一个由（地址、存储槽）组成的数组，允许用户为交易将要触达的地址和存储槽进行“预付费”。通过这种方式，在以太坊虚拟机（EVM）的执行过程中，用户被收取的 Gas 费用会更低。

>[!NOTE]
>更准确地说，访问列表中包含的地址及其存储槽分别被计入 accessed_addresses（已访问地址）和 accessed_storage_keys（已访问存储键）中。EVM 利用这些列表来区分热访问（Warm Access）和冷访问（Cold Access）。冷访问收取的 Gas 远高于热访问。例如，SLOAD 操作码在访问热存储槽时仅收取 100 Gas，而冷访问则需收取 2,100 Gas。

这种新交易类型的引入主要是为了解决由 EIP-2929 引起的问题。EIP-2929 提高了状态访问操作码的 Gas 成本，导致一些智能合约在处理交易时因 Gas 不足（Out-of-Gas）错误而失败。通过引入访问列表，用户可以为其交易将访问的地址和存储槽预先付费，从而防止这些执行失败。

### EIP-1559 交易
[EIP-1559](https://oreil.ly/ZBON6) 交易于 2021 年 8 月 5 日在“伦敦”硬分叉中引入，其交易类型标识为 0x02。它们通过引入一个新的协议参数——基础费（Base Fee），彻底改变了以太坊的手续费市场结构。

基础费代表了在以太坊网络上发送交易所需支付的最低费用。在本次升级中，区块 Gas 限制（Block Gas Limit）从 1,500 万翻倍至 3,000 万 Gas，并引入了等于 Gas 限制一半的区块 Gas 目标（Block Gas Target），即 1,500 万 Gas。其核心设计理念是保持以太坊网络平均负载与以往持平，但在需要时允许区块容量变得更大（最高可达两倍）。

为了使区块的平均 Gas 使用量维持在 1,500 万，基础费并不是一个固定值：它会根据区块的利用率动态调整。如果一个区块的实际 Gas 使用量高于目标值，基础费就会增加；如果低于目标值，基础费则会减少。

区块 Gas 限制（几乎）总是会在特定区块被调整为固定的、圆整的数值：1,000 万、1,250 万、1,500 万以及 3,000 万，具体趋势如图 6-1 所示。事实上，尽管验证者（以及旧 PoW 共识协议下的矿工）可以在每个区块微调 Gas 目标（这会直接转化为 Gas 限制），但区块 Gas 限制是一个至关重要的数值，通常所有人都会遵循核心开发者的建议。
![Figure 6-1](<./images/figure 6-1.png>)
图 6-1. 以太坊区块 Gas 限制历史演进
基础费（Base Fee）并不会流向创建区块的验证者（或矿工）；相反，它们会被立即销毁（Burned），从而减少以太坊的总供应量。同时，协议引入了一项新费用——优先费（Priority Fee），你可以将其理解为支付给验证者（或矿工）的小费，用以激励他们将你的交易包含在下一个区块中。
>[!TIP]
>理论上，你可以创建仅支付强制性基础费而“零小费”的交易。协议并不强求你向验证者支付小费。但在现实操作中，你应当始终包含优先费，以确保交易能在合理的时间内得到确认。需要注意的是，钱包通常会自动为你处理基础费和优先费，并将其设置为合适的数值。

一笔 EIP-1559 交易是一个序列化的二进制消息，包含以下数据：

* **链 ID** (Chain ID)：与遗留交易相同。
* **Nonce**：与遗留交易相同。
* **每单位 Gas 的最大优先费** (Max priority fee per gas)：发起者愿意直接支付给验证者的 Gas 单价（以 wei 为单位），作为将其交易纳入区块的小费。
* **每单位 Gas 的最大总费用** (Max fee per gas)：发起者愿意支付的总 Gas 单价（以 wei 为单位），包含基础费和优先费。
* **Gas 限制** (Gas limit)：与遗留交易相同。
* **接收者** (Recipient)：与遗留交易相同。
* **访问列表** (Access list)：与 EIP-2930 交易相同。
* **数额** (Value)：与遗留交易相同。
* **数据** (Data)：与遗留交易相同。
* **v, r, s**：与遗留交易相同。

与所有交易类型一样，其消息结构采用 RLP 编码方案进行序列化。

### EIP-4844 交易
[EIP-4844](https://oreil.ly/JMJmB) 交易随 2024 年 3 月 13 日的“坎昆（Cancun）”硬分叉引入，交易类型标识为 0x03。我们在第四章“KZG 承诺”一节中已经提到过它们，并将在第十六章进行深入探讨。这类交易也被称为携带 Blob 的交易（blob-carrying transactions），因为它们带有一个“边车（sidecar）”——即 Blob。每个 Blob 包含大量数据（约 131,000 字节），这些数据无法被 EVM（以太坊虚拟机）直接访问，但其对应的“承诺（commitment）”是可以被访问的。

为了处理 Blob，协议引入了一种新型 Gas——Blob Gas。它与普通 Gas 完全分离且相互独立。尽管它深受 EIP-1559 的启发并遵循类似的定价规则，但它有自己的目标调节逻辑：如果区块中使用的 Blob Gas 超过了目标值，Blob Gas 的价格就会上涨；反之则下降。

其序列化二进制消息格式与 EIP-1559 类似，但新增了两个字段：

* **每单位 Blob Gas 的最大费用** (Max fee per blob gas)：发起者愿意为 Blob 支付的 Blob Gas 单价（以 wei 为单位）。
* **Blob 版本化哈希列表** (Blob versioned hashes)：一个 32 字节值的列表，代表与该交易所携带的每个 Blob 相关联的 KZG 承诺的版本化哈希。

>[!NOTE]
>随着坎昆硬分叉和 EIP-4844 交易的引入，区块头增加了两个新元素：
>
> **已使用的 Blob Gas** (Blob gas used)：
>
>区块内所有 EIP-4844 交易消耗的 Blob Gas 总量。
>
> **超额 Blob Gas** (Excess blob gas)：
>
>在该区块之前，累积消耗的超出目标值的 Blob Gas 总量。

### EIP-7702 交易
[EIP-7702](https://oreil.ly/W_28X) 交易随 2025 年 5 月 7 日的“Pectra”硬分叉引入，交易类型标识为 0x04。它们允许外部账户（EOA）在自己的账户中设置代码。传统上，EOA 的代码字段是空的；它们只能发起交易，除非与智能合约交互，否则无法执行复杂操作。EIP-7702 改变了这一现状，使 EOA 能够执行如下操作：

* **批量处理**（Batching）：允许同一用户在单笔原子交易中完成多个操作。例如，先进行 ERC-20 授权（Approve），紧接着完成资产消费。这是许多去中心化交易所中非常常见的流程。
* **代付**（Sponsorship）：账户 X 可以代表账户 Y 支付交易费用。
* **权限降级**（Privilege deescalation）：用户可以签署子密钥并赋予其特定的受限权限，这些权限远弱于对账户的全局访问权。例如，限制每天只能消费总余额的 1%，或者只能与特定的应用程序交互。

底层的实现细节相当复杂，如果你感兴趣，我们建议阅读 EIP 官方网站。不过，从高层概述来看，它的原理简单却非常强大。EIP-7702 允许 EOA 为自己分配一个委派标识符（delegation designator）。该标识符指向一个（已存在于以太坊主网上的）智能合约。当一笔交易发送至该 EOA 时，它会执行指定地址的代码，就好像那是该 EOA 自身的实际代码一样，如图 6-2 所示。
![Figure 6-2](<./images/figure 6-2.png>)
图 6-2. EIP-7702 委派机制


## 交易 Nonce（The Transaction Nonce）
Nonce 是交易中最重要但也最常被误解的组成部分之一。在以太坊“黄皮书”中，它的定义如下：

> Nonce：一个标量值，等于从该地址发送出的交易数量；或者对于有关联代码的账户（合约账户）而言，是指由该账户创建的合约数量。

严格来说，Nonce 是发起地址的一个属性——即它仅在发送地址的语境下才有意义。然而，Nonce 并不作为账户状态的一部分显式地存储在区块链上，而是通过计算从该地址发出的已确认交易数量动态得出的。

Nonce 的存在对于两个场景至关重要：一是确保交易按创建顺序被包含的可用性功能，二是防止交易重复攻击的核心安全功能。让我们分别为这两个功能看一个示例场景：

场景1：顺序执行

假设你想进行两笔交易：一笔是 6 ETH 的重要付款，另一笔是 8 ETH 的付款。你先签署并广播了 6 ETH 的交易，因为它更重要。随后你签署并广播了 8 ETH 的交易。遗憾的是，你忽略了账户里只有 10 ETH，因此网络无法同时接受这两笔交易：其中一笔必然失败。

因为你先发送了更重要的 6 ETH 交易，你自然希望这笔成功，而 8 ETH 的被拒绝。但在像以太坊这样的去中心化系统中，节点接收交易的顺序是随机的，无法保证某个节点一定会先收到哪一笔。如果没有 Nonce，哪一笔被接受将变成一场随机的博弈。

但是，有了 Nonce 之后，你发送的第一笔交易 Nonce 为 3（假设），而 8 ETH 交易的 Nonce 就是 4。即便节点先收到了 Nonce 为 4 的交易，它也会将其忽略，直到 Nonce 0 到 3 的交易全部处理完毕。

场景 2：重放保护

假设你的账户里有 100 ETH。你从网上买了一个心仪的零件并支付了 2 ETH。你签署并广播了这笔交易。如果没有 Nonce，当你第二次给同一个地址发送 2 ETH 时，这笔交易看起来和第一笔完全一样。

这意味着任何在网络上看到你交易的人（包括收款人或你的对手），只需简单地复制并粘贴你原始交易的签名数据，就可以一遍又一遍地“重放”这笔交易，直到榨干你账户里所有的钱。然而，由于交易数据中包含了 Nonce 且每笔交易递增，每一笔交易都是唯一的。即使是向同一地址发送相同金额，其 Nonce 也不同，这让任何人都不可能“复制”你的支付行为。

总结，需要特别指出的是，对于以太坊这种基于账户模型的协议，使用 Nonce 是至关重要的；这与比特币协议所使用的 UTXO（未花费交易输出） 机制形成了鲜明对比。

### 追踪 Nonce（Keeping Track of Nonces）
在本节及后续章节中，我们将使用 Foundry 工具套件——特别是 cast 工具。它能以非常便捷的方式与区块链进行交互。如果你想复现以下示例，请务必安装它。

首先，我们需要设置本章将要使用的钱包。打开终端窗口并输入：

```Bash
$ cast wallet new
Successfully created new keypair.
Address:     0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
Private key: 0xd6d2672c6b4489e6bcd4e93b9af620fa0204b639b7d7f93765479c0846be0b58
```
> [!CAUTION]
> 如果你向上述地址发送资金，那是在浪费钱，因为其私钥已公开，任何人都可以利用它将资金转走。

现在，我们需要将私钥导入电脑的密钥库（Keystore），以便稍后轻松调用：

```Bash
$ cast wallet import example \
    --private-key 0xd6d2672c6b4489e6bcd4e93b9af620fa0204b639b7d7f93765479c0846be0b58
Enter password:
`example` keystore was saved successfully. Address: 0x7e41354afe84800680ceb104c5fc99ecb98a25f0
```
你可以选择（并推荐）设置一个密码，在后续使用该账户创建交易时将需要输入此密码。现在我们已正确设置，但账户里还没有任何 ETH。

你可以随时检查余额。首先，获取与账户关联的地址：
```Bash
$ cast wallet address --account example
Enter keystore password:
0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
```
接着，你可以向区块链查询余额。在本章的所有示例中，我们将使用以太坊 Sepolia 测试网：
```Bash
$ cast balance 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0
```
> [!NOTE]
> 请留意上一个 cast 命令中的 --rpc-url 标志。它应该指向你感兴趣的区块链的 RPC 端点。可靠的 RPC 端点通常需要付费，但如果你只是想进>行实验（如本章所述），有很多免费选项，例如：
>
> * Public Node
> * LlamaNodes
> * ChainList

为了获取一些免费的 Sepolia ETH 代币，你可以使用在线水龙头（Faucet）。我们将使用 Google Cloud Web3 水龙头（如图 6-3 所示），它会提供 0.05 ETH。访问 Ethereum Sepolia Faucet，粘贴你的地址并点击 "Receive 0.05 Sepolia ETH" 按钮。你应该很快就能收到 0.05 ETH。
![Figure 6-3](<./figure 6-3.png>)
图 6-3. Google Cloud Web3 水龙头界面

在成功申领测试币后，你可以验证余额已从 0 变为 $0.05 \text{ ETH}$（即 $5 \times 10^{16} \text{ Wei}$ ）：
```Bash
$ cast balance 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
50000000000000000
```
太好了！现在我们已完全准备就绪，可以回到关于交易 Nonce 的实验中。

从实际操作的角度来看，Nonce 是指从某个账户发出的**已确认（即已上链）**交易的最新计数。要查询 Nonce，你可以使用 cast 询问区块链。只需打开一个新的终端窗口并输入：
```Bash
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0
```

> [!TIP]
> Nonce 是一个从零开始的计数器，这意味着第一笔交易的 Nonce 为 0。在本例中，由于尚未发送过交易，返回值为 0。此外，RPC 响应总是指向下一个可用的 Nonce。例如，如果地址已发送 10 笔交易（Nonce 0-9），查询将返回 10。

我们可以实际动手尝试发送一笔以太币（ETH）了。我们将向 `vitalik.eth` 发送 0.001 ETH，这是以太坊联合创始人 Vitalik Buterin 的 ENS（以太坊域名服务）地址：
```Bash
$ cast send --account example vitalik.eth --value 0.001ether --rpc-url https://ethereum-sepolia-rpc.publicnode.com
blockHash               0xa1171309fd406e44e86be9695a597d2bf5c728738d140b9958cfb50276c32b1b
blockNumber             6989355
contractAddress
cumulativeGasUsed       18009816
effectiveGasPrice       11163498011
from                    0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0
gasUsed                 21000
logs                    []
logsBloom               0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
root
status                  1 (success)
transactionHash         0xeb7bb0322858a4e1ed85271a60d2f8353075dc0bcd0c80448ee1d5ca0bb85def
transactionIndex        60
type                    2
blobGasPrice
blobGasUsed
authorizationList
to                      0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
```

你的钱包会为你管理的每个地址自动追踪 Nonce。只要你仅从单一终端（例如只用这台电脑上的 cast）发起交易，这个过程非常简单。但假设你正在编写自己的钱包软件或某些需要发起交易的应用程序，你该如何管理 Nonce？

当你创建一笔新交易时，你会按顺序分配下一个 Nonce。但在该交易被确认（即正式入块）之前，它并不会计入链上的 Nonce 总数。

为了观察这一现象，我们可以尝试快速连续执行以下命令：
```Bash
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
10
$ cast send --account example vitalik.eth --value 0.001ether --async --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0x85f5b0db44407a6e9252590dc809087a2e232e00a951c9cb8853a109da5ddad4
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
10
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
11
```
如你所见，我们发送的交易并没有立即增加 Nonce 计数；即使在发送交易之后，它依然保持为 10。如果我们等待几秒钟，让网络通信稳定下来并将交易包含在区块中，再次调用 Nonce 查询才会返回预期的数字 11。

> [!NOTE]
> 请留意 `cast send` 命令中使用的 `--async` 标志：如果你不使用它，`cast` 会在终端中持续阻塞，直到交易在区块内得到确认。使用该标志后，它会将交易推送到网络并立即返回交易哈希（Transaction Hash），而无需等待入块。

现在让我们看一个不同的例子：
```Bash
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
11
$ cast send --account example vitalik.eth --value 0.001ether --async --rpc-url https://ethereum-sepolia-rpc.publicnode.com
0x63188aa73247ffe06388a9adf399fa715e42fbc37ca53f77642a7860c80feb9d
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
11
$ cast rpc eth_getTransactionCount 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 pending --rpc-url https://ethereum-sepolia-rpc.publicnode.com
"0xc"
$ cast nonce 0x7e41354AfE84800680ceB104c5Fc99eCB98A25f0 --rpc-url https://ethereum-sepolia-rpc.publicnode.com
12
```

在发送交易之前，我们的 Nonce 计数是 11；发送交易后，我们立即查询新的 Nonce。正如从前一个示例中所预期的，由于交易仍处于内存池（Mempool）中待处理，尚未被包含在区块内，因此 Nonce 尚未更新。然而，我们使用了一种新的查询方式，它实际上能够获取到真实的 Nonce 数量，即便交易尚未得到确认（返回的 0xc 是十六进制的 12）。几秒钟后，交易被添加到区块中，此时调用 cast nonce 就会返回新的正确值。

`cast nonce` 与 `eth_getTransactionCount pending` 之间的区别很简单：前者仅考虑已确认的交易（即已入块的交易），而后者则尝试包含那些仍在内存池中待处理（Pending）的交易。

> [!Warning]
> 在使用 eth_getTransactionCount pending 来统计待处理交易时务必小心。事实上，尽管它试图返回一个地址真实的 Nonce 值，但没有任何办法能百分之百确定内存池中是否还隐藏着其他等待确认的待处理交易。
>
> 公共内存池（Public Mempool）并不是一个全球统一的实体。 每个节点都有自己的内存池：这是一种用于存放待处理交易的动态仓库，在它们被正式确认上链前进行临时保存。每个节点都可以通过设置不同的规则（例如不同的最低 Gas 价格限制或账户限制）来定制自己接受或拒绝新交易的逻辑。虽然 RPC 服务商拥有庞大的节点网络，并且理论上应该对所有待处理交易拥有（近乎）完整的视角，但你仍应警惕，不要将该返回值视为 100% 准确。

### Nonce 间隙、重复 Nonce 与确认（Gaps, Duplicates, and Confirmation）
如果你是通过编程方式创建交易，追踪 nonce 就变得至关重要，特别是当你试图从多个独立的进程同时发起交易时。

以太坊网络根据 nonce 严格顺序地处理交易。这意味着，如果你发送了一笔 nonce 为 0 的交易，接着又发送了一笔 nonce 为 2 的交易，那么第二笔交易不会被包含在任何区块中。它会被存储在内存池（mempool）中，此时以太坊网络会等待缺失的 nonce 出现。所有节点都会假设缺失的 nonce 只是被延迟了，而 nonce 为 2 的交易只是乱序到达了。

如果你随后发送了缺失的 nonce 1，那么两笔交易（nonce 1 和 2）都将被处理并包含在区块中（当然前提是它们合法）。一旦你填补了间隙，网络就能打包之前保存在内存池中的乱序交易。

这意味着，如果你按顺序创建了几笔交易，而其中一笔没有被正式包含在区块中，那么所有后续交易都会被“卡住”，等待那个缺失的 nonce。一笔交易可能因为无效或 gas 不足而产生无意的“间隙”。要让交易重新流动，你必须发送一笔具有缺失 nonce 的有效交易。你同样需要警惕：一旦这个“缺失”的 nonce 被网络验证，所有已广播的后续 nonce 交易都会依次生效——撤回一笔已发送的交易是不可能的！

另一方面，如果你不小心重复了 nonce —— 例如发送了两笔具有相同 nonce 但收款人或金额不同的交易 —— 那么其中一笔会被确认，另一笔会被拒绝。哪一笔被确认取决于它们到达第一个接收它们的验证节点的顺序 —— 也就是说，这具有相当大的随机性。

如你所见，追踪 nonce 是必不可少的。如果你的应用程序无法正确管理这一过程，就会遇到麻烦。遗憾的是，正如我们将在下一节看到的，如果你尝试并发执行此操作，情况会变得更加复杂。

### 并发、交易发起与 Nonce（Concurrency, Transaction Origination, and Nonces）
并发是计算机科学中一个复杂的方面，它有时会出人意料地出现，尤其是在像以太坊这样去中心化和分布式的实时系统中。

简单来说，并发是指多个独立系统同时进行计算。这些系统可以在同一个程序中（如多线程）、同一个 CPU 上（如多进程），或者在不同的计算机上（如分布式系统）。从定义上讲，以太坊是一个允许操作（节点、客户端、DApps）并发的系统，但通过共识机制强制执行单体状态（Singleton State）。

现在，想象一下你有多个独立的钱包应用程序，它们正在从同一个或多个地址生成交易。这种情况的一个例子是交易所处理来自其热钱包（hot wallet）的提现。理想情况下，你会希望有多台计算机处理提现，这样它就不会成为瓶颈或单点故障。然而，这很快就会变得棘手，因为多台计算机产生提现会导致一些棘手的并发问题，其中最核心的就是 nonce 的选择。多台从同一个热钱包账户生成、签名并广播交易的计算机如何进行协调？

你可以使用一台计算机按先来后到的顺序，为负责签名交易的计算机分配 nonce。然而，这台计算机现在成了单点故障（single point of failure）。更糟的是，如果分配了几个 nonce，但其中一个由于处理该交易的计算机发生故障而从未被使用，那么所有后续交易都会被卡住。

另一种方法是生成交易但不分配 nonce（因此不签名——请记住，nonce 是交易数据的组成部分，因此必须包含在验证交易的数字签名中）。然后，你可以将它们排队发送到一个负责签名并追踪 nonce 的单一节点。但同样，这会成为流程中的一个瓶颈：在高负载下，签名和追踪 nonce 的部分最容易发生拥塞，而生成未签名交易的部分其实并不真正需要并行化。你虽然实现了一定程度的并发，但在流程的关键部分却缺乏并发能力。

最终，这些并发问题，加上在独立进程中追踪账户余额和交易确认的难度，迫使大多数实现方案趋向于规避并发并创造瓶颈，例如使用单一进程处理交易所的所有提现交易，或者设置多个完全独立工作的热钱包进行提现，仅需定期进行余额重平衡（rebalanced）。

## Transaction Gas
---
[^1]: 也可以理解为经典交易，不过在以太坊社区中多用遗留交易。
[^2]: 可以简单地理解为交易计数，但是社区更喜欢直接引用原词。
