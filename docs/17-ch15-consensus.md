# 第十五章：共识(Consensus)

贯穿本书，我们一直在讨论共识规则 (Consensus Rules) —— 即为了让系统以去中心化且确定性的方式运行，所有人必须共同遵守的规则。
在计算机科学中，“共识”这一术语早于区块链出现，它涉及分布式系统中同步状态的更广泛问题，即让分布式系统中的不同参与者最终都对单一的全局状态达成一致。这被称为达成共识。

当涉及到去中心化记录保存和验证的核心功能时，仅靠“信任”来确保状态更新所衍生信息的正确性可能会出现问题。这种普遍挑战在去中心化网络中尤为突出，因为没有中央实体来裁定什么是“真相”。
缺乏中央决策实体正是区块链平台的主要吸引力之一，因为它带来了抵御审查的能力，且访问信息无需依赖权威机构的许可。然而，这些优势是有代价的：
在没有受信任仲裁者的情况下，任何分歧、欺瞒或差异都需要通过其他手段来调和。共识算法 (Consensus Algorithms) 正是用于平衡安全性和去中心化的机制。

在区块链中，共识是系统的关键属性。简而言之，这关乎资金安全！因此，在区块链语境下，共识是指在保持去中心化的同时，能够达成共同状态的能力。
换句话说，共识旨在产生一个“有规则但无统治者”的系统。没有任何个人、组织或团体处于“掌权”地位；相反，权力和控制权分散在广泛的参与者网络中，通过遵守规则和保持诚实来服务于其自身的利益。

在对抗性环境下，在不集中控制权的前提下，跨分布式网络达成共识的能力是所有开放、公共区块链的核心原则。为了应对这一挑战并保持去中心化这一宝贵属性，社区一直在不断尝试不同的共识模型。
本章将探讨这些共识模型及其对以太坊等智能合约区块链的预期影响。

> [Note]
> 虽然共识算法是区块链运作的重要组成部分，但它们运行在最底层的架构中，远低于智能合约的抽象层。换句话说，共识的大部分细节对智能合约编写者来说是不可见的。
> 你不需要了解它们的工作原理就能使用以太坊，就像你不需要了解路由协议的工作原理就能使用互联网一样。

## 共识原则 (Principles of Consensus)

在区块链技术中，特别是在以太坊中，理解共识原则有助于我们理清网络如何维护其完整性并有效地运行。为了更清晰地了解其运作方式，让我们梳理一下其中的核心概念。

### 安全性 (Safety)

在共识机制的语境下，安全性是指确保网络能准确一致地就区块链的当前状态达成共识。这意味着要避免诸如“双花”（Double-spending）和交易冲突等问题，
保持整个网络的一致性。在一个安全的系统中，每个节点对账本历史都有完全相同的视图，其表现就像一个原子化地逐条执行操作的中心化系统。

### 最终确定性 (Finality)

最终确定性是以太坊共识机制中最重要的安全特性之一。它标志着交易被视为已完成且不可逆转的时间点，确保交易一旦被添加到区块链中，
就无法被更改或移除。这种交易的不可逆性为系统注入了极高的信任度，为用户提供了其交易已被永久记录的确定性。 
从本质上讲，最终确定性将安全性的理念付诸实践，使其从一个抽象概念转变为实际保障。它确保了即使网络的不同部分可能有各自的局部视图，
也存在一个不可撤销的协议点，使得区块链的历史变得固定且不可更改。

### 活跃性 (Liveness)

如果说安全性确保了网络中“坏事永远不会发生”，那么活跃性则保证了“好事终究会发生”。换句话说，无论发生什么情况，以太坊网络都会持续处理交易并添加新块。
从另一个角度看，活跃性也可以理解为可用性。在实际操作中，这意味着每当我们向网络中诚实运行的节点提交一笔有效交易时，我们可以预期该交易将被包含在后续的区块中，
从而为区块链的延伸做出贡献。这种对交易包含和处理的预期，对于赢得用户信任和以太坊平台的整体效能至关重要。

### 区块树与分叉 (Block Trees and Forking)

设计一个在任何情况下都同时具备安全性和活跃性的共识协议是不可能的——你必须在两者之间做出取舍（倾向于其中之一）。
虽然以太坊共识协议在网络状况良好时能同时提供安全性和活跃性，但当情况变得混乱时，它会优先考虑活跃性。
它是通过“分叉”的概念来实现这一点的。

在区块链中，每个区块（除了特殊的创世块）都建立在父块之上并指向父块。因此，我们最终得到了一串区块：即区块链。
然而，在实现“分叉共识协议”的链上，这种线性状态在实践中往往并不成立：在现实环境下，我们最终得到的可能更像是一棵区块树（如图 15-1 所示），
而不是单一的链。共识协议的目标就是让网络上的所有节点最终对同一条线性区块序列达成一致。

![Figure 15-1](<./images/figure 15-1.png>)

图 15-1. 区块树结构

区块树中的各个分支被称为分叉 (Forks)。分叉的产生通常是网络延迟、处理延迟、客户端故障或恶意行为的自然结果。

如果我们去查询遵循不同分叉的节点，它们会就系统状态给出不同的答案。这正是“分叉共识协议”的韧性所在：它们在不利条件下不会完全停止运行，
而是选择分叉。 最终，我们希望网络上所有正确的节点都能对历史达成完全一致的线性视图，从而对系统状态达成共识。

协议的分叉选择规则 (Fork Choice Rule) 的任务就是促成这种一致性：给定一个区块树和某些决策标准，
分叉选择规则旨在从所有可用分支中选出那条最有可能最终成为“标准链（Canonical Chain）”的分支。

分叉协议的代价在于，那些遵循了最终未能成为标准链的分支的节点，必须在事后“倒带”它们对现实的认知，撤销最近处理的所有交易，
以便切换到正确的轨道上。这一过程被称为重组 (Reorg) 或回滚 (Reversion)。由于重组具有破坏性，因此协议的设计目标是尽可能将其降至最低。

现在我们可以理解以太坊共识协议中“最终确定性”的威力了：分叉是实现活跃性的强大手段，但为了让网络具备可用性，这种灵活性必须辅以某些安全性保证。

## 工作量证明共识 (Consensus via Proof of Work)

建议译文
工作量证明共识 (Consensus via Proof of Work)

比特币这一原始区块链的创造者发明了一种基于工作量证明 (Proof of Work, PoW) 的共识算法。可以说，PoW 是支撑比特币最重要的一项发明。
PoW 的俗称是“挖矿”，但这导致了人们对共识主要目的的误解。人们通常认为挖矿的目的是创造新货币，因为现实世界中挖矿的目的是开采贵金属或其他资源。
然而，挖矿（以及所有其他共识模型）的真正目的是在确保区块链安全的同时，保持系统控制权的去中心化，并将其分散给尽可能多的参与者。
新铸造货币的奖励是对那些为系统安全性做出贡献的人的一种激励：它是达成目的的手段。从这个意义上说，奖励是手段，而去中心化安全才是目的。

在 PoW 共识中，还存在相应的“惩罚”，即参与挖矿所需的能源成本。这种巨大的能源消耗并非缺陷，而是刻意的安全与激励设计的关键。
如果参与者不遵守规则并赚取奖励，他们就会损失已经投入在挖矿电费上的资金。因此，PoW 共识是风险与回报的细致平衡，驱动参与者出于自身利益而诚信行事。

以太坊最初也是效仿比特币的 PoW 区块链，它使用了一种 PoW 算法，具有相同的基本激励系统和相同的基本目标：在实现控制权去中心化的同时保障区块链安全。
以太坊的 PoW 算法与比特币略有不同，被称为 *Ethash*。

### Ethash：以太坊的 PoW 算法

在以太坊转向权益证明（PoS）之前，它依赖于一种名为 Ethash 的工作量证明（PoW）算法。它是 Dagger-Hashimoto 算法的演进版本，
结合了 Vitalik Buterin 的 Dagger 算法和 Thaddeus Dryja 的 Hashimoto 算法。Ethash 依赖于一个大型数据集的生成和分析，
该数据集被称为有向无环图（Directed Acyclic Graph，简称 DAG）。DAG 的初始大小约为 1 GB，并持续缓慢地线性增长，
每经过一个周期（Epoch，即 30,000 个区块，约 125 小时）更新一次。

DAG 的目的是使 Ethash 算法高度依赖于对大型且频繁访问的数据结构的维护。这反过来旨在使 Ethash 具备 ASIC 抗性（ASIC Resistance），
即增加制造比高性能显卡（GPU）快出几个数量级的专用集成电路（ASIC）矿机的难度。以太坊的创始人希望避免 PoW 挖矿的中心化，
即防止那些拥有芯片制造工厂和巨额预算的人统治挖矿基础设施，从而破坏共识算法的安全性。

使用消费级 GPU 在以太坊网络上执行 PoW 意味着全球有更多的人可以参与挖矿过程。大量的独立矿工意味着挖矿权更加去中心化，
从而避免了像比特币那样，大部分算力集中在少数大型工业化矿场手中的局面。不过，使用 GPU 挖矿的负面影响是它在 2017 年引发了全球显卡短缺，
导致价格飙升并引发了游戏玩家的强烈抗议。这导致零售商出台了限购措施，限制每位客户只能购买一到两块显卡。

直到 2017 年，ASIC 矿机对比特币网络的威胁在很大程度上是不存在的。为以太坊制造 ASIC 需要设计、制造和分发高度定制化的硬件，
这需要投入大量的时间和资金。此外，以太坊开发者长期以来一直计划转向 PoS 共识算法（现已实现），这很可能在很长一段时间内阻止了 ASIC 供应商将以太坊网络作为目标。

## 权益证明共识 (Consensus via Proof of Stake)

从历史上看，PoW 并非第一个被提出的共识算法。在此之前，许多研究者探索过基于财务或名誉权益的构想。更早期的共识模型多为许可型（Permissioned）：
验证者通过权威机构或身份筛选产生，而非公开竞争。例如，实用拜占庭容错（PBFT） 算法需要一组固定或选定的验证者，这种模型至今仍是许多传统分布式系统的基础。

基于 PoW 共识的主要突破在于它实现了无许可性（Permissionless）：任何拥有计算能力的人都可以参与并获得奖励，无需获得加入批准。
这是去中心化的一次巨大飞跃。从某种意义上说，PoW 的发明是为了提供一种替代封闭模型的无许可方案。

随着比特币的成功，许多区块链采用了 PoW。但共识研究的爆发重新激发了人们对 PoS 的兴趣，并带来了重大进展。从一开始，以太坊的创始人们就希望最终迁移到 PoS。
事实上，以太坊最初的 PoW 链内置了一个障碍，即所谓的难度炸弹（Difficulty Bomb），其目的是随着时间的推移缓慢增加挖矿难度，迫使系统向最终转型迈进。
以太坊版的 PoS 虽然是无许可的，但在概念上与早期的基于权威的系统有一定渊源：
在这里，身份和参与权源于质押资产。但由于任何持有 ETH 的人都可以参与，它保留了中本聪设计中“开放获取”的精神。

通常情况下，PoS 算法的运作流程如下： 区块链记录一组验证者名单。任何持有底层加密货币（以太坊中即为以太币）的人都可以通过发送一种特殊的交易，
将他们的以太币锁定到存款合约中，从而成为验证者。验证者轮流提议并对下一个有效区块进行投票，每位验证者投票的权重取决于其存款（即质押量）的大小。
当验证者正确参与协议时，会获得与其质押量成比例的小额奖励。如果他们犯错（如发布不准确或延迟的见证数据），则会受到小额惩罚，数额通常与奖励相当。

但有一种更严重的后果被称为罚没（Slashing），仅当验证者被证明具有恶意行为时才会发生，例如发布相互冲突的见证或对区块进行双重投票。
因此，PoS 通过奖惩机制强制验证者诚实行事并遵守共识规则。PoS 与 PoW 的主要区别在于：PoS 的惩罚是区块链内在的（如损失质押的以太币），而 PoW 的惩罚是外在的（如损失电费开支）。

自 2015 年以太坊发布以来，就一直有转向 PoS 共识协议的意图。2020 年 12 月 1 日，信标链（Beacon Chain） 的启动迈出了实质性的第一步。
最初，信标链是一个“空转”的区块链，允许人们通过在特定存款合约中存入 32 ETH 成为验证者，它仅处理内部验证者及其余额的共识。此时，以太坊主链仍在使用 Ethash。

2022 年 9 月 15 日，合并（The Merge） 硬分叉发生，拥有自身验证者集的信标链将其 PoS 共识协议扩展到了以太坊主链，正式结束了 Ethash 的使用。
不过，当时仍存在一些局限，例如验证者无法提取资金并退出验证者集。这些问题在 2023 年 4 月 12 日的 Shapella（上海+卡佩拉）升级 中得到彻底解决，
标志着以太坊从 PoW 到 PoS 共识协议转型的全面完成。

以太坊所使用的 PoS 共识协议被称为 Gasper。在接下来的章节中，我们将探索它的运作原理，从基础术语开始，
逐步深入到分叉选择规则（LMD-GHOST）和最终性组件（Casper FFG）。最后，我们将通过一个实例来阐明我们讨论过的理论概念。

## PoS 术语 (PoS Terminology)
在本节中，我们将重点介绍以太坊 PoS 共识的组成部分及其术语。

### 节点与验证者 (Nodes and Validators)
节点构成了以太坊网络的骨干。它们相互通信，负责验证共识的遵守情况。验证者负责提议新区块并对其进行投票，它们附属于这些节点。
但与名称所暗示的相反，验证者本身并不实际验证区块；相反，是节点软件在检查区块和交易是否符合协议规则。一个节点可以托管多个验证者，
验证者的职责是通过运行执行客户端（Execution Client）和共识客户端（Consensus Client）共同完成的。
我们将在接下来的章节中详细了解这些职责。

PoS 有一个需要牢记的独特属性：活跃验证者的集合是已知的。这是实现“最终确定性”的关键，因为我们可以识别何时达到了参与者的多数投票。

### 区块与见证 (Blocks and Attestations)
严格的时间管理是以太坊 PoS 的一个重要属性。PoS 中有两个关键的时间间隔：时隙（Slot），时长恰好为 12 秒；
以及周期（Epoch），跨越 32 个时隙。

在每一个时隙（Slot）中，会有且仅有一名验证者被选中来提议区块。在每一个周期（Epoch）期间，每位验证者都有机会以“见证（Attestation）”的形式分享一次其对世界的视图。

一个见证包含了两类投票：
* 链头投票：用于 LMD-GHOST 协议，决定当前哪条链是主链。
* 检查点（Checkpoint）投票：用于 Casper FFG 协议（即“友好最终性小工具”），旨在锁定历史记录。
由于分享见证数据非常消耗带宽，因此这些投票被分布在整个周期的各个时隙中，而不是集中在每个区块产生时，以此来分散工作负载并确保网络负荷可控。

该协议通过针对验证者的奖惩机制来激励区块和见证的产出及准确性。然而，它也容忍**空时隙**（Empty slots）和缺失的见证，
这种情况的发生可能是由于自然原因（例如节点掉线），也可能是出于利润驱动的考量。我们将在后文的“时机博弈（Timing Games）”一节中详细展开讨论。

## LMD-GHOST

LMD-GHOST 是以太坊共识协议的核心部分：它是分叉选择规则（Fork Choice Rule）算法。它负责从节点的本地视图中，
选出其应当认为有效的最新区块。这个区块也被称为链头（Head of the Chain）。

要完全理解其工作原理，你必须了解以太坊 PoS 协议的一些基础概念。在经典且基于 PoW 的共识协议中，
负责创建新区块并将其添加到链上的实体（即矿工）不需要满足任何特殊要求。只要他们发布了一个满足 PoW 难度的区块，
该区块就会被整个网络接受。但在以太坊基于 PoS 的共识协议中，验证者必须质押大量的 ETH 作为抵押品——目前至少为 32 ETH——才能进入验证者集合。

正如我们之前简要提到的，验证者有两项主要职责：

**区块提议 (Block Proposing)**

在每个时隙（Slot）中，会通过伪随机算法选出一名验证者来创建并提议链上的下一个区块。

**创建见证 (Creating Attestations)**

在每个时隙中，比例约为 $1/32$ 的验证者会被选中，发布他们对“谁是当前最佳链头”的投票。这些选票随后以“见证（Attestation）”的形式分享给每一位验证者。

当验证者在见证中投票给某个特定区块时，实际上是在为该区块分配一个“分数”。这个分数恰好等于该验证者发布见证时所质押的 ETH 数量。
不仅如此：这一票不仅是投给该区块的，也是投给该区块所在分叉路径上的所有祖先区块的，如图 15-2 所示。

![Figure 15-2](<./images/figure 15-2.png>)

图 15-2. 投票向祖先传播

你可以认为，投给某个区块的一票会向后传播到其所有的祖先区块。为了让这个概念更加清晰，我们可以为所有分支（Branches）分配一个分数。
如图 15-3 所示，分支是将区块与其父区块连接起来的链路。

![Figure 15-3](<./images/figure 15-3.png>)

图 15-3. 分支的定义

我们将一个分支的分数定义为：该分支末端区块的分数（如图 15-3 中的区块 B）加上其所有直接后代分支分数之和。

图 15-4 展示了一个每个区块分数为 1 的区块轴。
* 分支 E→D：分数恰好等于区块 E 的分数（1），因为它没有后代区块。
* 分支 D→C：其分数为区块 D 的分数（1）加上所有后代分支的分数（分支 E→D 为 1），即 $1 + 1 = 2$。
* 分支 C→B：其分数为区块 C 的分数（1）加上分支 D→C 的分数（2），即 $1 + 2 = 3$。
* 分叉点：此时出现了一个带有区块 C′ 的小分叉。
* 分支 C′→B：分数仅为 1（区块 C′ 的分数），因为 C′ 没有直接后代。
* 分支 B→A：为了计算其分数，我们需要将区块 B 的分数（1）加上分支 C′→B 的分数（1）以及分支 C→B 的分数（3），总计为 $1 + 1 + 3 = 5$。
![Figure 15-4](<./images/figure 15-4.png>)

图 15-4. 分支分数计算示例

图 15-5 包含了一个更复杂的场景，其中存在多个分叉，且每个区块的分数各不相同。请仔细观察该图，确保你理解了每个分支的分数是如何计算出来的。

![Figure 15-5](<./images/figure 15-5.png>)

图 15-5. 复杂的分支评分示例

通过上一个例子，你应该已经清楚地发现：一个区块的分数不仅影响该区块本身，还会随着它向后传播到所有之前的分支，从而影响其所有的祖先区块。其核心思想是，如果一名验证者（以见证的形式）投票支持某个区块作为链头，那么该验证者同时也认为该区块的所有祖先都是有效的，且都是这条正确长链的一部分。

现在，我们终于可以深入探讨 LMD-GHOST 究竟是如何运作的，以及它如何筛选出那个被视为“链头”的区块。让我们先从分析它的名称入手。LMD-GHOST 由两个缩写组成：最新消息驱动 (Latest Message Driven) 和 贪婪最重观测子树 (Greediest Heaviest Observed Subtree)。

### 最新消息驱动 (Latest Message Driven)

在为每个区块和分支分配分数时，只需考虑每位验证者**最近一次（最新）**的见证。这意味着，如果你收到来自验证者 V 的两份见证，你不必计算两次；你需要检查哪一份是最新的，并丢弃另一份。

图 15-6 展示了一名验证者在区块 B 期间发布了一份见证，分享了其认为区块 B 是链头的观点。随后，在区块 F 期间，该验证者再次被选中并发布了一份新的见证，表达了其对区块 F 作为新链头的偏好。当该验证者在区块 F 发布新见证时，其他验证者需要丢弃旧的那份（在区块 B 期间发布的），并仅考虑最新的一份。

![Figure 15-6](<./images/figure 15-6.png>)

图 15-6. 最新消息驱动示例

### 贪婪最重观测子树 (Greediest Heaviest Observed Subtree)
GHOST 是分叉选择规则的核心。所谓的链头区块（Head Block），是指在获得最高投票权重的分叉路径上，那个没有任何后续后代区块的末端区块。

让我们通过实际案例来看看 LMD-GHOST 在真实场景中是如何运作的。图 15-7 展示了我们之前使用过的相同场景。

![Figure 15-7](<./images/figure 15-7.png>)

图 15-7. LMD-GHOST 场景图示

LMD-GHOST 算法总是从一个已被视为“最终确定链”一部分的初始区块开始运行。在系统启动之初，这个起点是创世块（Genesis Block）；但在以太坊完整的 PoS 共识协议中，这个起点会随着**最后一次被“待定”的检查点区块（Last Justified Checkpoint Block）**而不断更新。

这些术语我们将在“Casper FFG：最终性小工具”一节中深入探讨。目前即便你不完全了解什么是“待定检查点”也无妨，你只需要知道：计算永远有一个确定的起点。

在这个示例中，区块 A 是初始块。假设我们是一名验证者，现在需要投出见证票（Attestation），或者被选中提议下一个区块。我们必须运行 LMD-GHOST 算法来确定谁才是当前的链头（Head of the Chain），以便正确地发布见证，或在正确的父块之上构建新块。此时，我们已经收集了截至目前其他验证者的见证，并且遵循协议的 LMD 规则，每位验证者仅保留其最新的一份见证。基于此，我们得出了所有区块的分数，该分数由所有支持该区块的验证者质押权重累加而成。

在此阶段，LMD-GHOST 的运作分为两个步骤：

1. 为全部分支分配分数 按照我们之前解释过的方法，将每个区块的分数向后传播（累加）到之前所有的分支中。图 15-8 展示了所有分支计算完成后的最终分数。

![Figure 15-8](<./images/figure 15-8.png>)

图 15-8. 分支分数计算完成

2. 随后，从初始区块开始，协议中的 GHOST 部分会“贪婪地”选择分数最高的分支持续推进，直到到达一个没有任何后代区块的区块。该区块即为 LMD-GHOST 分叉选择规则返回的链头区块 (Head Block)。

让我们在示例中逐步观察这一过程。如图 15-9 所示，LMD-GHOST 从初始区块 A 开始，由于没有其他备选分支，它立即沿着分支 B→A 进入区块 B。

![Figure 15-9](<./images/figure 15-9.png>)

图 15-9. LMD-GHOST 第一步

现在，有两个分支可供选择：
* 分支 C→B：分数为 8
* 分支 D→B：分数为 6

如图 15-10 所示，GHOST 贪婪地选择了分支 C→B，因为它的分数最高。需要注意的是，即便区块 D 本身的分数高于区块 C 也无关紧要，因为 LMD-GHOST 并不看重单个区块的分数，而是看重该区块所引导的整个分叉路径（子树）的总分。

![Figure 15-10](<./images/figure 15-10.png>)

图 15-10. LMD-GHOST 第二步

我们现在又有两个不同的分支可供选择：
* 分支 E→C：分数为 4
* 分支 F→C：分数为 3

如图 15-11 所示，GHOST 选择了分支 E→C。

![Figure 15-11](<./images/figure 15-11.png>)

图 15-11. LMD-GHOST 第三步

此时，我们只有一个分支可供选择，即分支 H→E。因此，如图 15-12 所示，GHOST 选择了该分支。

![Figure 15-12](<./images/figure 15-12.png>)

图 15-12. LMD-GHOST 第四步

区块 H 没有任何后代区块。LMD-GHOST 算法至此停止运行，并将其作为链的新**链头区块**（Head Block）返回。

### 激励机制 (Incentives)

LMD-GHOST 为严格遵守规则的验证者提供了一系列明确的激励措施，同时也对恶意行为者施加惩罚。在本节中，我们将探讨该协议如何防止恶意参与者违规，并奖励诚信参与者。

验证者需要履行两种不同的职责：
* 提议区块 (Proposing blocks)
* 创建见证 (Creating attestations)

针对这两项职责，LMD-GHOST 包含了多种机制，以确保每个人都按照规则行事。

#### 提议区块 (Proposing Blocks)

当一名验证者被选中为链提议一个新区块时，它必须创建且仅能创建一个有效的区块。通过这种方式，验证者可以获得其所创建区块内所有交易的**优先费（Priority Fees）**总和，外加一部分协议新铸造的 ETH，如图 15-13 所示。

![Figure 15-13](<./images/figure 15-13.png>)

图 15-13. 区块提议奖励

如果验证者试图通过创建多个区块来作弊，协议会明确地通过罚没（Slashing）其一定比例的质押金来进行惩罚。事实上，要成为验证者集合的一员，你必须质押一定数量的 ETH 作为抵押品（目前至少 32 ETH）。这笔质押金的存在，（也是）为了让协议能够通过“罚没”——即扣除部分 ETH——来对你进行惩罚，如图 15-14 所示。

![Figure 15-14](<./images/figure 15-14.png>)

图 15-14. 区块提议罚没示例

> [!Note]
> 这里有一个非常有趣的观察：这种**显式惩罚（Explicit Punishment）**是以太坊 PoS 共识协议与比特币 PoW 协议之间的一个重大区别。在比特币中，只有当矿工的区块成为最重链的一部分时，他们才会获得奖励。如果矿工针对同一个区块高度创建了多个区块，并不会受到显式的惩罚。
> 
> 你可能会好奇这是为什么。这是因为基于 PoW 的系统要求在创建一个有效区块时必须进行大量的计算（即 PoW 过程本身）。如果一名矿工创建了多个区块，他们其实只是在浪费时间和金钱，因为最终只有其中一个区块会进入最重链，他们也只能获得那一个区块的奖励。
> 
> 而以太坊的 PoS 协议不要求验证者通过 PoW 来创建有效区块。这意味着对于验证者来说，创建多个区块几乎是零成本的。这就是为什么我们需要对任何试图以这种方式作弊的行为施加显式惩罚。

#### 创建见证 (Creating Attestations)

当一名验证者被选中以见证的形式分享其对网络状态的视图时，它必须发布且仅能发布一个有效的见证。通过这种操作，验证者可以赚取一笔小额费用（这笔费用远小于区块提议者所获得的奖励），如图 15-15 所示。

![Figure 15-15](<./images/figure 15-15.png>)

图 15-15. 见证奖励图示

如果验证者试图通过创建多个见证或相互矛盾的见证来作弊，协议会明确地通过罚没其一定比例的质押金来进行惩罚，如图 15-16 所示。

![Figure 15-16](<./images/figure 15-16.png>)

图 15-16. 见证罚没图示

如果验证者在相当长的一段时间内持续表现出恶意行为，协议有权将其从验证者集合中强制驱逐（Force-ejecting）。

## Casper FFG：最终性小工具 (The Finality Gadget)

Casper FFG 是一种“元共识（Metaconsensus）”协议。它像是一个运行在底层共识协议之上的覆盖层（Overlay），其目的是为底层协议增加最终性（Finality）。

在以太坊的 PoS 共识中，底层协议是 LMD-GHOST，但它本身并不提供最终性。最终性能够确保区块一旦在链中得到确认，就永远无法被逆转：它们将永久成为区块链的一部分。因此，Casper FFG 的本质功能就是一个“最终性小工具”，我们用它来为 LMD-GHOST 补全最终性。

Casper FFG 利用了 PoS 协议的一个特性：我们明确知道参与者是谁——即管理着质押 ETH 的验证者。这意味着我们可以通过计票来判断何时看到了诚实验证者的多数投票（更准确地说，是管理着大部分质押金的验证者的投票）。在下文中，每位验证者的选票都会根据其质押金额进行加权，但为了简洁起见，我们不会每次都强调这一点。

与所有经典的拜占庭容错（BFT）协议一样，只要故障或敌对验证者的比例低于三分之一，Casper FFG 就能确保最终性。一旦多数诚实验证者宣布某个区块为“最终确认”，所有诚实验证者都会达成一致，使该区块不可逆转。通过要求诚实验证者占总数的三分之二以上，系统确保了共识能够准确代表诚实多数派的观点。值得注意的是，Casper FFG 与传统 BFT 协议的不同之处在于，即使超过三分之一的验证者被攻破，它仍能提供经济最终性（Economic Finality）（更多详情请参阅“可追责的安全性和似是而非的活性”一节）。

### 时段（Epochs）与检查点（Checkpoints）

Casper FFG 通过要求在一个 Epoch 内获得超过三分之二验证者的投票来确保共识。为了高效管理庞大的验证者集合，投票被分配到 32 个 Slot（时隙）中进行，如图 15-17 所示。一个 Epoch 被划分为 32 个 Slot，每个 Slot 通常包含一个区块。每个 Epoch 的第一个 Slot 即为其“检查点（Checkpoint）”。

![Figure 15-17](<./images/figure 15-17.png>)

图 15-17. 时段（Epochs）与检查点（Checkpoints）

为了保持投票焦点的统一，验证者在每个 Epoch 内仅针对一个检查点（即该时段的第一个 Slot）进行一次投票。为了提高效率，这一过程将 Casper FFG 投票与 LMD-GHOST 投票合并进行。其目标是实现检查点的最终确定（Finalization）。需要澄清的是，在 Casper FFG 的语境下，最终确定的对象是检查点而非整个 Epoch，但最终性的效力会延伸至该检查点及其之前的所有内容。

### 证明 (Justification) 与 最终确定 (Finalization)

Casper FFG 与传统的 BFT（拜占庭容错）协议类似，通过两个阶段来确保网络达成一致。首先，验证者针对一个提议的检查点广播并收集意见。如果绝大多数验证者达成一致，该检查点即被证明（Justified），这标志着一种初步的共识。在随后的轮次中，如果验证者确认该“已证明”的检查点获得了广泛支持，它将实现最终确定（Finalization），这意味着该区块已获得一致认可且不可逆转。这一过程强调了确保网络一致性与安全性的协作努力，旨在使检查点在特定时间范围内先后完成证明与最终确定，从而提升共识机制的可靠性。

#### 源头与目标、连接与冲突 (Sources and targets, links and conflicts)

在 Casper FFG 中，选票由源头（Source）和目标（Target）检查点组成，代表了验证者对区块链在不同时间点状态的承诺。这些选票以“连接对”的形式投出，表明了验证者当前认可的共识点以及提议的新共识点。源头投票反映了验证者对某个已获得广泛支持的检查点的认可，而目标投票则代表了对一个新检查点的有条件承诺，该承诺取决于其他人是否也提供了类似的支持。这种双重投票机制为区块的最终确定提供了结构化的推进流程，确保了网络的完整性与连续性。

#### 绝对多数连接 (Supermajority links)
在 Casper FFG 中，当按质押权重计算超过三分之二的验证者认可同一个连接，并且他们的选票被包含在区块链中时，就建立了一个从源头到目标检查点的绝对多数连接 ($s \rightarrow t$)。该机制通过验证者的广泛一致性来确认检查点的序列，从而确保共识和安全。

#### 证明 (Justification)

在 Casper FFG 中，当一个节点观察到大多数验证者同意从一个检查点过渡到另一个检查点时，它就会证明（Justify）旧的检查点。如图 15-18 所示，这标志着该节点已经看到了来自验证者集合绝大部分成员达成共识的证据，并承诺除非另一条路径表现出压倒性的共识，否则不会回退到之前的状态。

![Figure 15-18](<./images/figure 15-18.png>)

图 15-18. 证明 (Justification) 过程¹

¹ 节点已观测到绝对多数连接 $C_N \rightarrow C_{N+1}$，因此将 $C_{N+1}$ 标记为已证明（Justified）。由于 $C_{N+1}$ 在检查点树中是 $C_N$ 的直接子节点，它同时也将 $C_N$ 标记为已最终确定（Finalized）。已最终确定的检查点在图中以阴影线表示，并标记为 F。

#### 最终确定 (Finalization)

当一个节点观测到从一个“已证明”的检查点指向其直接子节点的共识（即绝对多数连接）时，它便会最终确定（Finalize）该父检查点，如图 15-19 所示。这标志着全网承诺不再从该点回退，并拥有绝大多数验证者支持作为后盾。通过使该检查点之前的区块链历史变得不可篡改，最终确定确保了网络的稳定与安全，防止了在不让验证者承担严重后果的情况下逆转历史的可能性。

![Figure 15-19](<./images/figure 15-19.png>)

图 15-19. 最终确定 (Finalization) 过程

### 罚没 (Slashing)

Casper FFG 实施了罚没机制，旨在通过惩罚违反协议规则的验证者来保障网络共识。这种强制手段能够遏制那些可能破坏区块链完整性的行为，例如最终确定相互冲突的检查点。对这些违规行为的检测——尤其是像环绕投票（Surround Votes）（参见“分叉选择规则”一节）这样复杂的场景——由于技术挑战，可能需要依赖专门的外部服务。罚没后果的严重程度与违规行为的性质及网络整体健康状况成正比；惩罚力度会根据特定时间框架内的集体行为进行缩放，从而确保验证者行为的公平性与可追责性。

### 分叉选择规则 (Fork Choice Rule)

Casper FFG 对传统的 LMD-GHOST 分叉选择规则进行了修改，要求节点必须优先选择包含最高已证明检查点（Highest Justified Checkpoint）的链；随后，该检查点便实际上成为了 LMD-GHOST 协议运行的起始块。这一改编是 LMD-GHOST 协议演进的结果，它通过承诺由绝大多数验证者达成共识的检查点，确保了网络能够实现最终性。它有效地保证了检查点一旦被证明，网络就无法回退到该点之前，从而加强了区块链的安全性和稳定性。此外，该规则旨在维护网络的活性，这与 Casper 的基本目标是一致的。

### Casper 戒律 (The Casper Commandments)

在 Casper FFG 中，检查点（Checkpoints）是确保网络共识与安全的核心。随着区块链的推进，这些检查点以递增的 Epoch 编号进行标记。验证者必须遵守严格的投票规则：他们不得针对同一个检查点投出不同的结果，也就是说，禁止双重投票（Double-voting），如图 15-20 所示。如果这一投票规则不存在，发生重组（Reorg）的可能性将大大增加，从而导致整条链变得极其不稳定。

![Figure 15-20](<./images/figure 15-20.png>)

图 15-20. 禁止双重投票规则

验证者还必须避免创建可能被解释为与其先前承诺相矛盾的选票（即禁止环绕投票）。违反这些原则将导致罚没——这是一种旨在维护共识机制完整性与可追责性的惩罚措施，如图 15-21 所示。

![Figure 15-21](<./images/figure 15-21.png>)

图 15-21. 禁止环绕投票规则

### 可追责的安全性和似是而非的活性 (Accountable Safety and Plausible Liveness)

Casper FFG 共识协议提供了两项保证，它们类同于但又区别于经典共识协议中的“安全性”与“活性”概念。这两项保证分别是：可追责的安全性（Accountable Safety）与似是而非的活性（Plausible Liveness）。

#### 可追责的安全性和经济最终性 (Accountable Safety and Economic Finality)
Casper FFG 对“可追责安全性”的证明表明，除非有超过三分之一的验证者违反协议规则，否则两个相互冲突的检查点绝不可能同时被最终确定。该系统确保了在敌对验证者少于三分之一的情况下，已最终确定的检查点保持不可逆转，从而强制实现了网络安全以及对不诚实行为的经济惩罚。

Casper FFG 中的经济最终性（Economic Finality）为潜在攻击者引入了成本，不仅通过协议规则，还通过经济威慑来强化安全。试图通过最终确定冲突检查点来破坏网络的验证者将面临严厉惩罚，损失其大部分质押金。这种方法与传统共识机制的不同之处在于，它增加了一层经济后果，确保最终确定一个区块对恶意行为者而言意味着巨大的成本，从而增强了区块链的完整性以及抵御攻击的韧性。

#### 似是而非的活性 (Plausible Liveness)

Casper FFG 确保网络保持活跃，并且总能在不惩罚任何诚实验证者的情况下达成共识，这体现了“似是而非的活性”这一概念。这意味着，只要绝大多数（超过 2/3）验证者是诚实的，协议就可以持续证明并最终确定新的检查点，从而避免因担心罚没而导致进度停滞的任何死锁（Deadlock）情况。这一原则确保了网络的韧性与持续运行，突显了 Casper 即使在挑战性条件下也能维持共识的适应能力。

## 实践案例：一个检查点的生命周期
让我们一起开启一段旅程，探索以太坊 Casper FFG 机制中一个检查点的生命周期。以太坊验证者社区的规模极其庞大，参与人数可能多达数十万甚至上百万。让所有这些选票在同一时间被处理是不切实际的。那么，我们该如何管理这一切呢？投票被分散在所谓的 Epoch（时段） 中，每个 Epoch 被划分为 32 个 Slot（时隙），每个 Slot 持续 12 秒。通过这种方式，每位验证者在每个 Epoch 内恰好投票一次，每个 Slot 大约有 $1/32$ 的验证者集合参与投票。图 15-22 展示了这样一个验证者池。

![Figure 15-22](<./images/figure 15-22.png>)

图 15-22. 验证者池

在这个示例中，验证者的数量自然比真实的以太坊网络要少得多，但我们拥有 64 个节点，它们被分为 32 个小组。如图 15-23 所示，每个小组将负责在 Epoch 中的一个 Slot 内进行投票。

![Figure 15-23](<./images/figure 15-23.png>)

图 15-23. 验证者分组示意图

那么，他们究竟在对什么进行投票呢？他们投票的对象是检查点（Checkpoint）：具体来说，就是每个 Epoch 的第一个 Slot（时隙）²。这个检查点充当了在不同时间点进行投票的验证者们的共同目标。

² 检查点始终是每个 Epoch 的第一个 Slot，但如果该 Slot 本身的区块缺失，其区块哈希可能取自更早的区块。

> [!Note]
> 这里需要澄清一点：虽然我们经常谈论“最终确定 Epoch”，但从技术术语上讲，我们实际上最终确定的是检查点（Checkpoints），即这些首个 Slot。一旦一个检查点被最终确定，直到并包括该 Slot 在内的所有内容都将尘埃落定，变得安全且不可更改。

图 15-24 展示了一个 Epoch（在本例中为 Epoch N）的示意图。检查点 N 指的是 Slot $32N$；一旦该检查点被最终确定，Slot $32N-1$ 以及之前的所有其他 Slot 都将被视为已最终确定。

![Figure 15-24](<./images/figure 15-24.png>)

图 15-24. Epoch（时段）示意图

实现这种安全性的过程非常严谨，且与传统的 BFT（拜占庭容错）共识机制十分相似。在接下来的章节中，我们将详细描述其运作原理。

### 第一轮：证明 (Justification)

验证者各自向网络广播他们对当前 Epoch 检查点的看法。随后，他们会进行观测，看网络中是否有绝对多数（Supermajority）同意他们的观点。如果达成一致，该检查点即被“证明”。在这一阶段，验证者相信网络的大多数都支持将此检查点最终确定，尽管他们目前还不能百分之百确定每个人的想法。

问题的核心在于，验证者尚无法确信网络中的恶意行为者是否在向他们提供虚假的状态信息——即所谓的“两面派”（对一部分人说一套，对另一部分人说另一套）。这是一个经常被忽视的重要细节。如果所有参与者始终诚实，那么“证明”就等同于“最终确定”，整个两轮投票的过程大可不必存在。

如图 15-25 所示，当一名验证者证明某个检查点时，意味着他已收到全网三分之二权重对该特定检查点的认可。但这第一轮认可仅对该验证者本人在本地生效。在存在敌对条件的情况下，完全有可能并没有足够多的验证者达成这一共识。传统的 PBFT 式共识机制（如 Algorand、Dfinity 和 Cosmos 所使用的）在此时会陷入停滞并失去活性。

相比之下，以太坊会继续运行。如果它无法证明某个检查点，没关系——它只需继续前进，尝试证明下一个检查点。这是因为以太坊依靠 LMD-GHOST 来维持活性，而 Casper FFG 只是一个“覆盖层”——一种“锦上添花”的机制。因此，即便最终性暂时停滞，也不会造成致命问题。

![Figure 15-25](<./images/figure 15-25.png>)

图 15-25. 证明 (Justification) 轮次

### 第二轮：最终确定 (Finalization)

验证者宣布，他们已经收到来自绝对多数（Supermajority）的消息，确认这些人也支持该检查点。随后，他们再次检查网络中的其余部分，以确认这一绝对多数是否确实存在。如果确认无误，验证者便可以“最终确定”该检查点，如图 15-26 所示。最终确定是一个强有力的步骤——它意味着任何诚实的验证者都绝不会撤销该检查点。虽然他们可能尚未在本地视图中将其标记为“已最终确定”，但至少已经将其标记为“已证明（Justified）”，且非经应受惩罚的违规行为不可逆转。

![Figure 15-26](<./images/figure 15-26.png>)

图 15-26. 最终确定 (Finalization) 轮次

在实践中，理想情况下每一轮投票跨越一个 Epoch，这意味着证明一个检查点需要约 6.4 分钟（一个 Epoch），而最终确定它还需要另一个 Epoch。总计约为 12.8 分钟。然而，得益于 Casper FFG 的流水线（Pipelined）设计，我们能够每 6.4 分钟（即每个 Epoch）就最终确定一个检查点。

> [!Note]
> 同样值得注意的是，从外部视角来看，由于选票是在 Epoch 进程中逐渐累积的，只要没有发生重大的链重组，我们可能在 12.8 分钟届满之前就能看到该检查点极有可能被最终确定的迹象。然而，协议内部正式的“证明”与“最终确定”操作仅在 Epoch 结束时发生。

在检查点的证明与最终确定过程中，可能会出现许多异常情况。接下来，让我们分析两个重要的案例，以及这个“友好最终性小工具（FFG）”是如何处理它们的。

### 冲突的证明 (Conflicting Justification)

深入思考为什么检查点需要“已证明（Justified）”和“已最终确定（Finalized）”两种状态是非常有启发性的。为什么在三分之二的绝对多数投票赞成后，不直接将检查点最终确定呢？

区别在于：证明关乎本地一致性，而最终性关乎全局共识。

证明一个检查点意味着，作为一名验证者，我收到了来自三分之二验证者的确认，表明他们批准了该检查点。然而，这种批准仅代表我的本地视角。其他验证者可能掌握着不同的信息，我无法确定。尽管存在这种不确定性，但作为一名诚实的验证者，我承诺绝不撤销任何我根据本地数据已证明的检查点。

相比之下，最终确定一个检查点则更进一步。它发生在我收到来自三分之二验证者的保证，确认他们也收到了来自三分之二同行的确认，证明了该检查点的有效性。这意味着全网的绝对多数——而不仅仅是我的本地视图——都认可并致力于该检查点。正是这种广泛的共识保护了检查点免于在全局范围内被撤销。因此，一个最终确定的检查点不仅在本地得到认可，而且在全局范围内是安全的。

为了更好地理解共识过程，让我们探索一个极端场景。假设我们有四位验证者 A、B、C 和 D，如图 15-27 所示。他们都是诚实的，但他们运行的网络可能会经历无限期的延迟。为了方便举例，假设在每个区块高度都有一个检查点。

![Figure 15-27](<./images/figure 15-27.png>)

图 15-27. 四验证者场景图示

在此场景中，每位验证者都拥有区块 0，因此都能证明检查点 0；对于这四位验证者来说，作为“源头（Source）”的 0 在本地均已证明，而 1 则是“目标（Target）”（参见“源头与目标、连接与冲突”一节）。

现在，让我们假设 A 的网络连接出现了严重延迟，而它恰好被选中提议一个区块。A 在 Epoch 2 提议了一个区块，该区块包含了所有四张用于证明检查点 1 的选票。但由于其网络连接严重延迟，其他验证者从未看到这个区块。

此时，A 拥有一个连接源头 0 和目标 1 的绝对多数连接（参见“绝对多数连接”一节），因此它将最终确定检查点 0 并证明检查点 1。与此同时，B、C、D 在当前 Epoch 中没有看到任何选票，因此他们的状态仍停留在仅证明了检查点 0。他们也会在这一 Epoch 中针对一个空检查点进行投票，即检查点 X，如图 15-28 所示。

![Figure 15-28](<./images/figure 15-28.png>)

图 15-28. 网络延迟场景步骤 1

在 Epoch 3 中，B、C、D 其中的一位验证者被选中提议区块。该区块包含了三张选票，其源头为检查点 0，目标为检查点 X。因此，在 0 和 X 之间形成了一个绝对多数连接，使得验证者 B、C 和 D 能够将检查点 0 视为已最终确定，并将检查点 X 视为已证明，如图 15-29 所示。

然而，验证者 A 则认为该区块无效。因为在 A 的本地视图中，检查点 1 已经获得了证明，且根据协议规则不可撤销。对于验证者 A 的链来说，继续运行的唯一解决方案就是清除其本地内存，并与网络中的其他节点进行重新同步。

![Figure 15-29](<./images/figure 15-29.png>)

图 15-29. 网络延迟场景步骤 2

> [!Note]
> 请务必记住，在本例中，验证者 B、C 和 D 从未见过 A 提议的区块。由于他们没有观察到区块 2（即本应证明检查点 1 的区块），他们无法对检查点 1 达成一致，因此无法证明检查点 1。结果，他们转而对一个空检查点进行投票。

这个例子表明，即使是简单的网络延迟也会导致节点对“证明”和“最终确定”产生不同的看法。然而，仅凭这一点还不足以说明为什么需要两个独立的阶段（先证明，后最终确定）。设置这两个阶段的原因非常直观：如果我们没有“证明”这一步骤，A 就会直接“最终确定”检查点 1，而这将被其余验证者视为无效，如图 15-30 所示。

![Figure 15-30](<./images/figure 15-30.png>)

图 15-30. 若无“证明”阶段的情况

在前面的例子中，A 必须清除内存并与网络其余部分重新同步。这是因为正如我们之前所说，“证明”类似于一个本地步骤，是可以撤销的。然而，如果 A 之前直接最终确定了检查点 1，这种情况就不可能发生了。如果没有这两个阶段，A 就会经历一个“已最终确定”的区块被撤销，而 B、C、D 将能够孤立区块 1 且不被罚没。确保安全性的唯一方法是采用“两阶段提交”：即证明（Justification）与最终确定（Finalization）。

## Gasper：一个真实案例

到目前为止，我们已经分别了解了 Casper FFG 和 LMD-GHOST 的运作方式。现在，让我们看看它们是如何结合成 Gasper 并应用于以太坊 PoS 共识协议之中的。

充分理解 Gasper 运作原理的最佳方式，是跟随一个真实案例，观察区块链如何利用它对区块历史达成共识。在我们的案例中，我们不会直接使用以太坊主网，而是创建一个拥有三名验证者的模拟网络，以便更清晰地描述共识协议每个阶段发生的细节，如图 15-31 所示。

![Figure 15-31](<./images/figure 15-31.png>)

图 15-31. Gasper 模拟网络

这三名验证者拥有相同数量的质押 ETH，因此他们的投票权重（即他们在投票时对每个区块分数的贡献）是相等的。此外，在这个示例中，每位验证者在每一个区块高度都会发布一次见证（Attestation），而不是像以太坊主网那样每个 Epoch 仅投票一次。

我们的目标是观察一个区块从发布到被“证明（Justified）”，最后被“最终确定（Finalized）”的完整生命周期。

在我们简化的网络中，每个 Epoch 由三个 Slot（时隙）组成，如图 15-32 所示。

![Figure 15-32](<./images/figure 15-32.png>)

图 15-32. 简化的 Epoch（时段）结构

让我们从 Epoch 1 开始我们的案例。这并非现实中的第一个 Epoch，为简单起见，我们将其称为“Epoch 1”。验证者 A 被选为提议第一个区块的人。我们可以将他们提议的区块称为“区块 1”，如图 15-33 所示。

![Figure 15-33](<./images/figure 15-33.png>)

图 15-33. 区块 1 的提议

验证者 A 发布了区块 1，该区块随即开始在网络中传播。发布后不久，验证者 B 和 C 接收到了该区块，并将其保存到各自的网络视图中。

随后，所有验证者通过投票选出他们认为的链头区块（Head Block）来进行“见证（Attestation）”。为此，他们必须在各自的本地视图中运行 LMD-GHOST 算法。结果显示链头为区块 1。这些见证消息被发布并分享给所有验证者。

现在，轮到验证者 B 被选中提议下一个时隙（Slot 2）的区块，如图 15-34 所示。为了完成提议，该验证者同样需要在其本地网络视图中运行 LMD-GHOST，以获取最新的链头区块并在其基础上构建新块。

![Figure 15-34](<./images/figure 15-34.png>)

图 15-34. 区块 2 的提议

以下是验证者 B 的网络视图：
* 验证者 A 的见证：链头区块：区块 1
* 验证者 B 的见证：链头区块：区块 1
* 验证者 C 的见证：链头区块：区块 1

因此，验证者 B 运行 LMD-GHOST 的结果是区块 1。他们现在可以在区块 1 之上发布区块 2。在区块 2 内部，验证者 B 还会保存所有此前未被包含在区块中的见证消息。因此，他们保存了那三份包含对区块 1 投票的见证。

区块 2 在网络中传播，发布后不久，验证者 A 和 C 接收到了它。请记住，虽然 LMD-GHOST 同时使用通过 P2P 网络共享的和包含在区块中的投票，但 Casper FFG 仅考虑包含在区块中的投票。因此，如果验证者已经通过 P2P 网络共享了 LMD-GHOST 投票，那么将这些投票包含进区块并不会影响 LMD-GHOST 的结果；但对于 Casper FFG 来说，这至关重要，因为这是验证者获知这些投票的唯一途径。

同样，所有验证者再次通过投票选出他们认为的链头区块来进行见证。由于他们的本地视图中都有区块 2，因此他们都投票支持区块 2 作为链头。随后，他们发布这些见证，以便所有验证者都能看到。

现在，轮到验证者 C 被选中提议 Slot 3 的下一个区块。他们在本地视图基础上运行 LMD-GHOST 以获取链头区块。以下是验证者 C 的网络视图：
* 验证者 A 的见证：链头区块：区块 2
* 验证者 B 的见证：链头区块：区块 2
* 验证者 C 的见证：链头区块：区块 2

运行结果为区块 2，因此验证者 C 在其之上发布了区块 3，如图 15-35 所示。

![Figure 15-35](<./images/figure 15-35.png>)

图 15-35. 区块 3 的提议

在区块 3 内部，验证者 C 保存了三份投给区块 2 的见证（Attestations），因为这些见证此前尚未被包含在任何区块中。

区块 3 在网络中传播，发布后不久，验证者 A 和 B 接收到了它。随后，验证者们发布见证为区块 3 投票。

现在，我们回到验证者 A。他需要提议下一个区块——即 Slot 4，这同时也是新时段 Epoch 2 的第一个区块，如图 15-36 所示。

![Figure 15-36](<./images/figure 15-36.png>)

图 15-36. 区块 4 的提议——新 Epoch

验证者 A 在其本地视图上运行 LMD-GHOST 以获取链头。以下是验证者 A 的网络视图：
* 验证者 A 的见证：链头区块：区块 3
* 验证者 B 的见证：链头区块：区块 3
* 验证者 C 的见证：链头区块：区块 3

运行结果为区块 3，因此验证者 A 在其之上发布了区块 4。

在区块 4 内部，验证者 A 保存了三份投给区块 3 的见证（Attestations），因为这些见证此前尚未被包含在任何区块中。

区块 4 在网络中传播，发布后不久，验证者 B 和 C 接收到了它。随后，验证者们必须发布新的见证，投票支持它作为链头。但这一次，情况发生了变化。

我们已经进入了一个新的 Epoch（时段），因此验证者必须更新其投票中关于 Casper FFG 的部分。事实上，我们之前忽略了这样一个细节：一份见证不仅包含对链上最新链头的投票（共识协议中的 LMD-GHOST 部分），还包含了对 Casper FFG 检查点的投票。具体而言，每份见证都包含一个源头（Source）投票和一个目标（Target）投票。源头投票是验证者已知的最后一个“已证明”的检查点，而目标投票则代表验证者认为下一个应该被“证明”的检查点。

因此，验证者 A、B 和 C 作出的见证（Attestation）内容如下：

**见证内容**：
* 链头区块 (Head)：区块 4
* 源头区块 (Source)：区块 1
* 目标区块 (Target)：区块 4

目标区块的选择非常简单，因为它通常就是该 Epoch 的第一个区块（在某些边缘情况下，目标区块可能不是该 Epoch 的第一个区块，但为了简单起见，我们忽略这些情况）。而源头区块的计算方法是：验证者查看自己掌握的见证记录，寻找那个已被超过三分之二验证者投票选为“目标”的区块。虽然我们在之前的见证中没有明确标注源头和目标，但我们可以假设它们此前都将区块 1 选为目标。因此，现在我们已经证明（Justified）了区块 1，因为在区块 1 和区块 4 之间已经建立了一个绝对多数连接（Supermajority Link）。参见图 15-37。

![Figure 15-37](<./images/figure 15-37.png>)

这些见证消息随后被发布并共享给所有验证者，并会被包含在接下来的时隙（Slot）中（通常就在紧随其后的那个时隙）。我们可以略过区块 5 和区块 6，直接进入区块 7——它是下一个时段 Epoch 3 的第一个区块，如图 15-38 所示。

![Figure 15-38](<./images/figure 15-38.png>)

图 15-38. 区块 7 的提议——Epoch 3

验证者 A 再次被选中提议区块。他们在本地视图上运行 LMD-GHOST。以下是验证者 A 的网络视图：
* 验证者 A 的见证：链头区块：区块 6，源头区块：1，目标区块：4
* 验证者 B 的见证：链头区块：区块 6，源头区块：1，目标区块：4
* 验证者 C 的见证：链头区块：区块 6，源头区块：1，目标区块：4

运行结果为区块 6，因此验证者 A 在其之上发布了区块 7。

区块 7 在网络中传播，发布后不久，验证者 B 和 C 接收到了它。随后，验证者们必须发布新的见证，投票支持它作为链头。此时，情况再次发生了变化。

我们现在进入了下一个时段——Epoch 3，因此见证（Attestation）中的 Casper FFG 部分再次发生了变化。事实上，验证者 A、B 和 C 作出的见证内容如下：

**见证内容**：
* 链头区块 (Head)：区块 7
* 源头区块 (Source)：区块 4
* 目标区块 (Target)：区块 7

如你所见，现在的目标区块是区块 7，而源头区块变为了区块 4。之所以如此，是因为在上一轮见证中，验证者 A、B 和 C 都投票支持区块 4 作为目标区块。由于我们现在建立了一条从区块 4 到区块 7 的新绝对多数连接（Supermajority Link），区块 4 现已获得证明（Justified），如图 15-39 所示。

![Figure 15-39](<./images/figure 15-39.png>)

图 15-39. 区块 4 已证明，区块 1 已最终确定

我们之所以最终确定了区块 1，是因为它是一个“已证明”的检查点，且其直接后继检查点——区块 4——也已经获得了证明。当一名验证者认为某个区块已“最终确定”时，这意味着该验证者已经看到了来自超过三分之二验证者的确认，证明他们都认可该区块已获得证明。

以验证者 A 为例（这也同样适用于 B 和 C）：A 已经看到了 B 和 C 的见证消息，在这些见证中，他们都将区块 1 选为源头区块 (Source)。将区块 1 选为源头区块，意味着 B 和 C 此前都已经观察到有三分之二多数的选票将区块 1 选为目标区块 (Target)。因此，我们可以确信，若要撤销区块 1，至少有三分之一的验证者必须因为“双重投票”而被罚没 (Slashed)。

## 争议与竞争
看到这里，你可能会纳闷：为什么我们需要这么多不同的共识算法？到底哪一个更好？这个问题的答案正是过去十年分布式系统研究领域最令人兴奋的核心所在。归根结底，这取决于你如何定义“更好”——在计算机科学的语境下，这关乎假设（Assumptions）、目标（Goals）以及不可避免的权衡（Trade-offs）。

很可能不存在任何一种算法能够优化去中心化共识问题的所有维度。当有人提议某种共识算法“优于”其他算法时，你应该追问以理清头绪：是在哪个维度更好？不可篡改性（Immutability）？最终性（Finality）？去中心化程度？还是成本？目前还没有明确的答案。此外，共识算法的设计正处于一个价值数十亿美元产业的中心，并引发了巨大的争议和激烈的辩论。最终，可能并没有一个“正确”的答案，就像不同的应用场景可能有不同的最优解一样。

整个区块链行业就是一个巨大的实验场，这些问题将在充满敌意的环境下接受测试，并涉及巨额的货币价值。最终，历史将为这些争议给出答案。

共识协议中的争议可能层出不穷，而协调网络来解决这些争议极具挑战。对齐激励机制至关重要，但并非总能实现。接下来，我们将审视当前以太坊共识算法面临的两个问题。

### 时机博弈 (Timing Games)

在以太坊协议中，时间被划分为以 12 秒为单位的“时隙（Slots）”。每个时隙都会指派一名验证者在起始时刻（ $t = 0$ ）提议区块。随后，一个由见证者组成的委员会负责验证该区块，并目标在时隙开始后的第 4 秒（ $t = 4$ ）完成验证，这被视为“见证截止时间”。时机博弈是指验证者为了最大化其 MEV（最大可提取价值）收益，而在提议区块前尽可能延长等待时间的策略，如图 15-40 所示。这种做法涉及一种微妙的平衡：验证者需要通过延迟提议来捕获更多价值，但同时必须确保其区块能获得足够比例见证委员会的支持，从而留在主链（Canonical Chain）上。


![Figure 15-40](<./images/figure 15-40.png>)

图 15-40. 时机博弈策略

以太坊中的时机博弈创造了一种竞争格局，其中一名验证者获得的 MEV 收益可能导致其他人的劣势。这种竞争会增加错过时隙（Missed Slots）和潜在区块重组（Block Reorganizations）的数量，从而破坏共识。此外，它还诱使见证者推迟他们的验证行为，为整个流程增加了多重复杂性。

《共识原则》指出，活性（Liveness）对以太坊的共识过程至关重要。然而，时机博弈通过损害网络的可靠性，对这一关键特性构成了威胁。

什么是时机博弈？它就像是在等待做出行动的最佳时机，旨在从中榨取最大利益。这正是一些负责维护网络运行的人员试图做的事情：他们等待合适的行动时机以获取最高奖励。但这种等待游戏充满风险——如果他们的网络速度较慢或经验不足，就可能错过履行职责的机会。而错过太多机会可能会使网络的可靠性降低。

![Figure 15-41](<./images/figure 15-41.png>)

图 15-41. 时机博弈风险可视化

目前，这还不是一个严重的问题。大多数担任验证者的实体并没有深入参与这些时机博弈，或者根本没有参与，如图 15-41 所示。

> [!Note]
> 自我们 2024 年编写本章以来，情况发生了一些变化。目前，Dencun（坎昆）硬分叉中引入了一项名为“提议者助力（Proposer Boost）”的解决方案，旨在惩罚延迟出块的提议者。提议者助力会在提议区块的时隙（Slot）中，增加该区块提议者所获见证票的权重。

### 绝对多数客户端的中心化风险

以太坊中“绝对多数客户端风险（Supermajority Client Risk）”的概念核心在于平衡网络的健康与安全。以太坊决定采用多种客户端实现，以防止单点故障。这是因为所有软件（包括这些客户端）都不可避免地存在漏洞（Bugs）。

真正的麻烦始于共识漏洞，这类漏洞可能导致极其严重的后果，例如凭空制造出无限量的以太币。如果整个网络仅运行单一客户端，而该客户端恰好遭遇此类漏洞，修复过程将是一场噩梦：网络可能会在漏洞激活的状态下持续运行，时间长到足以让攻击者造成不可逆转的损害。

让我们分析一个快速示例，看看如果占多数地位的客户端出现漏洞会发生什么。请注意，图 15-42 中的每个方块代表一个检查点（Checkpoint），而非区块链中的普通区块。

![Figure 15-42](<./images/figure 15-42.png>)

图 15-42. 多数客户端漏洞场景

功能正常的客户端会忽略包含无效区块（标记为“B”）的 Epoch。图中指向区块 B 的箭头表示该无效 Epoch 已被“证明（Justified）”，而从该区块出发的箭头则将其“最终确定（Finalized）”。

假设漏洞已得到修复，那些此前最终确定了无效 Epoch 的验证者希望切换回正确的链 B。此时，他们必须采取的首要行动是对 Epoch X 进行证明，如图 15-43 所示。

![Figure 15-43](<./images/figure 15-43.png>)

图 15-43. 从漏洞中恢复需要重新进行证明

为了参与对 Epoch X 的证明（如虚线箭头所示的绝对多数连接），验证者必须绕过从区块 B 发出的箭头，因为该箭头代表了对无效 Epoch 的最终确定。同时为这两个连接投票可能会导致这些验证者受到惩罚。

多客户端策略提供了一张安全网。如果某个份额不足一半的客户端出现了漏洞，网络中运行其他客户端的其余部分只需忽略该错误区块即可。这能确保网络保持在正确轨道上，将干扰降至最低。但如果是一个多数派客户端——尤其是被超过三分之二验证者使用的客户端——引入了漏洞，就可能导致错误地最终确定某条链，从而引发潜在的分裂。

以太坊鼓励客户端多样化，因为如果每个人都使用同一个客户端且该客户端失效，整个网络都将面临风险。针对运行“违背主流”的客户端（指在错误链上运行）所设立的惩罚措施，旨在阻止人们“把所有鸡蛋放在一个篮子里”。这样，即使某个客户端确实存在漏洞，损害也是可控的，受影响的用户较少。如果是一个少数派客户端出了问题，影响相对较小，因为多数派可以修正路径并继续对正确的链进行最终确定。

我们越是将选择分散到不同的客户端，以太坊就越安全。这不仅仅是为了避免技术故障，更是为了保护以太坊的未来免受单点故障的影响。这种多样性是我们应对全网危机的最佳防御手段，确保无论遇到什么挑战，以太坊都能保持强健和韧性。

当我们最初编写本章时，Geth 的使用率高达 63%，正如我们此前解释的那样，这是一个严重的问题。目前情况已经有所好转，但未来仍需改进；截至目前，41% 的执行层客户端使用 Geth，38% 使用 Nethermind，如图 15-44 所示。

![Figure 15-44](<./images/figure 15-44.png>)

图 15-44. 当前执行层客户端分布

这一问题不仅影响执行层客户端，同样也影响共识层客户端。尽管共识层方面的风险得到了迅速处理，目前的情况已相对健康且稳定，如图 15-45 所示。

![Figure 15-45](<./images/figure 15-45.png>)

图 15-45. 当前共识层客户端分布

## 结语

共识算法是以太坊中最复杂（也最精密）的部分之一。它代表了一段永无止境的创新与改进之旅，旨在增强其功能与效率的提案正在不断涌现。诸如单时隙最终性（Single-slot Finality, SSF）以及提高验证者最大有效余额（MaxEB）等特性，都体现了社区在精简和优化系统方面所做的持续努力。

理解共识的核心原理，为领悟这些技术进步及其对以太坊网络鲁棒性与可扩展性的影响奠定了坚实基础。随着以太坊的不断进化，其共识机制也将同步演进，持续推动这一先锋区块链技术的能力边界。

进阶阅读推荐：
* Gasper 论文 ([Gasper Paper](https://oreil.ly/1BoMt))
* 《升级以太坊》 ([Upgrading Ethereum](https://oreil.ly/Jzh-9)) —— Ben Edgington 著
* "去中心化是好是坏？保卫以太坊 2.0 的共识" ([Decentralization Is Good or Not? Defending Consensus in Ethereum 2.0](https://oreil.ly/VNC1Q))


















