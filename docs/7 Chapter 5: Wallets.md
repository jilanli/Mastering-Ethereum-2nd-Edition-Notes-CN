# 第 5 章：钱包 (Wallets)

“钱包”一词在以太坊中被用来描述几种不同的事物。从高层视角来看，钱包是一个软件应用程序，作为用户与以太坊交互的主要用户界面。钱包控制着用户资金的访问权限、管理密钥和地址、追踪余额，并创建和签署交易。此外，一些以太坊钱包还可以与合约进行交互，例如 `ERC-20` 代币。

更狭义地从程序员的视角来看，“钱包”是指用于存储和管理用户密钥的系统。每个钱包都有一个密钥管理组件。对于某些钱包来说，这就是它的全部。而其他钱包则属于更广泛的类别——浏览器（Browsers），它们是通向基于以太坊的去中心化应用（DApps）的接口，我们将在第 12 章中更详细地探讨。在被统称为“钱包”的各个类别之间，并没有清晰的界限。

在本章中，我们将把钱包视为私钥的容器以及管理这些密钥的系统。



---
> [!TIP]
> **译者注**：
> 作为后端开发者，理解钱包时应将其解耦为“状态机接口”和“签名机”两部分。在代码实现中，钱包的核心逻辑通常封装在一个负责 `secp256k1` 签名和密钥派生的库中，而我们常见的手机 App 只是这个核心逻辑的 UI 壳子。
---

## 钱包技术概览 (Overview of Wallet Technologies)

在本节中，我们总结了用于构建用户友好、安全且灵活的以太坊钱包的各种技术。

设计钱包时的一个关键考量是平衡便捷性与隐私性。最方便的以太坊钱包是只使用单个私钥和地址来处理所有事务。不幸的是，这种方案是隐私噩梦，因为任何人都可以轻易追踪并关联你的所有交易。为每笔交易使用新密钥对隐私保护最好，但管理起来会变得非常困难。达到正确的平衡很难，这就是为什么优秀的钱包设计至关重要。

关于以太坊的一个常见误解是认为以太坊钱包里装有以太币（Ether）或代币（Tokens）。事实上，从严格意义上讲，钱包里只持有密钥。以太币或其他代币记录在以太坊区块链（Blockchain）上。用户通过使用钱包中的密钥签署交易，来控制网络上的代币。从某种意义上说，以太坊钱包就是一个“钥匙串”。话虽如此，考虑到钱包持有的密钥是向他人转移以太币或代币所需的唯一凭证，在实践中这种区别几乎无关紧要。

这种区别真正起作用的地方在于思维模式的转变：从处理传统银行业的中心化系统（只有你和银行能看到账户里的钱，你只需说服银行你想移动资金即可完成交易）转变为处理区块链平台的去中心化系统（所有人都能看到账户的以太币余额，尽管他们可能不知道账户的所有者，且必须向所有人证明所有者想要移动资金，交易才能生效）。在实践中，这意味着有一种独立的方法可以检查账户余额，而不需要该账户的钱包。此外，如果你不喜欢最初使用的钱包应用，你可以将账户处理迁移到另一个不同的钱包中。

> [!NOTE] 
> 以太坊钱包包含的是密钥，而不是以太币或代币。钱包就像包含成对私钥和公钥的钥匙串。用户使用私钥签署交易，从而证明他们拥有这些以太币。以太币存储在区块链上。


主要有两种类型的钱包，区别在于它们包含的密钥是否相互关联。

第一种是非确定性钱包（Nondeterministic Wallet），其中每个密钥都是从不同的随机数独立生成的。密钥之间没有关系。这类钱包也被称为 JBOK 钱包，源于短语“Just a Bunch Of Keys”（只是一堆密钥）。

第二种是确定性钱包（Deterministic Wallet），其中所有密钥都派生自一个称为种子（Seed）的主密钥。这类钱包中的所有密钥都相互关联，只要你拥有原始种子，就可以再次生成所有密钥。在确定性钱包中使用了几种不同的密钥派生方法。最常用的派生方法使用树状结构，正如“分层确定性钱包（Hierarchical Deterministic Wallets, BIP-32/BIP-44）”中所描述的那样。

为了使确定性钱包在面对数据丢失事故（例如手机被盗或掉进马桶）时更安全，种子通常被编码为一组单词列表（英文或其他语言），供你在发生意外时记下并使用。这些被称为钱包的助记词（Mnemonic code words）。当然，如果有人拿到了你的助记词，他们也可以重新创建你的钱包，从而获得你的以太币和智能合约的访问权。因此，请务必非常、非常小心地对待你的恢复单词列表！永远不要以电子方式存储它，不要存在电脑或手机的文件里。把它写在纸上，并存放在安全的地方。

接下来的几节将从高层视角介绍每种钱包技术。

### 非确定性（随机）钱包 (Nondeterministic (Random) Wallets)

在最初的以太坊钱包（为以太坊预售而制作）中，每个钱包文件都存储了一个单独随机生成的私钥。此类钱包正逐渐被确定性钱包（Deterministic Wallets）所取代，因为这些“旧式”钱包在许多方面都处于劣势。例如，在以太坊中，为了最大限度地保护隐私，不重复使用以太坊地址被视为一种良好的实践——也就是说，每次接收资金时都使用一个新的地址（这需要一个新的私钥）。你可以更进一步，为每笔交易都使用新地址，尽管如果你频繁处理代币（Tokens），这可能会变得非常昂贵。为了遵循这一实践，非确定性钱包需要定期增加其密钥列表，这意味着你需要进行定期的备份。如果你在成功备份钱包之前丢失了数据（磁盘故障、饮料泼洒、手机被盗），你将失去对资金和智能合约的访问权。“0 型”非确定性钱包（"Type 0" nondeterministic wallets）是最难处理的，因为它们会以“即时”的方式为每个新地址创建一个新的钱包文件。

尽管如此，许多以太坊客户端（包括 Geth）仍在使用密钥库文件（Keystore file），这是一种 JSON 编码的文件，包含一个（随机生成的）私钥，并由密码加密以提高安全性。该 JSON 文件的内容如下所示：

```json
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```
密钥库格式使用密钥派生函数（Key Derivation Function, KDF），也称为密码强化算法（Password-stretching algorithm），用于防御暴力破解、字典攻击和彩虹表攻击。
简单来说，私钥并不是直接由密码加密的。相反，密码通过反复哈希运算被“强化”。哈希函数会重复执行 262,144 轮，这可以在密钥库 JSON 的 crypto.kdfparams.n 参数中看到。
尝试暴力破解密码的攻击者必须对每一次尝试的密码应用 262,144 轮哈希运算，这极大地减慢了攻击速度，使得具有适当复杂度和长度的密码在实践中无法被破解。

[!TIP] 除了简单的测试外，不建议使用非确定性钱包。它们备份起来太麻烦，除了最基础的场景外很难使用。相反，应使用基于行业标准、带有助记词种子（Mnemonic seed）用于备份的分层确定性钱包（Hierarchical Deterministic Wallets）。

### 确定性（种子）钱包 (Deterministic (Seeded) Wallets)

确定性钱包或“种子”钱包包含的私钥全部派生自一个单一的主密钥（Master Key），即种子（Seed）。种子是一个随机生成的数字，通过将其与索引号或“链码（Chain code）”（参见“扩展公钥与私钥”）等其他数据结合，可以派生出任意数量的私钥。
在确定性钱包中，仅凭种子就足以恢复所有派生出的密钥，因此在创建钱包时进行单次备份，就足以保护钱包中所有的资金和智能合约。种子也足以用于钱包的导出或导入，从而实现在不同钱包实现之间轻松迁移所有密钥。

这种设计使得种子的安全性变得至关重要，因为只需要种子即可获得整个钱包的访问权限。另一方面，能够将安全工作集中在单一数据片段上，也可以被视为一种优势。


### 分层确定性钱包 (Hierarchical Deterministic Wallets, BIP-32/BIP-44)

开发确定性钱包是为了能够轻松从单一种子派生出许多密钥。目前，确定性钱包最先进的形式之一是基于比特币 `BIP-32` 标准定义的**分层确定性（HD）钱包**。
HD 钱包包含以树状结构派生的密钥，使得父密钥可以派生出一系列子密钥，每个子密钥又可以派生出一系列孙密钥，依此类推。这种树状结构如图 5-1 所示。
![Figure 5-1](<./images/figure 5-1.png>)
图 5-1：HD 钱包——由单一种子生成的密钥树

相比于简单的确定性钱包，HD 钱包具有几个核心优势。首先，树状结构可以用来表达额外的组织含义。例如，可以使用特定的子密钥分支来接收付款，
而用另一个不同的分支来接收发送交易时的找零。密钥分支还可以用于公司设置中，将不同的分支分配给部门、子公司、特定职能或会计类别。

HD 钱包的第二个优势是，用户可以在不接触对应私钥的情况下创建一系列公钥。这使得 HD 钱包能够部署在不安全的服务器上，或者以“观察模式（Watch-only）”及“仅接收模式（Receive-only）”运行，此时钱包并不持有能够动用资金的私钥。

---
> [!TIP] 
> **译者注**：
> 1. **权限隔离的妙用**：HD 钱包的分层特性在后端权限管理中非常有用。例如，你可以将“父级公钥（Extended Public Key, xpub）”部署在不安全的只读服务器上，用于生成收币地址和监控账目，而将能够签名的私钥保留在离线环境中。即使只读服务器被攻破，攻击者也无法转走资金。
> 2. **标准协议链**：虽然 `BIP-32` 定义了分层结构，但以太坊进一步遵循了 `BIP-44` 标准。作为开发者，你会经常看到 `m/44'/60'/0'/0/i` 这样的路径，其中 `60'` 代表以太坊（Coin Type），这种标准化确保了你的账户可以在 MetaMask、Ledger 或 ImToken 之间完美互通。
---

### 种子与助记词 (Seeds and Mnemonic Codes, BIP-39)

为了安全地备份和检索私钥，有许多种编码方式。目前首选的方法是使用一系列单词，当按正确顺序组合在一起时，可以唯一地重新创建私钥。这有时被称为**助记词（Mnemonic）**，该方法已通过 `BIP-39` 标准化。如今，许多以太坊钱包（以及其他加密货币钱包）都使用这一标准，并可以使用互通的助记词导入和导出种子，以进行备份和恢复。

为了理解为什么这种方法变得流行，让我们看一个例子：

```text
FCCF1AB3329FD5DA3DA9577511F8F137 ← 十六进制形式的种子
wolf juice proud gown wool unfair
wall cliff insect more detail hub ← 使用 BIP-39 表示法的种子
```
从实际操作的角度来看，抄写十六进制序列时出错的概率高到难以接受。相比之下，已知单词的列表处理起来非常容易，这主要是因为单词的拼写（尤其是英文单词）具有很高的冗余度。如果在记录时不小心写成了 inzect，在需要恢复钱包时，
很快就能确定 inzect 不是一个有效的英文单词，而应该使用 insect 代替。我们讨论的是记录种子的某种表示形式，因为这是管理 HD 钱包的良好实践：在数据丢失（无论是由于意外还是被盗）的情况下，需要种子来恢复钱包，因此保持备份是非常谨慎的做法。
然而，种子必须保持极度私密，因此应小心避免数字化备份——这就是建议使用笔和纸进行备份的原因。
简而言之，使用恢复单词列表来编码 HD 钱包的种子，是安全导出私钥集、转录、记录在纸上、无误读取以及将其导入另一个钱包的最简便方法。

## 钱包最佳实践 (Wallet Best Practices)

随着加密货币钱包技术的成熟，已经形成了一些特定的行业标准，这些标准使得钱包具有广泛的互操作性、易用性、安全性和灵活性。这些标准还允许钱包从单一助记词中派生出多种不同加密货币的密钥。这些标准包括：

* 基于 `BIP-39` 的**助记词** (Mnemonic code words)
* 基于 `BIP-32` 的**分层确定性钱包** (HD wallets)
* 基于 `BIP-43` 的**多用途 HD 钱包结构** (A multipurpose HD wallet structure)
* 基于 `BIP-44` 的**多币种和多账户钱包** (Multicurrency and multiaccount wallets)

这些标准可能会随着未来的发展而改变或被废弃，但目前，它们构成了一套环环相扣的技术，已成为大多数区块链平台及其加密货币的事实上的钱包标准。

广泛的软件和硬件钱包已经采用了这些标准，使得所有这些钱包都具有互操作性。用户可以导出一个钱包中生成的助记词，并将其导入到另一个钱包中，从而恢复所有的密钥和地址。

支持这些标准的软件钱包示例包括 **Rabby Wallet**、**MetaMask** 和 **Phantom**。支持这些标准的硬件钱包示例包括 **Ledger** 和 **Trezor** 的各种型号。

接下来的章节将详细研究这些技术中的每一项。



> [!TIP]
> 如果你正在开发一个以太坊钱包，它应该被构建为分层确定性（HD）钱包，并按照接下来的章节所述，遵循 `BIP-32`、`BIP-39`、`BIP-43` 和 `BIP-44` 标准，使用编码为助记词的种子进行备份。

### 助记词 (Mnemonic Code Words, BIP-39)

助记词是编码随机数的单词序列，该随机数用作派生确定性钱包的种子。单词序列足以重新创建种子，并由此重新创建钱包及所有派生密钥。实现带有助记词的确定性钱包应用程序在首次创建钱包时，会向用户展示一段包含 12 到 24 个单词的序列。该单词序列即为钱包备份，可用于在相同或任何兼容的钱包应用中恢复并重新创建所有密钥。正如我们之前所解释的，助记词列表使用户更容易备份钱包，因为它们易于阅读且能被准确转录。

> [!NOTE]
> 助记词经常与**脑钱包 (Brainwallets)** 混淆。它们并不相同。主要区别在于：脑钱包由用户自行选择单词，而助记词由钱包随机创建并展示给用户。这一重要区别使得助记词要安全得多，因为人类在提供随机性方面表现极差。或许更重要的是，使用“脑钱包”一词暗示这些单词必须被记住，这是一个极其糟糕的主意，也是在需要备份时却无法找到备份的隐患。

助记词在 `BIP-39` 标准中定义。请注意，`BIP-39` 只是助记词标准的一种实现方式。Electrum 比特币钱包使用另一种早于 `BIP-39` 的标准，且拥有一套不同的单词库。`BIP-39` 是由 Trezor 硬件钱包背后的公司提出的，与 Electrum 的实现不兼容。然而，`BIP-39` 目前已获得数十种互操作实现的广泛行业支持，应被视为事实上的行业标准。此外，`BIP-39` 可用于生成支持以太坊的多币种钱包，而 Electrum 种子则不行。

`BIP-39` 定义了助记词和种子的创建过程，我们在此将其分为九个步骤。为了清晰起见，该过程分为两部分：第 1 至 6 步列在“生成助记词”中，第 7 至 9 步列在“从助记词到种子”中。

### 生成助记词 (Generating Mnemonic Words)

钱包根据 `BIP-39` 定义的标准流程自动生成助记词。钱包从熵源开始，添加校验和，然后按照以下步骤将熵映射到单词列表：

1.  创建一个长度为 $128$ 到 $256$ 位的密码学随机序列 $S$（熵）。
2.  通过取 $S$ 的 `SHA-256` 哈希值的前（$S$ 的长度 $\div 32$）位，创建 $S$ 的校验和（Checksum）。
3.  将该校验和添加到随机序列 $S$ 的末尾。
4.  将“序列+校验和”的组合划分为每段 $11$ 位的部分。
5.  将每个 $11$ 位的值映射到包含 $2048$ 个预定义单词的字典中的一个单词。
6.  按顺序组合这些单词，创建助记词。

图 5-2 展示了如何使用熵生成助记词。
![Figure 5-2](<./images/figure 5-2.png>)
图 5-2：生成助记词 (Generating Mnemonic Words)

表 5-1 展示了熵数据的大小与助记词长度（以单词数为单位）之间的对应关系。

表 5-1：熵的大小与生成的助记词长度
![Table 5-1](<./images/table 5-1.png>)

#### 从助记词到种子 (From Mnemonic to Seed)

助记词代表了长度为 $128$ 到 $256$ 位的熵。随后，通过使用密钥拉伸函数 `PBKDF2`，该熵被用于派生一个更长（$512$ 位）的种子。生成的种子将用于构建确定性钱包并派生其密钥。

密钥拉伸函数接收两个参数：**助记词**和**盐（Salt）**。在密钥拉伸函数中使用盐的目的是为了增加构建查找表（即彩虹表）的难度，从而防御暴力破解攻击。在 `BIP-39` 标准中，盐还有另一个用途：它允许引入一个**密码短语（Passphrase）**，作为保护种子的额外安全因子，我们将在下一节详细描述。

该流程接续前一节的步骤：

7. `PBKDF2` 密钥拉伸函数的第一个参数是步骤 6 中生成的助记词。
8. `PBKDF2` 密钥拉伸函数的第二个参数是**盐**。盐由字符串常量 `"mnemonic"` 与一个可选的用户自定义密码短语连接而成。
9. `PBKDF2` 使用 `HMAC-SHA512` 算法对助记词和盐参数进行 $2048$ 轮哈希拉伸，产生一个 $512$ 位的值作为最终输出。该 $512$ 位的值即为**种子**。

图 5-3 展示了如何使用助记词生成种子。
![Figure 5-3](<./images/figure 5-3.png>)
图 5-3：从助记词到种子 (From Mnemonic to Seed)
> [!NOTE]
> 包含 $2048$ 轮哈希的密钥拉伸函数是对抗助记词或密码短语暴力破解攻击的一种较为有效的保护手段。它使得尝试数千个以上的密码短语与助记词组合的成本（计算量）变得非常高，而可能派生出的种子数量是巨大的（
>$$2^{512}$$，约为
> $$10^{154}$$
> ）——这远大于观测宇宙中的原子总数（约为 $10^{80}$）。

表 5-2、5-3 和 5-4 展示了一些助记词及其生成的种子的示例。
表 5-2：不带密码短语的 128 位熵助记词及其生成的种子
![Table 5-2](<./images/table 5-2.png>)
表 5-3：带有密码短语的 128 位熵助记词及其生成的种子
![Table 5-3](<./images/table 5-3.png>)
表 5-4：不带密码短语的 256 位熵助记词及其生成的种子
![Table 5-4](<./images/table 5-4.png>)

#### BIP-39 中的可选密码短语 (Optional Passphrase in BIP-39)

`BIP-39` 标准允许在派生种子时使用一个可选的密码短语（Passphrase）。如果不使用密码短语，助记词将使用由常量字符串 `"mnemonic"` 组成的盐（Salt）进行拉伸，从而为任何给定的助记词生成一个特定的 $512$ 位种子。如果使用了密码短语，拉伸函数将从同一组助记词中生成一个**完全不同**的种子。

事实上，对于单组助记词，每一个可能的密码短语都会导向一个不同的种子。本质上，**并不存在“错误”的密码短语**。所有的密码短语都是有效的，它们都指向不同的种子，形成了一套庞大的未初始化钱包集合。由于可能的钱包集合空间巨大（$2^{512}$），只要密码短语具有足够的复杂度和长度，实际上不存在被暴力破解或意外撞上已使用钱包的可能性。


> [!TIP]
> 在 `BIP-39` 中没有“错误”的密码短语。每一个密码短语都会导向某个钱包。除非该钱包之前被使用过，否则它最初将是空的。

密码短语创造了两个核心特性：
1.  **第二因子（记忆项）**：它使得助记词备份在物理上被盗时仍具有保护作用，因为窃贼缺少了用户大脑中记忆的那个“额外单词”。
2.  **某种形式的“隐写保护”或“胁迫钱包”**：用户可以准备一个简单的密码短语来导向一个存有少量资金的钱包，用于在受到威胁时分散攻击者注意力（即“诱饵钱包”），而将大额资产隐藏在另一个复杂密码短语导向的真实地址中。

然而，使用密码短语也引入了风险：
* **永久丢失风险**：如果钱包所有者丧失行为能力或去世，且没有其他人知道密码短语，那么即持有助记词也无法找回资产。
* **备份陷阱**：如果所有者将密码短语与助记词记录在同一张纸上，则完全失去了“双因子验证”的安全性，且增加了备份的复杂性。

虽然密码短语（Passphrase）非常有用，但应仅在配合周密的备份与恢复计划时使用。必须考虑到在所有者去世后，其继承人是否能够通过该流程恢复加密货币资产。

#### 使用助记词码（Working with Mnemonic Codes）

BIP-39 标准已在多种编程语言中以库的形式实现，例如：

* **python-mnemonic**
由提出 BIP-39 的 SatoshiLabs 团队维护的 Python 语言官方参考实现。
* **ConsenSys/eth-lightwallet**
一个适用于节点和浏览器的轻量级 JavaScript 以太坊（Ethereum）钱包实现，支持 BIP-39。
* **npm/bip39**
比特币 BIP-39 标准的 JavaScript 实现。

此外，还有一个实现在独立网页中的 BIP-39 生成器（图 5-4），这对于测试和实验非常有用。该助记词码转换器（Mnemonic Code Converter）可以生成助记词、种子（Seeds）以及扩展私钥（Extended Private Keys）。它可以离线在浏览器中使用，也可以在线访问。

> [!Note]
> 本章将反复强调这一点，因为这是种子安全（Seed Security）中最关键的规则：在任何情况下，切勿以数字形式保存你的助记词（Seed Phrase）。

![Figure 5-4](<./images/figure 5-4.png>)
图 5-4 网页中的 BIP-39 生成器

### 从种子创建分层确定性钱包（Creating an HD Wallet from the Seed）
分层确定性钱包（HD Wallets）是从一个单一的**根种子（Root Seed）**创建而成的，该种子是一个 128 位、256 位或 512 位的随机数。正如前一节所述，该种子通常由助记词（Mnemonic）生成。

HD 钱包中的每一个密钥都是从这个根种子中**确定性地派生（Deterministically Derived）**出来的。这意味着在任何兼容 HD 钱包标准的实现中，都可以仅凭该种子重新创建整个 HD 钱包。通过仅传输派生出根种子的助记词，即可轻松地导出、备份、恢复和导入包含成千上万甚至数百万个密钥的 HD 钱包。

### 分层确定性钱包（HD Wallets / BIP-32）
大多数 HD 钱包都遵循 BIP-32 标准，该标准已成为确定性密钥生成的行业事实标准。我们在此不会讨论 BIP-32 的所有细节，仅涵盖理解其在钱包中应用所必需的组件。最核心的特性是派生密钥之间可能存在的树状分层关系（Treelike Hierarchical Relationships），如图 5-1 所示。此外，理解**扩展密钥（Extended Keys）和增强密钥（Hardened Keys）**的概念也至关重要，这些内容将在接下来的章节中解释。

许多软件库提供了数十种可互操作的 BIP-32 实现。这些库大多是为比特币（Bitcoin）钱包设计的，虽然比特币的地址实现方式不同，但它们与以太坊（Ethereum）兼容 BIP-32 的钱包共享相同的密钥派生实现。你可以直接使用专为以太坊设计的库，或者通过添加以太坊地址编码库来改造比特币的实现版本。

此外，还有一个作为独立网页实现的 BIP-32 生成器，对于测试和实验 BIP-32 非常有用。

> [!WARNING]
> 该独立 BIP-32 生成器并非 HTTPS 网站。这是为了提醒你：使用此工具并不安全。它仅供测试使用，切勿将该网站生成的密钥用于存放真实资金。

#### 扩展公钥与私钥（Extended Public and Private Keys）
在 BIP-32 术语中，密钥可以被“扩展（Extended）”。通过特定的数学运算，这些扩展的“父（Parent）”密钥可以被用来派生“子（Child）”密钥，从而产生前面所述的密钥和地址层级结构。父密钥不一定非得处于树的最顶端，它可以是树状层级结构中任何位置的密钥。

扩展一个密钥涉及取密钥本身并附加一个特殊的链码（Chain Code）。链码是一个 256 位的二进制字符串，它与每个密钥混合以产生子密钥。
如果该密钥是私钥，它就会成为一个扩展私钥（Extended Private Key），以前缀 xprv 作为标识：
```
xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i...
```
而**扩展公钥（Extended Public Key）**则以前缀 xpub 作为标识：
```
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn...
```
HD 钱包一个非常有用的特性是：能够在没有私钥的情况下，直接从父级公钥派生出子级公钥。这为我们提供了两种派生子级公钥的途径：要么直接从子级私钥派生，要么从父级公钥派生。因此，一个扩展公钥可以被用来派生该 HD 钱包结构分支中所有的公钥（且仅限公钥）。

这种“快捷方式”可用于创建极其安全的“仅限公钥（Public-key-only）”部署方案。在这种场景下，服务器或应用程序仅持有扩展公钥的副本，而完全不持有任何私钥。此类部署可以生成无限数量的公钥和以太坊地址（Ethereum Addresses），但无法花费发送到这些地址的任何资金。与此同时，在另一台更安全的服务器上，扩展私钥可以派生出所有对应的私钥，用于签署交易并消费资金。

此方法的一个常见应用是在运行电子商务应用的 Web 服务器上安装扩展公钥。Web 服务器可以使用公钥派生函数为每笔交易（例如客户的购物车）创建一个新的以太坊地址，且服务器上不会有任何可能被盗的私钥。如果没有 HD 钱包，实现这一目标的唯一方法是在一台独立的物理隔离服务器上预先生成数千个以太坊地址，然后将它们预载到电商服务器上。这种方法非常繁琐，需要持续维护以确保服务器不会耗尽地址——因此，人们更倾向于使用 HD 钱包的扩展公钥。

另一个常见应用是冷存储（Cold-storage）或硬件钱包。在这种场景下，扩展私钥可以存储在硬件钱包中，而扩展公钥可以保持在线。用户可以随意创建“接收”地址，而私钥则安全地保存在线下。若要花费资金，用户可以在离线签名终端中使用扩展私钥，或者直接在硬件钱包设备上进行交易签名。

#### 增强子密钥派生（Hardened Child Key Derivation）
从扩展公钥（xpub）派生出一系列公钥分支的能力非常实用，但它也伴随着潜在风险。访问 xpub 虽然不能直接获取子私钥，但由于 xpub 包含链码（Chain Code，用于从父公钥派生子公钥），如果某个子私钥被知晓或泄露，它就可以与该链码结合，推导出所有其他同级子私钥。一旦单个子私钥连同父级链码泄露，所有子级的私钥都将暴露。更严重的是，子私钥与父级链码结合，可以被用来推算父级私钥。

为了抵御这种风险，HD 钱包使用了一种称为**增强派生（Hardened Derivation）**的替代派生函数，它“切断”了父公钥与子链码之间的数学关系。增强派生函数使用父私钥（Parent Private Key）来派生子链码，而不是使用父公钥。这在父子序列中创建了一道“防火墙”，由此产生的链码无法被用来破坏父级或同级兄弟节点的私钥安全性。

简单来说，如果你想利用 xpub 的便利性来派生公钥分支，同时又不希望暴露在链码泄露的风险之下，你应该从一个**增强父节点（Hardened Parent）**而不是普通父节点进行派生。最佳实践是让主密钥（Master Keys）的第一层级子节点始终通过增强派生生成，以防止主密钥受到威胁。

#### 普通与增强派生的索引号（Index Numbers for Normal and Hardened Derivation）
显然，能够从给定的父密钥派生出多个子密钥是非常必要的。为了实现这一点，标准引入了索引号（Index Number）。每个索引号在通过特殊的子密钥派生函数与父密钥结合时，都会产生一个不同的子密钥。BIP-32 父级到子级派生函数中使用的索引号是一个 32 位整数。为了轻松区分通过普通（非增强）派生函数生成的密钥与通过增强派生生成的密钥，该索引号范围被划分为两部分：普通派生（Normal Derivation）：使用索引号 $0$ 到 $2^{31}-1$（0x0 到 0x7FFFFFFF）。增强派生（Hardened Derivation）：使用索引号 $2^{31}$ 到 $2^{32}-1$（0x80000000 到 0xFFFFFFFF）。因此，如果索引号小于 $2^{31}$，则该子密钥是普通的；如果索引号等于或大于 $2^{31}$，则该子密钥是增强的。

为了使索引号更易于读取和显示，增强子密钥的索引号通常从零开始显示，但会附加一个撇号（'）。因此，第一个普通子密钥显示为 0，而第一个增强子密钥（索引 0x80000000）显示为 0'。依此类推，第二个增强密钥的索引为 0x80000001，显示为 1'，以此类推。当你看到 HD 钱包索引 $i'$ 时，它代表的实际数值是 $2^{31} + i$。

#### HD 钱包密钥标识符（路径）（HD Wallet Key Identifier (Path)）
HD 钱包中的密钥通过一种“路径（Path）”命名规范来标识，树中的每一层级都使用斜杠（/）字符分隔（参见表 5-5）。从主私钥（Master Private Key）派生出的私钥以 m 开头。从主公钥（Master Public Key）派生出的公钥则以 M 开头。

因此，主私钥的第一个子私钥标识为 m/0。第一个子公钥标识为 M/0。第一个子密钥的第二个孙密钥标识为 m/0/1，依此类推。

密钥的“祖先关系”是从右向左读取的，直到到达派生出它的主密钥为止。例如，标识符 m/x/y/z 描述的是：密钥 m/x/y 的第 z 个子密钥，而 m/x/y 是密钥 m/x 的第 y 个子密钥，m/x 又是主密钥 m 的第 x 个子密钥。
表 5-5. HD 钱包路径示例
![Table 5-5](<./images/table 5-5.png>)

### 导航 HD 钱包树状结构（Navigating the HD Wallet Tree Structure）
分层确定性钱包（HD Wallet）的树状结构具有极大的灵活性。但硬币的另一面是，它也允许无限的复杂度：每个父级扩展密钥可以拥有 40 亿个子节点——20 亿个普通子节点和 20 亿个增强（Hardened）子节点。其中的每个子节点又可以拥有另外 40 亿个子节点，依此类推。这棵树可以根据你的需求无限深，拥有潜在无限多的代际。面对如此巨大的潜力，导航这些庞大的树结构会变得相当困难。

两份比特币改进提案（BIPs）通过为 HD 钱包树结构创建标准，提供了管理这种潜在复杂度的方法。BIP-43 提议使用第一个增强子节点索引作为一个特殊的标识符，用以表示树结构的“用途（Purpose）”。基于 BIP-43，一个 HD 钱包应该只使用树的第一层级中的一个分支，通过索引号来定义钱包的用途，从而识别树剩余部分的结构和命名空间（Namespace）。更具体地说，一个仅使用 m/i'/... 分支的 HD 钱包旨在表示一个特定的用途，而该用途由索引号 i 标识。

延续这一规范，BIP-44 提议了一种多币种、多账户（Multicurrency, Multiaccount）结构，通过将“用途（Purpose）”编号设置为 44' 来表示。所有遵循 BIP-44 结构的 HD 钱包都可以通过它们仅使用树的一个分支这一事实来识别：m/44'/*。BIP-44 规定该结构由五个预定义的树层级组成：
```
m / purpose' / coin_type' / account' / change / address_index
```
第一层级 purpose' 始终设置为 44'。

第二层级 coin_type' 指定了加密货币类型，允许在一个多币种 HD 钱包中，每种货币在第二层级下都有自己的子树。标准文档 SLIP-0044 中定义了多种货币；例如，以太坊（Ethereum）是 `m/44'/60'`，以太坊经典（Ethereum Classic）是 `m/44'/61'`，比特币（Bitcoin）是 `m/44'/0'`，所有货币的测试网（Testnet）均为 `m/44'/1'`。

第三层级是 account'，允许用户为了会计或组织目的将其钱包细分为独立的逻辑子账户。例如，一个 HD 钱包可能包含两个以太坊账户：`m/44'/60'/0'` 和 `m/44'/60'/1'`。每个账户都是其自身子树的根。

由于 BIP-44 最初是为比特币设计的，它包含了一个在以太坊世界并不相关的“怪癖”。在路径的第四层级 change（找零）中，HD 钱包有两个子树：一个用于创建接收地址，一个用于创建找零地址。在以太坊中仅使用“接收（Receive）”路径，因为以太坊不像比特币那样需要找零地址。注意，之前的层级使用的是增强派生（Hardened Derivation），而这一层级使用的是普通派生（Normal Derivation）。这是为了允许树的账户层级（Account Level）导出扩展公钥（Extended Public Keys），以便在非安全环境中使用。

可用的地址由 HD 钱包作为第四层级的子节点派生，使得树的第五层级成为 address_index。例如，主账户中用于以太坊付款的第三个接收地址将是 `M/44'/60'/0'/0/2`。表 5-6 显示了更多示例。

表 5-6. BIP-44 HD 钱包结构示例
![Table 5-6](<./images/table 5-6.png>)

## 安全性（Security）
让我们首先引入“安全性（Security）”与“恢复便捷性（Ease of Recovery）”这两个概念。将这些概念推向极端：什么是世界上最安全的种子（Seed）？那是谁也无法恢复的种子，甚至包括你自己。因此，如果一个种子被创建后，所有的物理或数字副本都被销毁，那它就是世界上最安全的种子。虽然这并不理想，因为你也将无法找回资产，但从技术上讲，它是最安全的。

反之，从恢复便捷性的角度来看，什么样的种子最容易恢复？那就是把助记词（Seed Phrase）写得随处可见，比如在显眼位置把它纹在身上。这样的种子极其容易找回，但毫无安全性可言。

你在自托管（Self-custody）的**操作安全（OpSec）**中所做的任何选择，通常都会增加安全性或增加恢复的便捷性。增加安全性通常会降低恢复便捷性，反之亦然。有时，你的操作可能会同时降低两者，这是应当避免的。

即便拥有高安全性的系统，也没有任何方案是 100% 安全的。你可以竭尽全力创建一个完美的系统，但漏洞依然存在。其中最有趣的漏洞之一是私钥碰撞（Private-key Collisions）：即生成了一个已经被他人使用的种子。由于硬件钱包中的种子是离线生成的，且不存在已生成种子的数据库，因此在技术上确实有可能两次生成同一个钱包。发生这种情况的概率微乎其微（你连续两次中彩票头奖的概率都比这高），但它依然是一个理论上的可能性。

>[!WARNING]
>通常情况下，种子安全并不具备紧迫性。要么你的种子已经被盗（这种情况下你已经陷入麻烦），要么它还没被盗。对于比特币钱包来说尤其如此。对于以太坊而言情况类似，但在某些情况下快速行动可以挽救资金——例如撤销对危险智能合约的授权（Approvals）。如果你收到任何关于种子的“紧急信息”，那很可能是一个骗局。

隐藏种子的复杂安全机制并非最佳实践。虽然它们起初看起来天衣无缝，但该领域的专业人士通常能利用合适的工具破解这类方案。如果它复杂到连专业人士都无法恢复，那么当你真正需要时，你很有可能也无法找回它。

另一个非最佳实践是依赖“隐晦”来实现安全（Obscurity for Security）。你的系统应尽可能减少“秘密”组件，种子本身应该是唯一的秘密。如果泄露系统的部分细节会导致整个系统崩溃，那么它就不安全。

最佳实践是遵循大多数人的做法。尝试发明新系统，或者更糟的是从头开始创建一切，都是错误的。这不仅不安全，而且大多数人并不具备相关的技术能力。保持简单（Simplicity）绝对是一项最佳实践。

制作种子的备份可能是最重要的最佳实践。无论是硬件钱包还是浏览器钱包，备份都是必不可少的。备份存储应当：(a) 能够抵御自然灾害；(b) 与你的硬件钱包地理位置隔离；(c) 存放在安全的地方；(d) 使用防篡改包装。将种子分割存放在多张纸上并非最佳实践，这会给人一种虚假的安全感。

>[!TIP]
>如果你没有安全的地方存放种子，可以考虑使用助记词密语（Passphrase）。密语通过在密钥生成过程中与种子结合，增加了额外的一层保护。你甚至可以数字化存储密语，因为没有种子它就毫无用处。如果有人获取了你的种子但没有密语，他们在一定时间内仍无法访问你的资金；这是因为如果攻击者持有种子，密语是可以被暴力破解的。

每个人的需求不同，安全要求也会随之变化。但你应始终遵循最佳实践。你的需求可能会随时间推移而改变，因此请保持警惕并根据需要调整你的操作安全（OpSec）策略。

设置好硬件钱包后，测试你恢复种子的能力。每 12 个月至少进行一次测试，确保你的备份可用且易于获取。

一个安全的系统长什么样？一个可信的硬件钱包（如 Trezor）、至少一个安全的备份（绝不进行数字保存），以及一份万一你发生意外时的遗产继承计划（Inheritance Plan）。

>[!NOTE]
>遗产继承是一个非常复杂的话题。我们建议阅读 Pamela Morgan (Merkle Bloom) 撰写的《加密资产继承规划：所有者简明指南》（Cryptoasset Inheritance Planning: A Simple Guide for Owners）。

## 改善用户体验（Improving on User Experience）
正如我们早些时候提到的，从高层级来看，钱包是一个软件应用程序，作为以太坊（Ethereum）的主要用户界面。因此，对于大多数以太坊用户而言，钱包几乎代表了全部的用户体验。多年来，这一领域并未得到实质性的改进。例如，在撰写本书时，最流行的浏览器钱包是 MetaMask，它自诞生以来并没有太大的进化；而紧随其后的 Rabby 最近脱颖而出。我们现在将探讨几种可能大幅提升用户体验的钱包更新。

### 账户抽象（Account Abstraction）
以太坊上的账户抽象（Account Abstraction, AA）是一种让用户账户更灵活、更易于使用的方法。通常情况下，正如第 2 章所述，以太坊有两种类型的账户：外部账户（EOAs）和智能合约账户（Smart Contract Accounts）。AA 结合了两者的优点。它允许普通账户（EOAs）的行为更像智能合约，这意味着用户可以为账户运行方式设置自定义规则，例如增加安全功能或允许多人签署交易。

借助账户抽象（AA），以太坊可以变得更加用户友好且灵活。例如，你可以在不完全依赖私钥（Private Key）的情况下恢复丢失的账户，或者你可以使用任何代币支付交易手续费（Gas），而不局限于以太（Ether）。

目前已有多个实现账户抽象（AA）的提案。其主要区别在于：一类提案试图在不更改以太坊协议的情况下实现 AA；而另一类提案（将包含在 Pectra 升级中）最终将通过更改以太坊协议来实现。

让我们来看看账户抽象（AA）相关的主要以太坊改进提案（EIPs）和以太坊意见征求稿（ERCs）。请记住，这些提案正在快速演进，到本书出版时，AA 的格局可能已经发生了重大变化。尽管如此，探索已经实现的方案以及近期计划中的内容仍然大有裨益。

>[!TIP]
>理解 ERC、EIP 和 Rollup 改进提案（RIP）之间的区别非常重要。本质上，EIP 和 RIP 是侧重于以太坊网络底层变更的改进，而 ERC 是与应用相关的变更，不会对核心网络能力产生任何影响。

#### ERC-4337
ERC-4337 是以太坊区块链的一项进步，旨在使用户账户更加多功能、安全且用户友好。与改变以太坊协议的典型升级不同，ERC-4337 通过智能合约（Smart Contracts）和链外组件引入了新功能。截至 2024 年 9 月，账户抽象（AA）的主要链上实现方案即为 ERC-4337。

正如我们在第 2 章中所述，传统的以太坊账户分为两类：由私钥唯一控制的外部账户（EOAs），以及通过智能合约运行的合约账户（Contract Accounts）。目前 EOA 在用户钱包中占据主导地位，因为它们简单且经济；然而，它们的功能有限且容易产生安全风险。丢失私钥可能意味着永久丢失资金，且 EOA 无法针对多重签名（Multisignature）设置或账户恢复选项等安全特性进行自定义。合约账户虽然可以整合这些安全措施及更多功能，但其复杂性和更高的交易手续费（Gas）阻碍了普通用户的广泛使用。ERC-4337 通过使 EOA 能够像智能合约一样运作，将 EOA 的简便性与合约账户的安全性及灵活性结合在一起，从而克服了这一难题。

ERC-4337 的实现引入了**用户操作（UserOperations）来以不同的方式处理交易，如图 5-5 所示。用户不再直接向区块链广播每笔交易，而是将 UserOperations 提交到一个高级别的内存池（Mempool），交易在那里临时存储。被称为捆绑器（Bundlers）**的特殊参与者负责收集并处理这些 UserOperations，将其打包成一笔单一的以太坊交易。这一过程减少了网络拥堵，并允许以更高效的捆绑方式处理多个操作。

ERC-4337 还确立了一个名为**代付者（Paymasters）**的新角色。通常，以太坊交易需要以 ETH 支付 Gas 费用，但 Paymasters 使得用户可以用其他代币支付 Gas 费，甚至可以由第三方赞助者代为支付费用。这一转变消除了一个重大障碍，特别是对于可能持有非 ETH 代币的新手来说，使以太坊网络更具包容性和易用性。
![Table 5-5](<./images/figure 5-5.png>)
图 5-5. ERC-4337 实现图解（ERC-4337 implementation diagram）
UserOperations（用户操作）不再使用存放外部账户（EOAs）待处理交易的传统公共内存池（Mempool），而是被发送到一个专门的 UserOperation 内存池：这是一个专门为这些操作设计的高级别内存池。**捆绑器（Bundlers）**监控这个 UserOperation 内存池，收集多个 UserOperations 并将它们打包成一笔单一的“经典”交易。它们首先通过 EntryPoint（入口点合约）的方法验证每个 UserOperation 的有效性。验证通过后，捆绑器将这笔捆绑交易直接提交到下一个提议的区块中，从而绕过常规内存池。捆绑器既可以自己充当区块构建者（Block Builders），也可以与区块构建者合作，将交易添加到区块链中。

#### EIP-2938
虽然 ERC-4337 侧重于在不改变以太坊核心的前提下，通过智能合约（Smart Contracts）在应用层实现账户抽象（AA），但 EIP-2938 则更进一步，提议将 AA 嵌入到协议层（Protocol Layer）本身。这种底层方法通过从根本上改变以太坊虚拟机（EVM）对待账户的方式，允许用户、智能合约和应用程序之间进行更直接、更灵活的交互。通过 EIP-2938，用户可以在没有传统外部账户（EOAs）的情况下处理操作，消除对基于私钥（Private-key-based）账户的依赖，并直接在以太坊协议级别支持更多样化的账户管理系统，例如多重签名账户（Multisignature Accounts）或社交恢复账户（Social Recovery Accounts）。
EIP-2938 与现有的某些 AA 提案的主要区别在于，它专注于将抽象直接集成到协议中，而不是在协议之上堆叠。借助 EIP-2938，以太坊将支持“操作（Operations）”而非“交易（Transactions）”，其中每个操作都可以代表一种更通用、更可定制的交易类型。EIP-2938 可以将以太坊的交易重新定义为可编程对象，从而支持更广泛的使用场景。通过将账户和交易视为天生可编程的实体，它扩展了以太坊在标准支付和合约交互之外的效用，完美契合了网络上日益复杂的应用需求。

#### RIP-7560
RIP-7560 提案将 EIP-2938 和 ERC-4337 整合为一种统一的**原生账户抽象（Native AA）**方案，将以太坊交易的范围划分为验证（Validation）、执行（Execution）和交易后处理（Post-transaction）步骤。通过将交易验证分离为授权（Authorization）和 Gas 费用支付（Payment）这两个独立过程，它允许一个合约为另一个账户的交易赞助 Gas 费用。这种方法在实现完全原生 AA 目标的同时，保持了对 ERC-4337 生态系统的兼容性。
虽然 ERC-4337 在应用层引入了账户抽象（AA），但由于其非协议内设计（Out-of-protocol），它也带来了一些局限性。这些缺点包括额外的 Gas 成本、有限的抗审查性、对非标准 RPC 方法的依赖，以及限制了与现有合约预期兼容性的约束。EIP-2938 所提议的原生 AA 通过将这些功能直接构建到协议中，提供了一个更健壮的替代方案。然而，EIP-2938 并没有完全对齐 ERC-4337 的结构，而后者已经在不改变协议的情况下得到了广泛的测试和实施。

通过将 EIP-2938 内置的协议级特性与从 ERC-4337 中获得的实践见解相结合，该提案集两家之长。这种混合方案旨在降低 Gas 成本，通过增强交易的抗审查性来提高可靠性，并确保与当前及未来的以太坊合约兼容。从外部账户（EOAs）逐渐转向智能合约账户也将降低与私钥相关的风险，使以太坊更安全、更易于使用。重要的是，这种架构确保了那些已经在使用 ERC-4337 的用户可以平滑地采用这些新功能。

图 5-6 展示了 RIP-7560 中概述的账户抽象（AA）交易流程。该过程整合了几个负责验证、部署和执行的关键合约，从而创建了一种流线型、模块化的方法来管理以太坊区块链上的用户账户和交易。
![Table 5-6](<./images/figure 5-6.png>)
图 5-6. RIP-7560 交易流程（RIP-7560 transaction flow）
该流程始于 **Nonce 管理合约（Nonce Manager Contract）**的 Nonce 检查，以确保交易是唯一的且没有被重放。这是保证交易完整性的关键步骤，因为它能防止双重支出或意外的重复操作。如果 Nonce 有效，系统将继续推进；否则，交易将被终止。

接下来，流程会检查用户的**账户合约（Account Contract，即智能钱包）**是否已经存在。如果不存在，**部署者合约（Deployer Contract）**将介入并创建该钱包，从而允许用户参与交易。一旦完成部署（或者如果账户已存在），账户合约本身会执行一次验证检查，以确认交易合法并符合合约逻辑。这确保了只有经过授权的操作才能继续执行，为每个用户的钱包增添了一层安全性和自定义能力。
该流程中一个有趣的特性是 代付者合约（Paymaster Contract） 的可选参与。如果指定了代付者，该合约可以支付交易的 Gas 费用或提供替代支付方式。当涉及代付者时，它会经历自身的验证过程，以确保其能够合法地承担交易成本。这种灵活性支持了赞助模型（Sponsorship Models），并可能减轻用户的交易费负担。

一旦所有验证完成，以太坊执行层（Ethereum Execution Layer） 开始处理交易。在执行期间，会使用一个**执行帧（Execution Frame）**来处理交易细节并监控其进度。执行完成后，如果涉及代付者，它会执行任何必要的后处理（Postprocessing）操作以完成交易赞助的最终结算。

#### EIP-5806
EIP-5806 引入了一种新的交易类型，允许外部账户（EOAs）通过“委托调用（Delegate Call）”机制运行自定义代码。

目前，外部账户（EOAs）只能部署合约或发送“调用（Call）”交易，这限制了用户与区块链的交互。这种限制影响了易用性，因为外部账户（EOAs）无法执行诸如将多个操作批量打包进一笔交易，或执行复杂的操作等任务。虽然账户抽象（AA）可以解决这些问题，但其采用路径仍具有不确定性，且由于成本和不可转移的资产托管等因素，并非所有用户都能完成迁移。

该提案提供了一种直接的方法，让外部账户（EOAs）在最小化以太坊虚拟机（EVM）改动且符合熟悉的安全标准的情况下执行自定义代码。通过允许外部账户（EOAs）向特定合约进行委托调用，用户获得了更多的控制权和灵活性，能够实现多重调用批量处理（Multicall Batching）或安全代币转账等复杂操作。与其他账户抽象（AA）提案不同，此方法旨在改进外部账户（EOAs）的用户体验，而非取代现有的抽象方法，使其成为在近期增强外部账户（EOAs）功能的一个易于实现的选项。

#### EIP-3074
EIP-3074 引入了两个操作码（Opcodes）：AUTH 和 AUTHCALL，允许外部账户（EOAs）将其交易控制权委托给一个“调用者（Invoker）”合约。用户签署一条包含调用者地址和承诺值（Commit，交易值的哈希）的消息，确保调用者仅处理经过授权的交易。重放保护（Replay Protection）由调用者合约处理，用户必须信任该合约以避免恶意行为。该提案改进了交易批量处理并实现了灵活的账户委托。

AUTH 允许用户授予智能合约代表其行事的权限。它使用数字签名（ECDSA）来验证此授权，然后存储用户地址以供后续交易使用。AUTHCALL 则允许获得授权的智能合约执行交易，例如发送代币或与其他合约交互。例如，如果你想将 10 DAI 兑换为 ETH，你可以通过一次签名授权调用者（使用 AUTH）。调用者将使用 AUTHCALL 授权 Uniswap 使用你的 DAI，然后执行兑换。

最初，重放保护以及 value、gas 和其他 AUTHCALL 参数字段也需要签名。随后的设计演变为将这些任务委托给调用者合约，因此用户信任调用者至关重要。用户可以通过对特定的调用属性进行哈希处理来对其做出“承诺（Commit）”。调用者仅在承诺值（如用于重放保护的 nonce）与用户的承诺相匹配时才进行验证，如图 5-7 所示。这确保了调用者处理的内容正是用户所授权的内容。
![Figure 5-7](<./images/figure 5-7.png>)
图 5-7. EIP-3074 承诺验证（EIP-3074 commitment validation）
承诺哈希（Commit Hash）使调用者（Invoker）能够强制执行各种规则，例如允许并行 Nonce（Parallel Nonces）或在单次签名下捆绑多次调用。这实现了多重调用（Multicall）流程，例如将 ERC-20 的 approve（授权）和 transfer（转账）整合进单笔交易中，如图 5-8 所示。
![Figure 5-8](<./images/figure 5-8.png>)
图 5-8. EIP-3074 多重调用流程（EIP-3074 multicall flow）
此外，它还支持通过签署包含受托人地址和访问策略（Access Policy）的承诺消息（Commit Message），将外部账户（EOA）的控制权委托给其他密钥。调用者（Invoker）在代表该外部账户（EOA）转发调用之前会验证这些信息，如图 5-9 所示。
![Figure 5-9](<./images/figure 5-9.png>)
图 5-9. EIP-3074 委托流程（EIP-3074 delegation flow）

#### EIP-5003
EIP-5003 引入了 AUTHUSURP 操作码（Opcode），该操作码允许在通过 EIP-3074 授权的地址上部署代码，从而在配合 EIP-3607 使用时，有效地移除原始外部账户（EOA）的签名密钥。传统的外部账户（EOAs）控制着以太坊上的大量价值，但面临着诸多限制：没有简单的方法来轮换密钥、通过批量交易提高效率，或者在不持有以太（ETH）的情况下实现 Gas 赞助（Gas Sponsorship）。合约账户和账户抽象（AA）解决了这些问题，允许用户自定义安全特性、身份验证方法、支出限额、密钥轮换、社交恢复等。然而，这些好处大多仅限于那些通过智能合约钱包和应用层解决方案（如 ERC-4337 所提议的方案）积极采用新标准的开发用户。这使得自以太坊诞生以来就一直依赖外部账户（EOAs）的海量存量用户，在安全性及易用性改进方面进展有限。
虽然 EIP-3074 提供了一个初步解决方案，允许外部账户（EOAs）将签名权委托给合约账户，但它并没有允许外部账户（EOA）彻底撤销原始的签名密钥。这一缺陷引入了安全风险：即使拥有委托权限，主私钥（Primary Private Key）仍然是一个潜在的漏洞。如果主私钥泄露，整个账户依然处于危险之中，因为目前对于暴露的私钥没有撤销选项。如果用户的私钥因意外或恶意攻击泄露，唯一的选择就是创建一个新钱包并煞费苦心地逐一迁移资产，由于某些资产在现有智能合约中具有不可移动性，这一过程既昂贵且往往是不完整的。

通过该 EIP，AUTHUSURP 为外部账户（EOA）持有者提供了一条安全的过渡路径。它允许外部账户（EOAs）将控制权完全转移给智能合约，撤销原始密钥的权限，从而消除其作为安全威胁的隐患。

#### EIP-7702
EIP-7702 是预计将于 2025 年初在 Pectra 升级中实施的核心账户抽象（AA）提案。（注：本章编写于 2024 年 9 月和 10 月，因此我们使用了将来时态。）EIP-7702 在 EIP-2718 框架下引入了一种“设置代码交易（Set Code Transaction）”，使外部账户（EOA）能够授权特定代码代表其执行。

>[!NOTE]
>EIP-2718 为以太坊引入了“类型化交易信封（Typed Transaction Envelope）”格式，支持在协议内运行多种交易类型。这种标准化格式允许向后兼容的交易升级，在引入新交易类型以实现未来改进的同时保持现有结构。这将在第 6 章中详细解释。此外，本提案还调整了 EIP-3607 的限制，允许来自带有委托标记的外部账户（EOA）的交易。它为外部账户（EOA）实现了安全的委托，为以太坊增加了改进的账户管理能力。
>关于用户应如何指定打算在账户中运行的代码，产生了一个问题。主要选项包括：直接在交易中包含字节码（Bytecode），或者引用一个指向代码的指针（Pointer）。最简单的指针是链上已部署代码的地址。直接指定代码允许外部账户（EOA）在交易调用数据（Calldata）中执行任意代码。在签署代码指针时，一个需要考虑的因素是该地址在另一条链上是否指向预期的代码；钱包维护者可以硬编码单个 EIP-7702 授权消息，以确保跨链代码的一致性。

在实施 EIP-7702 时，有一个重要的安全性考量。一旦外部账户（EOA）中嵌入了代码，EIP-7702 交易可能会允许 msg.sender == tx.origin。在这种情况下，每当 EOA 代码发起调用时，交易创建者同时也是广播地址。在没有 EIP-7702 之前，这种情况仅发生在交易的最顶层执行层。由于 EIP-7702 支持交易赞助（Transaction Sponsoring），这种情况在其他执行层也将成为可能。因此，该 EIP 打破了这一不变性（Invariant），从而影响了包含 require(msg.sender == tx.origin) 检查的智能合约。这种检查通常服务于以下三个目的：

1. 验证 msg.sender 是否为 EOA：由于 tx.origin 必须始终是 EOA，这一不变性不受执行深度影响；如果调用深度为 1，仍能确保 tx.origin 即为 msg.sender。
2. 防止原子夹击攻击（Atomic Sandwich Attacks）：例如闪电贷（Flash Loans），这类攻击依赖于在同一原子交易中，在目标合约执行前后修改状态。本 EIP 会削弱这种保护。然而，利用 tx.origin 达到此目的通常被视为糟糕的实践，且矿工已可以通过选择性打包交易来绕过它。
3. 防止重入攻击（Reentrancy）：

前两种情况的例子在以太坊主网合约中均有出现，其中第一种更为常见（且不受本 EIP 影响）。然而，第三种情况在本 EIP 下更显脆弱，尽管提案开发者在初步审查中尚未发现依赖 tx.origin 进行重入保护的实例。

>[!TIP]
>与本 EIP 的早期版本及类似提案不同，委托授权可以随时撤销。用户只需使用账户当前的 nonce 签署并提交一份指向新地址的 EIP-7702 授权消息即可。如果不采取此类行动，委托将无限期保持有效。

目前，人们对于改进 EOA 的功能、提升易用性以及在某些情况下增强安全性表现出浓厚兴趣。一个关键应用是交易赞助（Transaction Sponsorship），它使用户能够在不持有 ETH 支付 Gas 费的情况下进行交易。在传统的以太坊交易中，Gas 费必须以 ETH 支付，这对于仅持有其他代币的用户或生态新手来说可能极不方便。EIP-7702 引入了一种模式，允许第三方临时或永久覆盖交易费用，使用户能够在没有 ETH 的情况下完成交易。这将简化入门流程，让用户能够直接参与特定的 DApp 或代币交互，而无需进行繁琐的 ETH 管理。

传统的以太坊账户完全依赖单个私钥，丢失私钥即意味着失去对账户和资产的控制。EIP-7702 的结构支持多种恢复机制（Recovery Mechanisms）。这对于注重安全的用户和觉得私钥管理令人望而生畏的新手来说极具价值。潜在的恢复选项包括多重签名（Multisignature）和社交恢复（Social Recovery），允许选定的联系人协助恢复账户；这是以太坊账户安全性与用户友好性的重大飞跃。

EIP-7702 还引入了批量处理（Batching）和权限降级（Privilege Deescalation）。批量处理允许在单个原子交易中处理多个动作，使用户能够一步完成复杂的工作流（例如先授权 ERC-20 额度再消费代币）。权限降级则提供权限受限的子密钥，例如仅授权支出特定金额或仅允许与某些应用交互，从而在账户受损时通过最小化暴露来增强安全性。

该 EIP 还修改了传统上管理账户余额和 nonce 行为的不变性。它打破了“EOA 账户余额只能因该账户发起的交易而减少”以及“交易执行开始后 EOA 的 nonce 不会增加”的预期。这些变化影响了内存池（Mempool）设计和其他 EIP。然而，由于账户在外部交易中是静态列出的，交易传播规则可以进行调整以防止转发冲突交易。它与 ERC-4337 和 RIP-7560 具有前向兼容性。此外，它还允许 EOA 通过现有的 EntryPoint 机制伪装成与 ERC-4337 捆绑包兼容的合约。

>[!NOTE]
>状态转换变更的一个通用设计目标是尽量减少 EIP 中的特殊情况。本 EIP 的早期迭代曾拒绝为清除账户委托标识添加特殊情况。通常，委托给 0x0 的账户行为类似于真实的 EOA；但大多数与该账户交互的操作会产生额外成本。这种额外成本可能会影响 EIP 的整体采用。基于这些原因，提案最终包含了一种机制，允许用户将其 EOA 恢复到原始状态。

本 EIP 涉及多个安全考量，这些将由实现方负责并应进行仔细评估。除了提到的 tx.origin 问题外，还有三个关键点：

* 对交易传播的挑战：允许 EOA 表现得像智能合约会挑战交易传播。传统上，EOA 只能通过交易发送价值。在本 EIP 下，EOA 的委托代码可以由任何人在任何时间调用，这导致节点无法进行静态余额验证，增加了节点验证地址余额的难度。

* 无执行的代码设置：智能合约钱包开发者必须考虑在账户中设置代码而不立即执行的影响。通常，合约部署带有 initcode 以确定性地初始化存储槽。本 EIP 在委托时省略了 initcode 执行，因此开发者必须验证初始调用数据（Calldata），以防止观察者利用其控制的账户抢跑（Front-run）设置过程。

* 重放保护：重放保护（如 nonce 处理）应由委托对象实现并签署。如果没有这一点，恶意行为者可能会重复使用签名，从而获得对签名者 EOA 近乎完全的控制权。

#### 以太坊账户抽象的未来
以太坊上的账户抽象是一个复杂但充满前景的构想，拥有多种可能的演进路径。每项提案都为简化用户交互和增强安全性提供了不同的方式。部分提案在先前方案的基础上进行改进，例如 EIP-5003 建立在 EIP-3074 之上；而其他提案，如 EIP-5806，则相对独立，甚至可能缺乏向后兼容性。这种多样性反映了社区对最优解的探索过程，最终的发展方向很可能取决于用户认为哪些选项最简单且最有效。尽管确切的未来尚不明朗，但账户抽象在改善以太坊使用体验方面确实具有巨大的潜力。

### 社交恢复
与社交恢复相关的主要提案是 EIP-2429。该提案名为“秘密多签恢复”，它引入了一种机制，允许用户通过指定信任的个人或实体作为“守护者”，从而重新获得钱包的访问权限。在用户丢失私钥的情况下，他们可以请求这些守护者协助恢复对钱包的控制权。如图 5-10 所示，守护者仅在恢复过程中介入，这限制了他们的权限，确保了系统的安全性。
![Figure 5-10](<./images/figure 5-10.png>)
图 5-10. 社交恢复流程
>[!NOTE]
>Vitalik Buterin 在 2021 年发表的一篇文章中提到：“这引出了我最推崇的钱包保护方法：社交恢复。”我们虽然不知道目前的情况是否有所改变，但社交恢复很有可能依然是 Buterin 最青睐的方案。
在正常使用情况下，社交恢复钱包的功能与普通钱包无异，允许用户使用其签名密钥签署交易。一旦密钥丢失，社交恢复机制就会启动，用户可以联系守护者，由守护者签署交易来更新钱包的签名密钥。守护者可以是值得信赖的个人、设备或机构。为了防止针对性攻击，守护者的身份不会存储在链上，从而保持其匿名性。如果用户去世，守护者也可以通过协作来收回用户的资金。

### ENS（以太坊域名服务）
以太坊域名服务（ENS）就像是传统域名的 Web3 版本，但它连接的不是网站，而是将人类可读的名称与以太坊地址联系起来。这使得处理冗长且复杂的区块链地址变得更加容易。例如，你无需将加密货币发送到像 $0xd8dA6BF...$ 这样的地址，而只需发送到类似 vitalik.eth 的名称即可。这极大地简化了交易过程，并降低了区块链的操作门槛，尤其是对于加密货币的新手而言。

如果将 ENS 与 Web2 世界进行类比，它与 DNS（域名系统）的工作原理非常相似。DNS 将难以记忆的 IP 地址连接到类似 google.com 的 URL，因此你访问网站时无需记住一串数字。然而，ENS 与 DNS 之间存在一个关键区别：ENS 是去中心化的。一旦你拥有了一个 .eth 域名，没有任何中心化机构可以控制它。在 Web2 中，域名由注册商管理，可能会被审查、暂停或限制；而在 ENS 中，你通过自己的以太坊钱包完全控制你的域名，这意味着你的 .eth 域名与持有它的钱包一样安全。

当你发送或接收加密货币时，使用像 andreas.eth 这样的名称而不是冗长的以太坊地址，会让一切变得更加顺畅和安全。它降低了输入地址时出错的可能性，而在区块链交易中，输入错误通常意味着巨大的风险。ENS 的另一个迷人之处在于它提供了一种数字身份感。就像为你的网站拥有一个域名一样，拥有一个唯一的 .eth 名称可以作为你在区块链上的公开身份。

## 总结
钱包是任何面向用户的区块链应用的基础。它们使用户能够管理密钥和地址的集合。此外，钱包还允许用户证明其对以太币（ETH）的所有权，并通过应用数字签名来授权交易，这一点我们将在第 6 章中详细探讨。
