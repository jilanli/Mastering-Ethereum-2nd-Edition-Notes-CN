# 第 5 章：钱包 (Wallets)

“钱包”一词在以太坊中被用来描述几种不同的事物。从高层视角来看，钱包是一个软件应用程序，作为用户与以太坊交互的主要用户界面。钱包控制着用户资金的访问权限、管理密钥和地址、追踪余额，并创建和签署交易。此外，一些以太坊钱包还可以与合约进行交互，例如 `ERC-20` 代币。

更狭义地从程序员的视角来看，“钱包”是指用于存储和管理用户密钥的系统。每个钱包都有一个密钥管理组件。对于某些钱包来说，这就是它的全部。而其他钱包则属于更广泛的类别——浏览器（Browsers），它们是通向基于以太坊的去中心化应用（DApps）的接口，我们将在第 12 章中更详细地探讨。在被统称为“钱包”的各个类别之间，并没有清晰的界限。

在本章中，我们将把钱包视为私钥的容器以及管理这些密钥的系统。



---
> [!TIP]
> **译者注**：
> 作为后端开发者，理解钱包时应将其解耦为“状态机接口”和“签名机”两部分。在代码实现中，钱包的核心逻辑通常封装在一个负责 `secp256k1` 签名和密钥派生的库中，而我们常见的手机 App 只是这个核心逻辑的 UI 壳子。
---

## 钱包技术概览 (Overview of Wallet Technologies)

在本节中，我们总结了用于构建用户友好、安全且灵活的以太坊钱包的各种技术。

设计钱包时的一个关键考量是平衡便捷性与隐私性。最方便的以太坊钱包是只使用单个私钥和地址来处理所有事务。不幸的是，这种方案是隐私噩梦，因为任何人都可以轻易追踪并关联你的所有交易。为每笔交易使用新密钥对隐私保护最好，但管理起来会变得非常困难。达到正确的平衡很难，这就是为什么优秀的钱包设计至关重要。

关于以太坊的一个常见误解是认为以太坊钱包里装有以太币（Ether）或代币（Tokens）。事实上，从严格意义上讲，钱包里只持有密钥。以太币或其他代币记录在以太坊区块链（Blockchain）上。用户通过使用钱包中的密钥签署交易，来控制网络上的代币。从某种意义上说，以太坊钱包就是一个“钥匙串”。话虽如此，考虑到钱包持有的密钥是向他人转移以太币或代币所需的唯一凭证，在实践中这种区别几乎无关紧要。

这种区别真正起作用的地方在于思维模式的转变：从处理传统银行业的中心化系统（只有你和银行能看到账户里的钱，你只需说服银行你想移动资金即可完成交易）转变为处理区块链平台的去中心化系统（所有人都能看到账户的以太币余额，尽管他们可能不知道账户的所有者，且必须向所有人证明所有者想要移动资金，交易才能生效）。在实践中，这意味着有一种独立的方法可以检查账户余额，而不需要该账户的钱包。此外，如果你不喜欢最初使用的钱包应用，你可以将账户处理迁移到另一个不同的钱包中。

> [!NOTE] 
> 以太坊钱包包含的是密钥，而不是以太币或代币。钱包就像包含成对私钥和公钥的钥匙串。用户使用私钥签署交易，从而证明他们拥有这些以太币。以太币存储在区块链上。


主要有两种类型的钱包，区别在于它们包含的密钥是否相互关联。

第一种是非确定性钱包（Nondeterministic Wallet），其中每个密钥都是从不同的随机数独立生成的。密钥之间没有关系。这类钱包也被称为 JBOK 钱包，源于短语“Just a Bunch Of Keys”（只是一堆密钥）。

第二种是确定性钱包（Deterministic Wallet），其中所有密钥都派生自一个称为种子（Seed）的主密钥。这类钱包中的所有密钥都相互关联，只要你拥有原始种子，就可以再次生成所有密钥。在确定性钱包中使用了几种不同的密钥派生方法。最常用的派生方法使用树状结构，正如“分层确定性钱包（Hierarchical Deterministic Wallets, BIP-32/BIP-44）”中所描述的那样。

为了使确定性钱包在面对数据丢失事故（例如手机被盗或掉进马桶）时更安全，种子通常被编码为一组单词列表（英文或其他语言），供你在发生意外时记下并使用。这些被称为钱包的助记词（Mnemonic code words）。当然，如果有人拿到了你的助记词，他们也可以重新创建你的钱包，从而获得你的以太币和智能合约的访问权。因此，请务必非常、非常小心地对待你的恢复单词列表！永远不要以电子方式存储它，不要存在电脑或手机的文件里。把它写在纸上，并存放在安全的地方。

接下来的几节将从高层视角介绍每种钱包技术。

### 非确定性（随机）钱包 (Nondeterministic (Random) Wallets)

在最初的以太坊钱包（为以太坊预售而制作）中，每个钱包文件都存储了一个单独随机生成的私钥。此类钱包正逐渐被确定性钱包（Deterministic Wallets）所取代，因为这些“旧式”钱包在许多方面都处于劣势。例如，在以太坊中，为了最大限度地保护隐私，不重复使用以太坊地址被视为一种良好的实践——也就是说，每次接收资金时都使用一个新的地址（这需要一个新的私钥）。你可以更进一步，为每笔交易都使用新地址，尽管如果你频繁处理代币（Tokens），这可能会变得非常昂贵。为了遵循这一实践，非确定性钱包需要定期增加其密钥列表，这意味着你需要进行定期的备份。如果你在成功备份钱包之前丢失了数据（磁盘故障、饮料泼洒、手机被盗），你将失去对资金和智能合约的访问权。“0 型”非确定性钱包（"Type 0" nondeterministic wallets）是最难处理的，因为它们会以“即时”的方式为每个新地址创建一个新的钱包文件。

尽管如此，许多以太坊客户端（包括 Geth）仍在使用密钥库文件（Keystore file），这是一种 JSON 编码的文件，包含一个（随机生成的）私钥，并由密码加密以提高安全性。该 JSON 文件的内容如下所示：

```json
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```
密钥库格式使用密钥派生函数（Key Derivation Function, KDF），也称为密码强化算法（Password-stretching algorithm），用于防御暴力破解、字典攻击和彩虹表攻击。
简单来说，私钥并不是直接由密码加密的。相反，密码通过反复哈希运算被“强化”。哈希函数会重复执行 262,144 轮，这可以在密钥库 JSON 的 crypto.kdfparams.n 参数中看到。
尝试暴力破解密码的攻击者必须对每一次尝试的密码应用 262,144 轮哈希运算，这极大地减慢了攻击速度，使得具有适当复杂度和长度的密码在实践中无法被破解。

[!TIP] 除了简单的测试外，不建议使用非确定性钱包。它们备份起来太麻烦，除了最基础的场景外很难使用。相反，应使用基于行业标准、带有助记词种子（Mnemonic seed）用于备份的分层确定性钱包（Hierarchical Deterministic Wallets）。

### 确定性（种子）钱包 (Deterministic (Seeded) Wallets)

确定性钱包或“种子”钱包包含的私钥全部派生自一个单一的主密钥（Master Key），即种子（Seed）。种子是一个随机生成的数字，通过将其与索引号或“链码（Chain code）”（参见“扩展公钥与私钥”）等其他数据结合，可以派生出任意数量的私钥。
在确定性钱包中，仅凭种子就足以恢复所有派生出的密钥，因此在创建钱包时进行单次备份，就足以保护钱包中所有的资金和智能合约。种子也足以用于钱包的导出或导入，从而实现在不同钱包实现之间轻松迁移所有密钥。

这种设计使得种子的安全性变得至关重要，因为只需要种子即可获得整个钱包的访问权限。另一方面，能够将安全工作集中在单一数据片段上，也可以被视为一种优势。


### 分层确定性钱包 (Hierarchical Deterministic Wallets, BIP-32/BIP-44)

开发确定性钱包是为了能够轻松从单一种子派生出许多密钥。目前，确定性钱包最先进的形式之一是基于比特币 `BIP-32` 标准定义的**分层确定性（HD）钱包**。
HD 钱包包含以树状结构派生的密钥，使得父密钥可以派生出一系列子密钥，每个子密钥又可以派生出一系列孙密钥，依此类推。这种树状结构如图 5-1 所示。
![Figure 5-1](<./images/figure 5-1.png>)
图 5-1：HD 钱包——由单一种子生成的密钥树

相比于简单的确定性钱包，HD 钱包具有几个核心优势。首先，树状结构可以用来表达额外的组织含义。例如，可以使用特定的子密钥分支来接收付款，
而用另一个不同的分支来接收发送交易时的找零。密钥分支还可以用于公司设置中，将不同的分支分配给部门、子公司、特定职能或会计类别。

HD 钱包的第二个优势是，用户可以在不接触对应私钥的情况下创建一系列公钥。这使得 HD 钱包能够部署在不安全的服务器上，或者以“观察模式（Watch-only）”及“仅接收模式（Receive-only）”运行，此时钱包并不持有能够动用资金的私钥。

---
> [!TIP] 
> **译者注**：
> 1. **权限隔离的妙用**：HD 钱包的分层特性在后端权限管理中非常有用。例如，你可以将“父级公钥（Extended Public Key, xpub）”部署在不安全的只读服务器上，用于生成收币地址和监控账目，而将能够签名的私钥保留在离线环境中。即使只读服务器被攻破，攻击者也无法转走资金。
> 2. **标准协议链**：虽然 `BIP-32` 定义了分层结构，但以太坊进一步遵循了 `BIP-44` 标准。作为开发者，你会经常看到 `m/44'/60'/0'/0/i` 这样的路径，其中 `60'` 代表以太坊（Coin Type），这种标准化确保了你的账户可以在 MetaMask、Ledger 或 ImToken 之间完美互通。
---

### 种子与助记词 (Seeds and Mnemonic Codes, BIP-39)

为了安全地备份和检索私钥，有许多种编码方式。目前首选的方法是使用一系列单词，当按正确顺序组合在一起时，可以唯一地重新创建私钥。这有时被称为**助记词（Mnemonic）**，该方法已通过 `BIP-39` 标准化。如今，许多以太坊钱包（以及其他加密货币钱包）都使用这一标准，并可以使用互通的助记词导入和导出种子，以进行备份和恢复。

为了理解为什么这种方法变得流行，让我们看一个例子：

```text
FCCF1AB3329FD5DA3DA9577511F8F137 ← 十六进制形式的种子
wolf juice proud gown wool unfair
wall cliff insect more detail hub ← 使用 BIP-39 表示法的种子
```
从实际操作的角度来看，抄写十六进制序列时出错的概率高到难以接受。相比之下，已知单词的列表处理起来非常容易，这主要是因为单词的拼写（尤其是英文单词）具有很高的冗余度。如果在记录时不小心写成了 inzect，在需要恢复钱包时，
很快就能确定 inzect 不是一个有效的英文单词，而应该使用 insect 代替。我们讨论的是记录种子的某种表示形式，因为这是管理 HD 钱包的良好实践：在数据丢失（无论是由于意外还是被盗）的情况下，需要种子来恢复钱包，因此保持备份是非常谨慎的做法。
然而，种子必须保持极度私密，因此应小心避免数字化备份——这就是建议使用笔和纸进行备份的原因。
简而言之，使用恢复单词列表来编码 HD 钱包的种子，是安全导出私钥集、转录、记录在纸上、无误读取以及将其导入另一个钱包的最简便方法。

## 钱包最佳实践 (Wallet Best Practices)

随着加密货币钱包技术的成熟，已经形成了一些特定的行业标准，这些标准使得钱包具有广泛的互操作性、易用性、安全性和灵活性。这些标准还允许钱包从单一助记词中派生出多种不同加密货币的密钥。这些标准包括：

* 基于 `BIP-39` 的**助记词** (Mnemonic code words)
* 基于 `BIP-32` 的**分层确定性钱包** (HD wallets)
* 基于 `BIP-43` 的**多用途 HD 钱包结构** (A multipurpose HD wallet structure)
* 基于 `BIP-44` 的**多币种和多账户钱包** (Multicurrency and multiaccount wallets)

这些标准可能会随着未来的发展而改变或被废弃，但目前，它们构成了一套环环相扣的技术，已成为大多数区块链平台及其加密货币的事实上的钱包标准。

广泛的软件和硬件钱包已经采用了这些标准，使得所有这些钱包都具有互操作性。用户可以导出一个钱包中生成的助记词，并将其导入到另一个钱包中，从而恢复所有的密钥和地址。

支持这些标准的软件钱包示例包括 **Rabby Wallet**、**MetaMask** 和 **Phantom**。支持这些标准的硬件钱包示例包括 **Ledger** 和 **Trezor** 的各种型号。

接下来的章节将详细研究这些技术中的每一项。



> [!TIP]
> 如果你正在开发一个以太坊钱包，它应该被构建为分层确定性（HD）钱包，并按照接下来的章节所述，遵循 `BIP-32`、`BIP-39`、`BIP-43` 和 `BIP-44` 标准，使用编码为助记词的种子进行备份。
