# 第 5 章：钱包 (Wallets)

“钱包”一词在以太坊中被用来描述几种不同的事物。从高层视角来看，钱包是一个软件应用程序，作为用户与以太坊交互的主要用户界面。钱包控制着用户资金的访问权限、管理密钥和地址、追踪余额，并创建和签署交易。此外，一些以太坊钱包还可以与合约进行交互，例如 `ERC-20` 代币。

更狭义地从程序员的视角来看，“钱包”是指用于存储和管理用户密钥的系统。每个钱包都有一个密钥管理组件。对于某些钱包来说，这就是它的全部。而其他钱包则属于更广泛的类别——浏览器（Browsers），它们是通向基于以太坊的去中心化应用（DApps）的接口，我们将在第 12 章中更详细地探讨。在被统称为“钱包”的各个类别之间，并没有清晰的界限。

在本章中，我们将把钱包视为私钥的容器以及管理这些密钥的系统。



---
> [!TIP]
> **译者注**：
> 作为后端开发者，理解钱包时应将其解耦为“状态机接口”和“签名机”两部分。在代码实现中，钱包的核心逻辑通常封装在一个负责 `secp256k1` 签名和密钥派生的库中，而我们常见的手机 App 只是这个核心逻辑的 UI 壳子。
---

## 钱包技术概览 (Overview of Wallet Technologies)

在本节中，我们总结了用于构建用户友好、安全且灵活的以太坊钱包的各种技术。

设计钱包时的一个关键考量是平衡便捷性与隐私性。最方便的以太坊钱包是只使用单个私钥和地址来处理所有事务。不幸的是，这种方案是隐私噩梦，因为任何人都可以轻易追踪并关联你的所有交易。为每笔交易使用新密钥对隐私保护最好，但管理起来会变得非常困难。达到正确的平衡很难，这就是为什么优秀的钱包设计至关重要。

关于以太坊的一个常见误解是认为以太坊钱包里装有以太币（Ether）或代币（Tokens）。事实上，从严格意义上讲，钱包里只持有密钥。以太币或其他代币记录在以太坊区块链（Blockchain）上。用户通过使用钱包中的密钥签署交易，来控制网络上的代币。从某种意义上说，以太坊钱包就是一个“钥匙串”。话虽如此，考虑到钱包持有的密钥是向他人转移以太币或代币所需的唯一凭证，在实践中这种区别几乎无关紧要。

这种区别真正起作用的地方在于思维模式的转变：从处理传统银行业的中心化系统（只有你和银行能看到账户里的钱，你只需说服银行你想移动资金即可完成交易）转变为处理区块链平台的去中心化系统（所有人都能看到账户的以太币余额，尽管他们可能不知道账户的所有者，且必须向所有人证明所有者想要移动资金，交易才能生效）。在实践中，这意味着有一种独立的方法可以检查账户余额，而不需要该账户的钱包。此外，如果你不喜欢最初使用的钱包应用，你可以将账户处理迁移到另一个不同的钱包中。

> [!NOTE] 
> 以太坊钱包包含的是密钥，而不是以太币或代币。钱包就像包含成对私钥和公钥的钥匙串。用户使用私钥签署交易，从而证明他们拥有这些以太币。以太币存储在区块链上。


主要有两种类型的钱包，区别在于它们包含的密钥是否相互关联。

第一种是非确定性钱包（Nondeterministic Wallet），其中每个密钥都是从不同的随机数独立生成的。密钥之间没有关系。这类钱包也被称为 JBOK 钱包，源于短语“Just a Bunch Of Keys”（只是一堆密钥）。

第二种是确定性钱包（Deterministic Wallet），其中所有密钥都派生自一个称为种子（Seed）的主密钥。这类钱包中的所有密钥都相互关联，只要你拥有原始种子，就可以再次生成所有密钥。在确定性钱包中使用了几种不同的密钥派生方法。最常用的派生方法使用树状结构，正如“分层确定性钱包（Hierarchical Deterministic Wallets, BIP-32/BIP-44）”中所描述的那样。

为了使确定性钱包在面对数据丢失事故（例如手机被盗或掉进马桶）时更安全，种子通常被编码为一组单词列表（英文或其他语言），供你在发生意外时记下并使用。这些被称为钱包的助记词（Mnemonic code words）。当然，如果有人拿到了你的助记词，他们也可以重新创建你的钱包，从而获得你的以太币和智能合约的访问权。因此，请务必非常、非常小心地对待你的恢复单词列表！永远不要以电子方式存储它，不要存在电脑或手机的文件里。把它写在纸上，并存放在安全的地方。

接下来的几节将从高层视角介绍每种钱包技术。

### 非确定性（随机）钱包 (Nondeterministic (Random) Wallets)

在最初的以太坊钱包（为以太坊预售而制作）中，每个钱包文件都存储了一个单独随机生成的私钥。此类钱包正逐渐被确定性钱包（Deterministic Wallets）所取代，因为这些“旧式”钱包在许多方面都处于劣势。例如，在以太坊中，为了最大限度地保护隐私，不重复使用以太坊地址被视为一种良好的实践——也就是说，每次接收资金时都使用一个新的地址（这需要一个新的私钥）。你可以更进一步，为每笔交易都使用新地址，尽管如果你频繁处理代币（Tokens），这可能会变得非常昂贵。为了遵循这一实践，非确定性钱包需要定期增加其密钥列表，这意味着你需要进行定期的备份。如果你在成功备份钱包之前丢失了数据（磁盘故障、饮料泼洒、手机被盗），你将失去对资金和智能合约的访问权。“0 型”非确定性钱包（"Type 0" nondeterministic wallets）是最难处理的，因为它们会以“即时”的方式为每个新地址创建一个新的钱包文件。

尽管如此，许多以太坊客户端（包括 Geth）仍在使用密钥库文件（Keystore file），这是一种 JSON 编码的文件，包含一个（随机生成的）私钥，并由密码加密以提高安全性。该 JSON 文件的内容如下所示：

```json
{
    "address": "001d3f1ef827552ae1114027bd3ecf1f086ba0f9",
    "crypto": {
        "cipher": "aes-128-ctr",
        "ciphertext":
            "233a9f4d236ed0c13394b504b6da5df02587c8bf1ad8946f6f2b58f055507ece",
        "cipherparams": {
            "iv": "d10c6ec5bae81b6cb9144de81037fa15"
        },
        "kdf": "scrypt",
        "kdfparams": {
            "dklen": 32,
            "n": 262144,
            "p": 1,
            "r": 8,
            "salt":
                "99d37a47c7c9429c66976f643f386a61b78b97f3246adca89abe4245d2788407"
        },
        "mac": "594c8df1c8ee0ded8255a50caf07e8c12061fd859f4b7c76ab704b17c957e842"
    },
    "id": "4fcb2ba4-ccdb-424f-89d5-26cce304bf9c",
    "version": 3
}
```
密钥库格式使用密钥派生函数（Key Derivation Function, KDF），也称为密码强化算法（Password-stretching algorithm），用于防御暴力破解、字典攻击和彩虹表攻击。
简单来说，私钥并不是直接由密码加密的。相反，密码通过反复哈希运算被“强化”。哈希函数会重复执行 262,144 轮，这可以在密钥库 JSON 的 crypto.kdfparams.n 参数中看到。
尝试暴力破解密码的攻击者必须对每一次尝试的密码应用 262,144 轮哈希运算，这极大地减慢了攻击速度，使得具有适当复杂度和长度的密码在实践中无法被破解。

[!TIP] 除了简单的测试外，不建议使用非确定性钱包。它们备份起来太麻烦，除了最基础的场景外很难使用。相反，应使用基于行业标准、带有助记词种子（Mnemonic seed）用于备份的分层确定性钱包（Hierarchical Deterministic Wallets）。

### 确定性（种子）钱包 (Deterministic (Seeded) Wallets)

确定性钱包或“种子”钱包包含的私钥全部派生自一个单一的主密钥（Master Key），即种子（Seed）。种子是一个随机生成的数字，通过将其与索引号或“链码（Chain code）”（参见“扩展公钥与私钥”）等其他数据结合，可以派生出任意数量的私钥。
在确定性钱包中，仅凭种子就足以恢复所有派生出的密钥，因此在创建钱包时进行单次备份，就足以保护钱包中所有的资金和智能合约。种子也足以用于钱包的导出或导入，从而实现在不同钱包实现之间轻松迁移所有密钥。

这种设计使得种子的安全性变得至关重要，因为只需要种子即可获得整个钱包的访问权限。另一方面，能够将安全工作集中在单一数据片段上，也可以被视为一种优势。


### 分层确定性钱包 (Hierarchical Deterministic Wallets, BIP-32/BIP-44)

开发确定性钱包是为了能够轻松从单一种子派生出许多密钥。目前，确定性钱包最先进的形式之一是基于比特币 `BIP-32` 标准定义的**分层确定性（HD）钱包**。
HD 钱包包含以树状结构派生的密钥，使得父密钥可以派生出一系列子密钥，每个子密钥又可以派生出一系列孙密钥，依此类推。这种树状结构如图 5-1 所示。
![Figure 5-1](<./images/figure 5-1.png>)
图 5-1：HD 钱包——由单一种子生成的密钥树

相比于简单的确定性钱包，HD 钱包具有几个核心优势。首先，树状结构可以用来表达额外的组织含义。例如，可以使用特定的子密钥分支来接收付款，
而用另一个不同的分支来接收发送交易时的找零。密钥分支还可以用于公司设置中，将不同的分支分配给部门、子公司、特定职能或会计类别。

HD 钱包的第二个优势是，用户可以在不接触对应私钥的情况下创建一系列公钥。这使得 HD 钱包能够部署在不安全的服务器上，或者以“观察模式（Watch-only）”及“仅接收模式（Receive-only）”运行，此时钱包并不持有能够动用资金的私钥。

---
> [!TIP] 
> **译者注**：
> 1. **权限隔离的妙用**：HD 钱包的分层特性在后端权限管理中非常有用。例如，你可以将“父级公钥（Extended Public Key, xpub）”部署在不安全的只读服务器上，用于生成收币地址和监控账目，而将能够签名的私钥保留在离线环境中。即使只读服务器被攻破，攻击者也无法转走资金。
> 2. **标准协议链**：虽然 `BIP-32` 定义了分层结构，但以太坊进一步遵循了 `BIP-44` 标准。作为开发者，你会经常看到 `m/44'/60'/0'/0/i` 这样的路径，其中 `60'` 代表以太坊（Coin Type），这种标准化确保了你的账户可以在 MetaMask、Ledger 或 ImToken 之间完美互通。
---

### 种子与助记词 (Seeds and Mnemonic Codes, BIP-39)

为了安全地备份和检索私钥，有许多种编码方式。目前首选的方法是使用一系列单词，当按正确顺序组合在一起时，可以唯一地重新创建私钥。这有时被称为**助记词（Mnemonic）**，该方法已通过 `BIP-39` 标准化。如今，许多以太坊钱包（以及其他加密货币钱包）都使用这一标准，并可以使用互通的助记词导入和导出种子，以进行备份和恢复。

为了理解为什么这种方法变得流行，让我们看一个例子：

```text
FCCF1AB3329FD5DA3DA9577511F8F137 ← 十六进制形式的种子
wolf juice proud gown wool unfair
wall cliff insect more detail hub ← 使用 BIP-39 表示法的种子
```
从实际操作的角度来看，抄写十六进制序列时出错的概率高到难以接受。相比之下，已知单词的列表处理起来非常容易，这主要是因为单词的拼写（尤其是英文单词）具有很高的冗余度。如果在记录时不小心写成了 inzect，在需要恢复钱包时，
很快就能确定 inzect 不是一个有效的英文单词，而应该使用 insect 代替。我们讨论的是记录种子的某种表示形式，因为这是管理 HD 钱包的良好实践：在数据丢失（无论是由于意外还是被盗）的情况下，需要种子来恢复钱包，因此保持备份是非常谨慎的做法。
然而，种子必须保持极度私密，因此应小心避免数字化备份——这就是建议使用笔和纸进行备份的原因。
简而言之，使用恢复单词列表来编码 HD 钱包的种子，是安全导出私钥集、转录、记录在纸上、无误读取以及将其导入另一个钱包的最简便方法。

## 钱包最佳实践 (Wallet Best Practices)

随着加密货币钱包技术的成熟，已经形成了一些特定的行业标准，这些标准使得钱包具有广泛的互操作性、易用性、安全性和灵活性。这些标准还允许钱包从单一助记词中派生出多种不同加密货币的密钥。这些标准包括：

* 基于 `BIP-39` 的**助记词** (Mnemonic code words)
* 基于 `BIP-32` 的**分层确定性钱包** (HD wallets)
* 基于 `BIP-43` 的**多用途 HD 钱包结构** (A multipurpose HD wallet structure)
* 基于 `BIP-44` 的**多币种和多账户钱包** (Multicurrency and multiaccount wallets)

这些标准可能会随着未来的发展而改变或被废弃，但目前，它们构成了一套环环相扣的技术，已成为大多数区块链平台及其加密货币的事实上的钱包标准。

广泛的软件和硬件钱包已经采用了这些标准，使得所有这些钱包都具有互操作性。用户可以导出一个钱包中生成的助记词，并将其导入到另一个钱包中，从而恢复所有的密钥和地址。

支持这些标准的软件钱包示例包括 **Rabby Wallet**、**MetaMask** 和 **Phantom**。支持这些标准的硬件钱包示例包括 **Ledger** 和 **Trezor** 的各种型号。

接下来的章节将详细研究这些技术中的每一项。



> [!TIP]
> 如果你正在开发一个以太坊钱包，它应该被构建为分层确定性（HD）钱包，并按照接下来的章节所述，遵循 `BIP-32`、`BIP-39`、`BIP-43` 和 `BIP-44` 标准，使用编码为助记词的种子进行备份。

### 助记词 (Mnemonic Code Words, BIP-39)

助记词是编码随机数的单词序列，该随机数用作派生确定性钱包的种子。单词序列足以重新创建种子，并由此重新创建钱包及所有派生密钥。实现带有助记词的确定性钱包应用程序在首次创建钱包时，会向用户展示一段包含 12 到 24 个单词的序列。该单词序列即为钱包备份，可用于在相同或任何兼容的钱包应用中恢复并重新创建所有密钥。正如我们之前所解释的，助记词列表使用户更容易备份钱包，因为它们易于阅读且能被准确转录。

> [!NOTE]
> 助记词经常与**脑钱包 (Brainwallets)** 混淆。它们并不相同。主要区别在于：脑钱包由用户自行选择单词，而助记词由钱包随机创建并展示给用户。这一重要区别使得助记词要安全得多，因为人类在提供随机性方面表现极差。或许更重要的是，使用“脑钱包”一词暗示这些单词必须被记住，这是一个极其糟糕的主意，也是在需要备份时却无法找到备份的隐患。

助记词在 `BIP-39` 标准中定义。请注意，`BIP-39` 只是助记词标准的一种实现方式。Electrum 比特币钱包使用另一种早于 `BIP-39` 的标准，且拥有一套不同的单词库。`BIP-39` 是由 Trezor 硬件钱包背后的公司提出的，与 Electrum 的实现不兼容。然而，`BIP-39` 目前已获得数十种互操作实现的广泛行业支持，应被视为事实上的行业标准。此外，`BIP-39` 可用于生成支持以太坊的多币种钱包，而 Electrum 种子则不行。

`BIP-39` 定义了助记词和种子的创建过程，我们在此将其分为九个步骤。为了清晰起见，该过程分为两部分：第 1 至 6 步列在“生成助记词”中，第 7 至 9 步列在“从助记词到种子”中。

### 生成助记词 (Generating Mnemonic Words)

钱包根据 `BIP-39` 定义的标准流程自动生成助记词。钱包从熵源开始，添加校验和，然后按照以下步骤将熵映射到单词列表：

1.  创建一个长度为 $128$ 到 $256$ 位的密码学随机序列 $S$（熵）。
2.  通过取 $S$ 的 `SHA-256` 哈希值的前（$S$ 的长度 $\div 32$）位，创建 $S$ 的校验和（Checksum）。
3.  将该校验和添加到随机序列 $S$ 的末尾。
4.  将“序列+校验和”的组合划分为每段 $11$ 位的部分。
5.  将每个 $11$ 位的值映射到包含 $2048$ 个预定义单词的字典中的一个单词。
6.  按顺序组合这些单词，创建助记词。

图 5-2 展示了如何使用熵生成助记词。
![Figure 5-2](<./images/figure 5-2.png>)
图 5-2：生成助记词 (Generating Mnemonic Words)

表 5-1 展示了熵数据的大小与助记词长度（以单词数为单位）之间的对应关系。

表 5-1：熵的大小与生成的助记词长度
![Table 5-1](<./images/table 5-1.png>)

#### 从助记词到种子 (From Mnemonic to Seed)

助记词代表了长度为 $128$ 到 $256$ 位的熵。随后，通过使用密钥拉伸函数 `PBKDF2`，该熵被用于派生一个更长（$512$ 位）的种子。生成的种子将用于构建确定性钱包并派生其密钥。

密钥拉伸函数接收两个参数：**助记词**和**盐（Salt）**。在密钥拉伸函数中使用盐的目的是为了增加构建查找表（即彩虹表）的难度，从而防御暴力破解攻击。在 `BIP-39` 标准中，盐还有另一个用途：它允许引入一个**密码短语（Passphrase）**，作为保护种子的额外安全因子，我们将在下一节详细描述。

该流程接续前一节的步骤：

7. `PBKDF2` 密钥拉伸函数的第一个参数是步骤 6 中生成的助记词。
8. `PBKDF2` 密钥拉伸函数的第二个参数是**盐**。盐由字符串常量 `"mnemonic"` 与一个可选的用户自定义密码短语连接而成。
9. `PBKDF2` 使用 `HMAC-SHA512` 算法对助记词和盐参数进行 $2048$ 轮哈希拉伸，产生一个 $512$ 位的值作为最终输出。该 $512$ 位的值即为**种子**。

图 5-3 展示了如何使用助记词生成种子。
![Figure 5-3](<./images/figure 5-3.png>)
图 5-3：从助记词到种子 (From Mnemonic to Seed)
> [!NOTE]
> 包含 $2048$ 轮哈希的密钥拉伸函数是对抗助记词或密码短语暴力破解攻击的一种较为有效的保护手段。它使得尝试数千个以上的密码短语与助记词组合的成本（计算量）变得非常高，而可能派生出的种子数量是巨大的（
>$$2^{512}$$，约为
> $$10^{154}$$
> ）——这远大于观测宇宙中的原子总数（约为 $10^{80}$）。

表 5-2、5-3 和 5-4 展示了一些助记词及其生成的种子的示例。
表 5-2：不带密码短语的 128 位熵助记词及其生成的种子
![Table 5-2](<./images/table 5-2.png>)
表 5-3：带有密码短语的 128 位熵助记词及其生成的种子
![Table 5-3](<./images/table 5-3.png>)
表 5-4：不带密码短语的 256 位熵助记词及其生成的种子
![Table 5-4](<./images/table 5-4.png>)

#### BIP-39 中的可选密码短语 (Optional Passphrase in BIP-39)

`BIP-39` 标准允许在派生种子时使用一个可选的密码短语（Passphrase）。如果不使用密码短语，助记词将使用由常量字符串 `"mnemonic"` 组成的盐（Salt）进行拉伸，从而为任何给定的助记词生成一个特定的 $512$ 位种子。如果使用了密码短语，拉伸函数将从同一组助记词中生成一个**完全不同**的种子。

事实上，对于单组助记词，每一个可能的密码短语都会导向一个不同的种子。本质上，**并不存在“错误”的密码短语**。所有的密码短语都是有效的，它们都指向不同的种子，形成了一套庞大的未初始化钱包集合。由于可能的钱包集合空间巨大（$2^{512}$），只要密码短语具有足够的复杂度和长度，实际上不存在被暴力破解或意外撞上已使用钱包的可能性。


> [!TIP]
> 在 `BIP-39` 中没有“错误”的密码短语。每一个密码短语都会导向某个钱包。除非该钱包之前被使用过，否则它最初将是空的。

密码短语创造了两个核心特性：
1.  **第二因子（记忆项）**：它使得助记词备份在物理上被盗时仍具有保护作用，因为窃贼缺少了用户大脑中记忆的那个“额外单词”。
2.  **某种形式的“隐写保护”或“胁迫钱包”**：用户可以准备一个简单的密码短语来导向一个存有少量资金的钱包，用于在受到威胁时分散攻击者注意力（即“诱饵钱包”），而将大额资产隐藏在另一个复杂密码短语导向的真实地址中。

然而，使用密码短语也引入了风险：
* **永久丢失风险**：如果钱包所有者丧失行为能力或去世，且没有其他人知道密码短语，那么即持有助记词也无法找回资产。
* **备份陷阱**：如果所有者将密码短语与助记词记录在同一张纸上，则完全失去了“双因子验证”的安全性，且增加了备份的复杂性。

虽然密码短语（Passphrase）非常有用，但应仅在配合周密的备份与恢复计划时使用。必须考虑到在所有者去世后，其继承人是否能够通过该流程恢复加密货币资产。

#### 使用助记词码（Working with Mnemonic Codes）

BIP-39 标准已在多种编程语言中以库的形式实现，例如：

* **python-mnemonic**
由提出 BIP-39 的 SatoshiLabs 团队维护的 Python 语言官方参考实现。
* **ConsenSys/eth-lightwallet**
一个适用于节点和浏览器的轻量级 JavaScript 以太坊（Ethereum）钱包实现，支持 BIP-39。
* **npm/bip39**
比特币 BIP-39 标准的 JavaScript 实现。

此外，还有一个实现在独立网页中的 BIP-39 生成器（图 5-4），这对于测试和实验非常有用。该助记词码转换器（Mnemonic Code Converter）可以生成助记词、种子（Seeds）以及扩展私钥（Extended Private Keys）。它可以离线在浏览器中使用，也可以在线访问。

> [!Note]
> 本章将反复强调这一点，因为这是种子安全（Seed Security）中最关键的规则：在任何情况下，切勿以数字形式保存你的助记词（Seed Phrase）。

![Figure 5-4](<./images/figure 5-4.png>)
图 5-4 网页中的 BIP-39 生成器

### 从种子创建分层确定性钱包（Creating an HD Wallet from the Seed）
分层确定性钱包（HD Wallets）是从一个单一的**根种子（Root Seed）**创建而成的，该种子是一个 128 位、256 位或 512 位的随机数。正如前一节所述，该种子通常由助记词（Mnemonic）生成。

HD 钱包中的每一个密钥都是从这个根种子中**确定性地派生（Deterministically Derived）**出来的。这意味着在任何兼容 HD 钱包标准的实现中，都可以仅凭该种子重新创建整个 HD 钱包。通过仅传输派生出根种子的助记词，即可轻松地导出、备份、恢复和导入包含成千上万甚至数百万个密钥的 HD 钱包。

### 分层确定性钱包（HD Wallets / BIP-32）
大多数 HD 钱包都遵循 BIP-32 标准，该标准已成为确定性密钥生成的行业事实标准。我们在此不会讨论 BIP-32 的所有细节，仅涵盖理解其在钱包中应用所必需的组件。最核心的特性是派生密钥之间可能存在的树状分层关系（Treelike Hierarchical Relationships），如图 5-1 所示。此外，理解**扩展密钥（Extended Keys）和增强密钥（Hardened Keys）**的概念也至关重要，这些内容将在接下来的章节中解释。

许多软件库提供了数十种可互操作的 BIP-32 实现。这些库大多是为比特币（Bitcoin）钱包设计的，虽然比特币的地址实现方式不同，但它们与以太坊（Ethereum）兼容 BIP-32 的钱包共享相同的密钥派生实现。你可以直接使用专为以太坊设计的库，或者通过添加以太坊地址编码库来改造比特币的实现版本。

此外，还有一个作为独立网页实现的 BIP-32 生成器，对于测试和实验 BIP-32 非常有用。

[!WARNING] 该独立 BIP-32 生成器并非 HTTPS 网站。这是为了提醒你：使用此工具并不安全。它仅供测试使用，切勿将该网站生成的密钥用于存放真实资金。

#### 扩展公钥与私钥（Extended Public and Private Keys）
在 BIP-32 术语中，密钥可以被“扩展（Extended）”。通过特定的数学运算，这些扩展的“父（Parent）”密钥可以被用来派生“子（Child）”密钥，从而产生前面所述的密钥和地址层级结构。父密钥不一定非得处于树的最顶端，它可以是树状层级结构中任何位置的密钥。

扩展一个密钥涉及取密钥本身并附加一个特殊的链码（Chain Code）。链码是一个 256 位的二进制字符串，它与每个密钥混合以产生子密钥。
如果该密钥是私钥，它就会成为一个扩展私钥（Extended Private Key），以前缀 xprv 作为标识：
```
xprv9s21ZrQH143K2JF8RafpqtKiTbsbaxEeUaMnNHsm5o6wCW3z8ySyH4UxFVSfZ8n7ESu7fgir8i...
```
而**扩展公钥（Extended Public Key）**则以前缀 xpub 作为标识：
```
xpub661MyMwAqRbcEnKbXcCqD2GT1di5zQxVqoHPAgHNe8dv5JP8gWmDproS6kFHJnLZd23tWevhdn...
```
HD 钱包一个非常有用的特性是：能够在没有私钥的情况下，直接从父级公钥派生出子级公钥。这为我们提供了两种派生子级公钥的途径：要么直接从子级私钥派生，要么从父级公钥派生。因此，一个扩展公钥可以被用来派生该 HD 钱包结构分支中所有的公钥（且仅限公钥）。

这种“快捷方式”可用于创建极其安全的“仅限公钥（Public-key-only）”部署方案。在这种场景下，服务器或应用程序仅持有扩展公钥的副本，而完全不持有任何私钥。此类部署可以生成无限数量的公钥和以太坊地址（Ethereum Addresses），但无法花费发送到这些地址的任何资金。与此同时，在另一台更安全的服务器上，扩展私钥可以派生出所有对应的私钥，用于签署交易并消费资金。

此方法的一个常见应用是在运行电子商务应用的 Web 服务器上安装扩展公钥。Web 服务器可以使用公钥派生函数为每笔交易（例如客户的购物车）创建一个新的以太坊地址，且服务器上不会有任何可能被盗的私钥。如果没有 HD 钱包，实现这一目标的唯一方法是在一台独立的物理隔离服务器上预先生成数千个以太坊地址，然后将它们预载到电商服务器上。这种方法非常繁琐，需要持续维护以确保服务器不会耗尽地址——因此，人们更倾向于使用 HD 钱包的扩展公钥。

另一个常见应用是冷存储（Cold-storage）或硬件钱包。在这种场景下，扩展私钥可以存储在硬件钱包中，而扩展公钥可以保持在线。用户可以随意创建“接收”地址，而私钥则安全地保存在线下。若要花费资金，用户可以在离线签名终端中使用扩展私钥，或者直接在硬件钱包设备上进行交易签名。
