# 第十四章：以太坊虚拟机

以太坊虚拟机（EVM）是以太坊协议和运行的核心。正如你从名字中猜到的那样，它是一个计算引擎，与微软 .NET 框架的虚拟机或 Java 等其他字节码编译语言的解释器并没有本质区别。
在本章中，我们将深入探讨 EVM 的指令集、架构及其在以太坊状态更新背景下的运作方式。

## 什么是 EVM
EVM（以太坊虚拟机）是以太坊中负责处理智能合约部署与执行的核心部分。从实际操作层面来看，从一个外部账户（EOA）到另一个外部账户的简单价值转账交易并不需要它参与；
除此之外，几乎所有的操作都会涉及由 EVM 计算的状态更新。从宏观角度来看，运行在以太坊区块链上的 EVM 可以被视为一台全球化的去中心化计算机，
它包含数百万个可执行对象，每个对象都有其独立的永久数据存储库。

EVM 是一个**准图灵完备**（Quasi-Turing-Complete）状态机：之所以说它是“准”完备，是因为所有的执行过程都受限于气数（Gas）的额度，
而 Gas 限制了任何给定智能合约执行的计算步数。因此，**停机问题**（Halting Problem）得到了“解决”（所有程序的执行最终都会停止），
从而避免了执行过程（因意外或恶意）永久运行并导致整个以太坊平台陷入停滞的情况。我们将在本章稍后部分更详细地探讨停机问题。

EVM 采用栈式架构（Stack-Based Architecture），将所有内存中的数值存储在栈（Stack）上。
它的字长（Word Size）为 256 位，这主要是为了便于进行原生的哈希运算和椭圆曲线运算。它拥有以下几个可寻址的数据组件：
* 不可变的程序代码 ROM：加载了待执行智能合约的字节码。
* 易失性内存（Memory）：每个位置在初始状态都被显式地置为零。
* 瞬时存储（Transient Storage）：仅在单笔交易期间存在（且不属于以太坊状态的一部分）。
* 永久存储（Storage）：是以太坊状态的一部分，初始状态同样被置为零。

此外，在执行期间还有一组环境变量和数据可供调用。我们将在本章稍后部分详细介绍这些内容。
![Figure 14-1](<./images/figure 14-1.png>)

图 14-1. EVM 架构与执行上下文

## 与现有技术的比较
“虚拟机”一词通常应用于对真实计算机的虚拟化——通常由 VirtualBox 或 QEMU 等管理程序（Hypervisor）实现；
或者是对整个操作系统实例的虚拟化，如 Linux 的 KVM。这些技术必须分别提供对实际硬件、系统调用以及其他内核功能的软件抽象。

EVM 的运行领域则受限得多：它仅仅是一个计算引擎，因此仅提供对计算和存储的抽象，这一点类似于 Java 虚拟机（JVM）规范。
从宏观角度看，JVM 旨在提供一个与底层主机操作系统或硬件无关的运行环境，从而实现跨多种系统的兼容性。
诸如 Java、Scala（使用 JVM）或 C#（使用 .NET）等高级编程语言，都会被编译成各自虚拟机的字节码指令集。
同样地，EVM 执行其专有的字节码指令集（将在下一节描述），而 Solidity、Vyper 和 Yul 等高级智能合约编程语言也会被编译成这种字节码。

因此，EVM 不具备调度能力，因为执行顺序是在其外部组织的：以太坊客户端通过扫描经过验证的区块交易，
来确定哪些智能合约需要执行以及按何种顺序执行。从这个意义上说，以太坊世界计算机是单线程的，类似于 JavaScript。
EVM 也不具备任何“系统接口”处理或“硬件支持”——因为它没有物理机器可以进行接口交互。以太坊世界计算机是完全虚拟的。

## 其他区块链在做什么？

EVM 绝对是加密货币领域应用最广泛的虚拟机。大多数竞争性 L1（第一层）和 L2（第二层）区块链都采用 EVM，以保持与现有工具和框架的兼容性，
并直接从以太坊社区吸引项目和开发者。

尽管如此，近年来也涌现出了一批各具特色的虚拟机：Solana VM、Wasm VM、Cairo VM 和 Move VM 可能是其中最著名且最有趣的，
它们各有利弊。这些虚拟机在智能合约开发路线上采取了不同的方案：

**自定义语言**

一些平台（如 Cairo 和 Move）创建了专门用于编写智能合约的编程语言。这类似于以太坊为其虚拟机 EVM 使用 Solidity 和 Vyper。

**标准语言**

其他平台（如 Solana 和使用 WebAssembly (Wasm) 的平台）允许开发者使用广泛通用的编程语言编写智能合约。
例如，这些平台通常支持使用 Rust 进行开发。

这些替代虚拟机与 EVM 的另一个不同之处在于交易的并行化（Parallelization）。我们已经提到过，EVM 按顺序处理交易，没有任何形式的并行化。
一些项目针对这一缺陷进行了改进。例如，Solana VM 和 Move VM 都能处理交易的并行执行，尽管这并非在所有情况下都可行——也就是说，
当两笔交易通过与同一个合约交互来修改同一块存储空间时，它们无法并行执行。

必须说明的是，这些改进虚拟机性能的努力并不仅仅发生在以太坊之外。事实上，许多团队正致力于突破 EVM 的当前限制，
尝试引入并行化以及其他酷炫功能，例如将 EVM 字节码**提前编译**（AOT）或**即时编译**（JIT）为原生机器码。

## EVM 指令集（字节码操作）
EVM 指令集提供了你所预期的大多数操作，包括：
* 算术及位逻辑运算
* 执行上下文查询
* 栈（Stack）、内存（Memory）及存储（Storage）访问
* 流程控制操作
* 日志、调用及其他操作符

除了典型的字节码操作外，EVM 还可以访问账户信息（如地址和余额）和区块信息（如区块高度和当前气价）。

让我们通过查看可用的操作码（Opcodes）及其功能，开始对 EVM 进行更深入的探索。正如你所预料的，所有操作数（Operands）均取自栈顶，而执行结果（如果适用）通常会被重新压回栈顶。

可用的操作码可以分为以下几类：
### 算术运算 (Arithmetic Operations)
算术操作码指令包括：
```
ADD // 将栈顶的两个项相加
MUL // 将栈顶的两个项相乘
SUB // 将栈顶的两个项相减
DIV // 整数除法
SDIV // 有符号整数除法
MOD // 取模（余数）运算
SMOD // 有符号取模运算
ADDMOD // 对任意数取模的加法运算
MULMOD // 对任意数取模的乘法运算
EXP // 指数运算
SIGNEXTEND // 扩展补码有符号整数的长度
SHA3 // 计算内存块的 Keccak-256 哈希值
```
除非另有说明，所有算术运算均在模 $2^{256}$ 的前提下进行，且 $0^0$ 的值取为 1。

### 栈操作
栈、内存及存储管理指令包括：
```
POP // 从栈顶移除一个项
MLOAD // 从内存中加载一个字（32 字节）到栈
MSTORE // 将一个字从栈保存到内存
MSTORE8 // 将一个字节从栈保存到内存
SLOAD // 从永久存储中加载一个字到栈
SSTORE // 将一个字从栈保存到永久存储
TLOAD // 从瞬时存储中加载一个字到栈
TSTORE // 将一个字从栈保存到瞬时存储
MSIZE // 获取当前活跃内存的大小（以字节为单位）
PUSH0 // 将数值 0 压入栈顶
PUSHx // 将 x 字节的项目压入栈顶，其中 x 为 1 到 32（全字）之间的任意整数
DUPx // 复制第 x 个栈项，其中 x 为 1 到 16 之间的任意整数
SWAPx // 交换第 1 个和第 (x+1) 个栈项，其中 x 为 1 到 16 之间的任意整数
```

### 流程控制操作
用于控制执行流程的指令包括：
```
STOP // 停止执行
JUMP // 将程序计数器（PC）设置为任意值
JUMPI // 有条件地修改程序计数器（即条件跳转）
PC // 获取程序计数器的当前值（在该指令本身引起的增量之前的值）
JUMPDEST // 标记一个有效的跳转目标地址
```

### 系统操作 
用于执行程序的系统级操作码包括：
```
LOGx // 附加一条带有 x 个主题（Topics）的日志记录，其中 x 为 0 到 4 之间的任意整数。
CREATE // 创建一个带有相关代码的新账户（即部署新合约）。
CALL // 对另一个账户进行消息调用，即运行另一个账户的代码。
CALLCODE // 在当前账户环境中运行另一个账户的代码（已基本被替代）。
RETURN // 停止执行并返回输出数据。
DELEGATECALL // 在当前账户环境中运行另一个账户的代码，但保留原始发送者（Sender）和价值（Value）信息。
STATICCALL // 对账户进行静态消息调用，即不允许修改任何账户的状态。
REVERT // 停止执行并回滚状态更改，但返回错误信息并退还剩余气数（Gas）。
INVALID // 指定的无效指令。
SELFDESTRUCT // 停止执行；如果在创建合约的同一笔交易中执行，则将账户注册为待删除。请注意，目前强烈不建议使用此指令，且该操作码已被视为“废弃”状态。
```

### 逻辑运算（Logic operations）
用于比较和位逻辑运算的操作码包括：
```
LT // 小于（Less-than）比较
GT // 大于（Greater-than）比较
SLT // 有符号小于比较
SGT // 有符号大于比较
EQ // 等于（Equality）比较
ISZERO // 简单的非（NOT）运算符，检查值是否为 0
AND // 按位与（AND）运算
OR // 按位或（OR）运算
XOR // 按位异或（XOR）运算
NOT // 按位取反（NOT）运算
BYTE // 从一个 256 位全宽字（Word）中提取单个字节
```

### 环境操作 (Environmental Operations)
处理执行环境信息的操考码包括：
```
GAS // 获取当前可用的气数（Gas）余额（扣除本条指令的消耗后）。
ADDRESS // 获取当前正在执行的账户地址。
BALANCE // 获取指定账户的以太币余额。
ORIGIN // 获取发起本次 EVM 执行的外部账户（EOA）地址（即交易的原始发起者）。
CALLER // 获取直接发起本次执行的调用者地址。
CALLVALUE // 获取本次调用由调用者存入的以太币金额。
CALLDATALOAD // 获取调用者发送的输入数据（Calldata）。
CALLDATASIZE // 获取输入数据的字节大小。
CALLDATACOPY // 将输入数据复制到内存中。
CODESIZE // 获取当前环境运行的代码大小。
CODECOPY // 将当前环境运行的代码复制到内存中。
GASPRICE // 获取原始交易指定的单位气价。
EXTCODESIZE // 获取指定外部账户的代码大小。
EXTCODECOPY // 将指定外部账户的代码复制到内存中。
RETURNDATASIZE // 获取当前环境下上一次调用返回的输出数据大小。
RETURNDATACOPY // 将上一次调用的输出数据复制到内存中。
```

### 区块操作 (Block Operations)

用于获取当前区块信息的操考码包括：
```
BLOCKHASH // 获取最近完成的 256 个区块之一的哈希值。
COINBASE // 获取该区块奖励的受益人地址（即打包该区块的验证者地址）。
TIMESTAMP // 获取该区块的时间戳。
NUMBER // 获取当前区块的高度（区块编号）。
PREVRANDAO // 获取前一个区块的 RANDAO 混合值。自“合并（The Merge）”硬分叉以来，该操作码取代了原有的 DIFFICULTY（难度）操作码。
GASLIMIT // 获取该区块的气数限制（Gas Limit）。
```

## 以太坊状态
EVM 的工作是根据以太坊协议的定义，通过计算智能合约代码执行产生的有效状态转换来更新以太坊状态。
这一特性使得以太坊被描述为一种基于交易的状态机 (Transaction-based State Machine)，
反映了外部参与者（即账户持有者和验证者）通过创建、接受和排序交易来启动状态转换的事实。此时，了解什么构成了以太坊状态是很有帮助的。

在顶层，我们有以太坊全局状态 (Ethereum World State)。全局状态是自以太坊地址（160 位数值）到账户的映射。在底层，每个以太坊地址代表一个账户，包含以下内容：
以太币余额 (Ether Balance)：以该账户拥有的 Wei 数量存储。
Nonce：如果是外部账户（EOA），代表从该账户成功发送的交易数量；如果是合约账户，则代表由其创建的合约数量。
账户存储 (Account Storage)：仅供智能合约使用的永久数据存储库。
账户程序代码 (Program Code)：同样仅存在于智能合约账户中。

传统上，EOA 既没有代码也没有存储。然而，[EIP-7702](https://eips.ethereum.org/EIPS/eip-7702)（于 2025 年 5 月的 Pectra 升级中激活）改变了这一假设，允许 EOA 将代码执行委托给智能合约。当 EOA 选择委托时，其代码字段会被设为一个 23 字节的委托标识 (Delegation Designation)，格式为 `0xef0100 || address`，其中 address 是目标合约的 20 位地址。根据 [EIP-3541](https://eips.ethereum.org/EIPS/eip-3541)，`0xef` 字节是一个被禁用的操作码，确保此标识不会与可部署的合约代码混淆。当 EVM 遇到对已委托 EOA 的调用时，它会在该 EOA 的上下文中加载并执行目标地址的代码。这意味着对委托 EOA 执行 EXTCODESIZE 会返回 23（委托标识的大小），而在委托代码内执行 CODESIZE 则返回目标合约代码的大小。EOA 在执行委托代码时也可以使用存储，尽管协议建议使用 [ERC-7201](https://eips.ethereum.org/EIPS/eip-7201) 命名空间存储布局，以防止在迁移委派合约时发生冲突。重要的是，已委托的 EOA 仍然可以发起交易——它们依然是可以签名发送交易的 EOA，只是现在具备了智能合约的能力。通过委托给零地址可以清除该委托（`0x0000000000000000000000000000000000000000`）。

当一笔交易触发智能合约代码执行时，一个 EVM 实例会被初始化，并包含当前创建区块及所处理交易相关的所有必要信息。特别地，EVM 的程序代码 ROM 会加载被调用合约账户的代码，程序计数器置零，从合约账户加载存储，内存全部置零，并设置所有区块和环境变量。一个关键变量是本次执行的 Gas 供应量。随着代码执行，Gas 供应量根据操作消耗而减少。如果在任何时刻 Gas 供应量小于零，就会触发 Gas 耗尽 (OOG) 异常：执行立即停止，交易被放弃。除了发送者的 Nonce 增加且余额减少（用于支付资源消耗）外，不会对以太坊状态应用任何更改。此时，你可以将 EVM 视为在以太坊全局状态的沙盒副本上运行，如果执行失败，该沙盒版本将被彻底丢弃。只有在执行成功时，真实世界状态才会更新以匹配沙盒版本。

代码执行是一个递归过程。一个合约可以调用其他合约，每次调用都会围绕新的调用目标实例化另一个 EVM。每个实例的沙盒世界状态都由上一层 EVM 的沙盒状态初始化。每个实例（上下文）也会被分配特定数量的 Gas 供应量（当然不会超过上一层剩余的 Gas），因此它也可能因 Gas 不足而异常停止。在这种情况下，该层的沙盒状态被丢弃，执行返回到上一层 EVM。


## 以太坊无状态性 (Ethereum Statelessness)

尽管在撰写本文时（2025 年 6 月），所有以太坊节点都必须计算并维护最新的状态——即我们之前提到的“全局状态（World State）”——以便通过重新执行区块中包含的所有交易来校验每一个新区块的正确性，但目前已有计划在一定程度上摆脱这一限制。

其核心思路是：让一组受限的角色（如搜索者 Searchers 和构建者 Builders）仍然持有完整状态以创建并发布新区块，而所有其他节点可以在不持有状态的情况下，通过密码学手段验证这些区块。这被称为无状态性（Statelessness）。

无状态性在以太坊路线图中仍处于较远的位置，因为它需要对核心协议进行一些关键修改：

**Enshrined proposer-builder separation (ePBS)**

将填充交易以创建区块的工作与向 P2P 网络提议区块的工作分离。 第一项工作由被称为“搜索者（Searchers）”和“构建者（Builders）”的高度专业化实体完成，他们能够创建极其优化的区块；而第二项工作则由以太坊验证者（Validator）节点完成。尽管这一机制尚未在协议层正式确立（即“原生化”），但在主网上已成为现实。事实上，目前绝大多数以太坊区块已经由极少数的大型构建者所构建。

**Verkle trees**

对以太坊当前用于存储状态的数据结构——默克尔-帕特里夏树（Merkle-Patricia Trie）进行更换。 这将大幅缩减验证状态正确性所需的密码学证明（Proof）的大小，并使验证速度比传统的默克尔-帕特里夏树更快。

> [!Note]
> 目前也在测试其他基于哈希的二叉树，以作为维尔克树（Verkle trees）的潜在替代方案。 其核心思路始终如一：即为状态构建一种数据结构，使其能够生成小型证明，并确保这些证明的验证过程既快速又简便。

这两项升级的结合将催生这样一种场景：只有那些拥有强大硬件、并希望创建区块的大型实体才需要存储和访问完整的状态。 在生成新区块的同时，他们还会创建一个密码学证人（Cryptographic Witness）：这是一组最小化的数据集，能够证明新状态是基于区块中所包含的交易正确计算得出的。

所有其他节点（包括验证者节点）仅存储状态根（State Root），即整个状态的哈希值。当它们接收到一个新区块时，只需利用相关的“证人”即可验证其正确性。

这使得运行以太坊节点变得非常轻量化，因为你既不需要存储完整状态，甚至不需要（在 EVM 内部）重新执行所有交易，但你依然能够验证一切是否正确，从而无需信任第三方。你甚至可以在智能手机上运行一个节点……

尽管研究进展神速，但距离在主网上实现无状态性可能仍有数年之久。

## 默克尔-帕特里夏树 (Merkle-Patricia Trie)

目前，以太坊的状态是使用一种非常特殊的数据结构来存储的，称为改进后的默克尔-帕特里夏树（Modified Merkle-Patricia Trie，简称 MPT）。我们在前一节中简要提到了它，但深入理解它的工作原理、设计初衷，以及以太坊如何利用它来存储状态（不仅限于此）是非常重要的，因为同样的逻辑也适用于未来的 Verkle 树。在深入研究 MPT 之前，你需要先了解默克尔树（Merkle Trees），因为它们是构建 MPT 的基石。

### 默克尔树 (Merkle Trees)

默克尔树是一种历史悠久的数据结构，由 Ralph Merkle 于 1988 年发明，最初旨在构建更优的数字签名。当你需要验证某些数据是否存在于数据库中且未被篡改，同时又不想发送整个数据库来证明时，这种结构非常高效。

从一组数据集合开始创建默克尔树非常简单。首先，你需要将数据分成若干个块（Chunks）；接着，将这些数据块两两配对进行哈希运算；然后递归地重复最后这一步骤，直到最终只剩下一个数据块。这个块即代表默克尔根（Merkle Root）：它是用于创建这棵树的所有数据的一种数字指纹。

让我们从头开始构建一个二叉默克尔树（Binary Merkle Tree）——这是默克尔树最简单的形式——以便你更深入地了解它。我们从 8 个数据块开始（你可以把它们想象成 8 个不同的英语单词）。我们使用特定的哈希函数对每个数据块进行哈希处理（正如第 4 章提到的，以太坊使用 Keccak-256 哈希函数），从而得到默克尔树的叶子节点（Leaves），在图 14-2 中分别表示为 hash_1、hash_2 等。接着，我们将每两片叶子连接（Concatenate）在一起并再次哈希，生成 hash_12、hash_34 等。我们将这种连接并哈希的过程再重复两次，直到得到一个最终结果，即我们的默克尔根：hash_12345678。
![Figure 14-2](<./images/figure 14-2.png>)

图 14-2. 二叉默克尔树

现在，你可能会问：为什么我们需要用默克尔树来存储数据？这难道不比直接把每个数据块存进传统数据库更复杂吗？

答案是肯定的，这确实比将数据块存入键值对（Key-Value）数据库或 SQL 数据库要复杂得多。我们之所以使用这类数据结构，唯一的逻辑在于：它们能以极低的成本提供密码学证明（Cryptographic Proof），从而证实某个特定数据块确实存在于整个集合中，且未被篡改。事实上，如果我们使用普通数据库存储数据，当被要求证明我们拥有某个特定数据块时，我们必须公开整个数据集，这样读取者才能确信我们没有撒谎。

让我们用之前的例子来看看这在实践中是如何运作的。假设我们想证明 data_1 包含在数据集中。

朴素方法：提供整个数据集，从 data_1 到 data_8：总共 8 个项。

默克尔树方法：我们只需要提供 hash_2、hash_34 和 hash_5678。接着，任何人都可以自行计算默克尔根，并将其与我们最初计算（并公开分享）的根进行比对。如果两者匹配，你就可以完全确定 data_1 是原始数据集的一部分，如图 14-3 所示。
![Figure 14-3](<./images/figure 14-3.png>)

图 14-3. 用于验证 data_1 包含在树中的默克尔证明

> [!Tip]
> 重构默克尔树（验证证明）可以遵循以下步骤：
> 1. 对 data_1 进行哈希，得到 hash_1。
> 2. 将 hash_1 与提供的 hash_2 拼接并哈希，得到 hash_12。
> 3. 将 hash_12 与提供的 hash_34 拼接并哈希，得到 hash_1234。
> 4. 将 hash_1234 与提供的 hash_5678 拼接并哈希，得到最终的默克尔根（Merkle root）。

请注意，我们仅使用了三个项，而如果不使用默克尔树的朴素方法，则需要使用全部八个项。这还只是一个简单的示例——当数据量巨大时，节省的成本会呈指数级增长。从数学角度来看，默克尔树提供的是 $O(\log n)$ 的复杂度，而朴素方法则是线性复杂度 $O(n)$，如图 14-4 所示。
![Figure 14-4](<./images/figure 14-4.png>)
图 14-4. $O(n)$ 线性复杂度（上方）与 $O(\log n)$ 复杂度（下方）的对比

在以太坊的世界里，这意味着为某个地址的余额、某笔交易的结果，或是某个特定智能合约的字节码提供密码学证明，都会变得更加廉价且容易。

### 比特币中的默克尔树 (Merkle trees in Bitcoin)

比特币开创了在区块链技术中使用默克尔树的先河。事实上，每一个比特币区块都包含了该区块内所有交易的默克尔根（Merkle root），因此，任何一笔交易都无法被修改，否则将导致整个区块头发生变化（这也会破坏该区块的工作量证明 PoW 结果）。

### 以太坊中的默克尔-帕特里夏树 (Merkle-Patricia Trie in Ethereum)

以太坊沿用了同样的理念并将其应用于自身，但针对其特定需求进行了一些修改。默克尔树（Merkle Trees）非常适合处理永不改变的永久性数据，例如比特币的交易记录。然而，以太坊的“状态”是在不断变化的，因此我们需要对默克尔树进行调整，使其在允许频繁更改底层数据的同时，依然能保持其原有的实用特性。

这就是**默克尔-帕特里夏树**（Merkle-Patricia Trie，简称 MPT）登场的时刻。这个名字结合了默克尔树、Patricia（一种高效检索字母数字编码信息的算法）以及 trie（源自检索“retrieval”一词，提醒我们这种结构的优化目标）三个概念。

本质上，MPT 是经过改良的默克尔树，每个节点拥有 16 个子节点。它们非常适合处理像以太坊状态这样拥有大量“键值对（Key-Value）”项的数据（其中“键”是地址，“值”是对应地址的账户信息，如余额、Nonce 以及可能存在的代码）。这是因为键（Key）本身就被编码在通往树中正确位置所必须遵循的路径里。

假设我们要存储以下键值项： 
```
car → Schumacher
```
“car”的十六进制编码为 `0x636172`。因此，你需要从默克尔根节点开始，先选择第 6 个子节点，接着向下选择第 3 个子节点，重复这一过程，直到到达最终位置，在那里你可以读取到与该键相关联的值——在本例中就是“Schumacher”，如图 14-5 所示。

![Figure 14-5](<./images/figure 14-5.png>)

图 14-5. 键值项 car → Schumacher 在默克尔-帕特里夏树中的编码方式

具体而言，以太坊使用了四种默克尔-帕特里夏树（MPT）：

**状态树 (State Trie)**

用于存储以太坊的全部全局状态。

**交易树 (Transaction Trie)**

用于存储区块中包含的所有交易。

**收据树 (Receipt Trie)**

用于存储该区块内所有交易的执行结果（收据）。

**存储树 (Storage Trie)**

用于存储智能合约的内部数据。

每个以太坊区块头 (Block Header) 都包含了状态树、交易树和收据树的默克尔根；而每个账户 (Account)（包含在状态树中）则存储着它自己专属的存储树默克尔根。


## 深入解析 EVM 组件 (A Deep Dive into the Components of the EVM)
在本节中，我们将详细探讨 EVM 每个组件的工作原理。最后，我们将通过一个真实案例来观察各组件是如何协同工作的。

### 栈 (Stack)

栈是一个非常简单的数据结构，遵循后进先出 (LIFO) 的原则来执行操作。在栈中，每个项都是一个 32 字节 的对象。它最多可以同时存放 1,024 个 项。

EVM 可以通过各种操作码将项“推入 (Push)”或“弹出 (Pop)”栈空间，并能灵活调整其内部元素的顺序，如图 14-6 所示。

![Figure 14-6](<./images/figure 14-6.png>)

图 14-6. 遵循后进先出 (LIFO) 操作顺序的 EVM 栈

### 内存 (Memory)
EVM 内存是一个按字节寻址 (Byte-addressable) 的数据结构：本质上是一个非常长的字节数组。实际上，内存中的每一个字节都可以使用一个 32 字节（256 位）的键（索引）来访问，这意味着它的理论容量上限可达 $2^{256}$ 字节。内存是易失性 (Volatile) 的——也就是说，它在执行结束后会被删除——并且在初始状态下总是被置为 0。虽然可以从内存中读取或向其中写入单个字节，但大多数操作通常涉及读取或写入更大的数据块，通常是 32 字节 的块，如图 14-7 所示。

![Figure 14-7](<./images/figure 14-7.png>)

> [!Note]
> 从技术角度讲，你无法从 EVM 内存中直接读取单个字节。你只能读取一整个 32 字节的“字”（Word）。为了达到读取单个字节的效果，EVM 需要先加载包含该字节的整个字，然后通过位运算对其进行“裁剪”，从而仅返回所选的那个字节。

### 存储 (Storage)

EVM 存储是一个键值对（Key-Value）数据结构，其中的键（通常称为插槽 Slots）和值均为 32 字节长。这是每个智能合约的持久化内存：所有保存在其中的数值都会在不同的交易和区块之间无限期保留。每个智能合约只能访问和修改属于自己的存储空间。如果你尝试访问一个尚未存入任何数值的插槽，它将始终返回 0 而不会抛出任何错误。图 14-8 展示了两个合约存储结构的简化示意图。
![Figure 14-8](<./images/figure 14-8.png>)

图 14-8. EVM 存储是一种具有键值对结构的永久性内存

此外，还有通过 EIP-1153 引入的瞬态存储 (Transient Storage)。它的行为方式与普通存储完全一致，唯一的区别在于它会在交易执行结束后被彻底丢弃。正因如此，它的使用成本比普通存储要廉价得多。

### 调用数据 (Calldata)

调用数据是一个不可变（Immutable）的数据结构，它始终包含作为输入发送至下一个调用帧 (Call Frame)（即沙盒化的 EVM 环境）的字节。例如，在创建合约的交易中，calldata 包含即将部署的合约字节码。它也可以是空的，比如在简单的 ETH 转账交易中。

## 让我们通过一个具体案例来整合所有知识
你正在执行一笔作用于合约 A 的交易，并且拥有以下 EVM 字节码：`60425F525F3560AB145F515500`。

同时，你还拥有如下初始调用数据（Calldata）：
```
00000000000000000000000000000000000000000000000000000000000000ab
```
让我们以人类可读的格式来表示这段 EVM 字节码：
```
[00]            PUSH1            42
[02]            PUSH0
[03]            MSTORE
[04]            PUSH0
[05]            CALLDATALOAD
[06]            PUSH1            AB
[08]            EQ
[09]            PUSH0
[0a]            MLOAD
[0b]            SSTORE
[0c]            STOP
```

> [!Note]
> 每个 EVM 操作码（Opcode）都由一个唯一的 1 字节数值标识（范围从 0x00 到 0xFF）。例如，0x60 是 PUSH1 操作码，0x5F 是 PUSH0，依此类推。如需查看所有操作码及其十六进制表示的完整列表，请参考 [EVM Codes 网站](https://www.evm.codes/)。

让我们看看 EVM 如何执行这些操作码，以及它是如何操纵栈、内存和存储的。图 14-9 展示了 EVM 的初始状态。

![Figure 14-9](<./images/figure 14-9.png>)

图 14-9. EVM 初始状态

第一个操作码将 0x42 推入栈中（图 14-10）。请注意，所有的 PUSH 操作码都会从字节码中紧随其后的可用字节里提取（待推入的）数据。

![Figure 14-10](<./images/figure 14-10.png>)

图 14-10. 执行 PUSH1 0x42 后的 EVM

接着，PUSH0 将 `0x00` 推入栈中（图 14-11）。

![Figure 14-11](<./images/figure 14-11.png>)

图 14-11. 执行 PUSH0 后的 EVM

MSTORE 从栈中弹出两个项，将第一个项解释为偏移量（以字节为单位），第二个项解释为要写入内存的值，并从该偏移量开始写入。请注意，在内存中的字节 0x42 之前有很多前导零（31 个字节为零）。这是正确的，因为栈中的每个值都是 32 字节 的。大多数时候，我们在书写时可以忽略前导零（在图 14-12 中，你可以看到项 0x42），但你应该始终记住它们是 32 字节的值。

![Figure 14-12](<./images/figure 14-12.png>)

图 14-12. 执行 MSTORE 后的 EVM

随后，再次执行 PUSH0，将 0x00 推入栈中（图 14-13）。

![Figure 14-13](<./images/figure 14-13.png>)

图 14-13. 执行 PUSH0 后的 EVM

CALLDATALOAD 从栈中取出一个元素作为偏移量，返回调用数据（Calldata）中从该偏移量开始的 32 字节 数值，并将其推入栈中。在本例中，它返回了 0xab（注意，我们可以忽略所有不具实际意义的前导零），如图 14-14 所示。

![Figure 14-14](<./images/figure 14-14.png>)

图 14-14. 执行 CALLDATALOAD 后的 EVM

PUSH1 将 0xab 推入栈中（图 14-15）。

![Figure 14-15](<./images/figure 14-15.png>)

图 14-15. 执行 PUSH1 0xab 后的 EVM

EQ 从栈中弹出两个项并进行比较：如果相等则返回 1，否则返回 0。在此示例中，由于两个数值相等，它返回了 0x01，如图 14-16 所示。

![Figure 14-16](<./images/figure 14-16.png>)

图 14-16. 执行 EQ 后的 EVM

再次执行 PUSH0，将 0x00 推入栈中（图 14-17）。

![Figure 14-17](<./images/figure 14-17.png>)

图 14-17. 执行 PUSH0 后的 EVM

MLOAD 从栈中取出一个元素作为偏移量，读取内存中从该偏移量开始的 32 字节数据，然后将结果推入栈中（图 14-18）。

![Figure 14-18](<./images/figure 14-18.png>)

图 14-18. 执行 MLOAD 后的 EVM

现在，SSTORE 从栈中弹出两个项，将第一个项解释为插槽 (Slot)，第二个项解释为要存入该合约存储（对应插槽编号）的数值，如图 14-19 所示。

![Figure 14-19](<./images/figure 14-19.png>)

图 14-19. 执行 SSTORE 后的 EVM

最后，执行 STOP 操作码使执行挂起，EVM 成功返回，如图 14-20 所示。

![Figure 14-20](<./images/figure 14-20.png>)

图 14-20. 执行 STOP 后的 EVM

> [!Tip]
> 在前面的示例中，我们使用了操作码 PUSH0。需要注意的是，并非所有兼容 EVM 的区块链都集成了这个操作码，因此在部署跨链合约时请务必留意。[EVM Diff](https://www.evmdiff.com/) 是一个非常酷的网站，展示了各大兼容 EVM 的链之间所有这些微妙的差异。

## Compiling Solidity to EVM Bytecode
