密码学发展历程
非对称加密的发展，椭圆曲线加密，哈希加密，未来的0知识证明和全同态加密

在 20 世纪 70 年代首次发表的密钥交换协议（Key exchange protocol）是一项划时代的突破，它引发了公众对密码学领域的第一次大规模关注。在 20 世纪 70 年代之前，强大的密码学知识一直被政府视为最高机密。
密码学中一类更有用的高级数学函数是基于椭圆曲线（Elliptic Curve）的算术运算。在椭圆曲线算术中，模素数乘法（Multiplication modulo a prime）很简单，但其逆运算——除法——在实际操作中几乎是不可能的。
这被称为离散对数问题（Discrete logarithm problem），且目前尚无已知的“陷门”。椭圆曲线密码学（ECC）广泛应用于现代计算机系统，也是以太坊（以及其他加密货币）使用私钥和数字签名的基础。

## 椭圆曲线
在数学理论中，椭圆曲线是作用在实数域上的曲线，但是对于计算机处理并不方便，因此在密码学中，将其定义到有限域中，形成一系列孤立的点阵，关于y=p/2对称，p为模。
椭圆曲线的加法虽然在理论上得到第三个点后需要关于x轴做镜像，但是在密码学中是关于y=p/2做镜像，当然代数运算是一致的。`(x, y) -> (x, -y(mod p))`

### 实数域的椭圆曲线
从直观上看，两个点构成的直线会和曲线有交点，但是一定会有交点吗？会有第二个交点吗？这个可以从代数层面给出解释（涉及到初等数学知识）。
椭圆曲线的方程式3次方程`y^2 = x^3 + ax + b`，假设直线的方程式y=mx+c，则有 
```
x^3 -m^2*x^2 + (a -2mc)x + (b - c^2) = 0
```
一个三次方程在复数域内一定有且仅有 3 个根（考虑重根的情况下）。
已知有两个交点，说明存在实数x1和x2作为解。根据韦达定理：形如`x^3 + Bx^2 + Cx + D = 0`的方程，根的和满足：
```
x1 + x2 + x3 = -B
```
考虑到上面的直线方程，有`x1 + x2 + x3 = m^2`，因此，只要x1和x2是已知的实数，则`x3 = m^2 - x1 -x2`是一个确定的实数。考虑特殊情况，m直线没有斜率，那么引入无穷远点作为第三个点。 
虽然使用初等数学的内容可以很好的解释，但其实这套椭圆曲线的计算逻辑就是为了构建一个阿贝尔群而设计的。KZG 用到的双线性配对，本质上是在两个不同的阿贝尔群之间建立的一种特殊映射。这部分属于高等数学内容，在此不做过多的解释。

### 有限域的椭圆曲线
清楚实数域的椭圆曲线后，再来看下有限域的椭圆曲线就好理解了。在密码学中，我们不是先在实数曲线上找一个点然后再“强行”取模，而是从一开始就定义整个坐标系只有整数，且所有算术规则都在模p下运行。
只有当 (x, y)是整数且满足 `y^2 = x^3 + ax + b (mod p)` 时，我们才说这个点在“加密意义”的曲线上。
```
举个例子：假设曲线 y^2 = x^3 + 7 (mod 11), 如果 x=2，计算 x^3 + 7 = 15, 15 mod 11 = 4。显然 y=2 是一个解，所以点 (2, 2) 在曲线上。同时 y = 11 - 2 = 9 也是一个解，因为 9^2 = 81 = 4 (mod 11)。
所以点 (2, 9)也在曲线上（这就是关于 y=p/2 对称）。
```
在有限域中没有小数，为了让除法有意义，使用逆模元（类似矩阵的除法）。在模p有限域中，数字a的逆模元记作a^-1, 满足 `a·a^-1 = 1 (mod p)`
```
假设 p = 7，要计算 2 的模逆元（即 1 / 2），我们找一个数 x，使得 2x = 1 (mod 7)。试一下发现 2 * 4 = 8。8 / 7 余数是 1。所以，在模 7 的世界里，2的逆元是 4。在这里，1 / 2 = 4。
```
实际上计算逆模元的常见方法是**费马小定理(Fermat's Little Theorem)**：如果 p 是一个质数，那么对于任何不被 p 整除的整数 a，都有：
```
a^(p-1) = 1 (mod p)
```
推导出：
```
a^(p-2) * a = 1 (mod p) => a^-1 = a^(p-2) (mod p)
```
和上面的猜测结果一致，于是求逆元变成了求幂运算。但是求逆元（模幂运算）的开销非常大，大约是普通乘法的 200-300 倍。这就是为什么高性能加密库会使用 雅可比坐标（Jacobian Coordinates）——它通过引入一个额外的Z维度，
把加法公式中的所有除法都推迟到最后一步才计算。整套复杂的 KZG 证明生成过程中，可能只需要做一次求逆，极大地提升了速度。此外在计算过程中需要考虑安全性，计算逆元时必须使用恒定时间算法。如果使用基础的递归欧几里得算法，
执行时间会随数值变化，从而通过“时间侧信道”泄露你的私钥。

## 密码学哈希函数
密码学哈希函数是一种单向哈希函数（One-way hash function），它将任意大小的数据映射为固定长度的位字符串。其“单向”性质意味着，如果只知道输出哈希值，在计算上是不可能重新创建输入数据的。
使用公钥进行哈希运算，得到地址，而不是直接使用公钥作为地址，相当把地址和公钥解耦，既增加了随机性，消除了数学关联，又没有将以太坊绑定到特定椭圆曲线上，如果以后发现了安全漏洞可以换一种算法。

## 椭圆曲线数字签名算法 (ECDSA)

**ECDSA**（Elliptic Curve Digital Signature Algorithm）是区块链（如比特币、以太坊）实现身份验证的核心方案。其核心目标是：**允许持有者通过消息哈希和签名证明其拥有私钥，而无需暴露私钥。**

### 1. 核心参数预设
* **曲线参数**：基点 $G$，群的阶 $n$（满足 $[n]G = \mathcal{O}$， 即`0 = n * G`）。
* **用户密钥**：私钥 $d$（一个随机大整数），公钥 $Q = [d]G$（曲线上的点）。
* **待签消息**：消息的哈希值 $z$。
在有限阿贝尔群中，比如以太坊使用的椭圆曲线，任何一点G都存在对应满足条件的n。但是密码学中的G需要精心挑选，对应的n需要是一个巨大的质数。

在以太坊中，数字签名由三个分量组成：**$r$**, **$s$**, 和 **$v$**。其中 $v$ 被称为 **恢复标识符（Recovery ID）**。
在标准的 ECDSA 验证中，验证者必须已知**公钥 $Q$** 才能验证签名。但在以太坊中：
1. 为了节省链上存储，交易数据里不包含 64 字节的长公钥。
2. 仅凭 $r$ 值（它只是随机点 $R$ 的 $x$ 坐标），在曲线上会对应两个可能的 $y$ 坐标（正负对称）。
3. 因此，仅靠 $(r, s)$ 会推导出两个可能的公钥。**$v$ 的作用就是指明哪一个是正确的公钥。**

### 2. 签名生成流程 (Signing)
要对消息 $z$ 进行签名，发送方执行以下步骤：

1.  **选取随机数**：生成一个临时的随机整数 $k \in [1, n-1]$（称为 **Nonce**）。
2.  **计算随机点**：计算曲线上的点 $R = [k]G$。
3.  **计算 $r$**：取 $R$ 点的 $x$ 坐标对 $n$ 取模，即 $r = x_R \pmod n$。（若 $r=0$ 则返回第一步）。
4.  **计算 $s$**：利用**模逆元**计算：
    $$s = k^{-1} (z + r \cdot d) \pmod n$$
    （若 $s=0$ 则返回第一步）。
5.  **计算 $v$**：
    - 观察点 $R$ 的 $y$ 坐标。
    - 如果 $y$ 是偶数，v = 27（或 EIP-155 后的新标准）。
    - 如果 $y$ 是奇数，v = 28。
    - *注：在现代以太坊中，v 还会包含 `ChainID` 以防止跨链重放攻击。*
6.  **输出结果**：最终签名结果为 **$(r, s, v)$**。


### 3. 签名验证流程 (Verification)
验证者持有消息哈希 $z$、公钥 $Q$ 以及签名 $(r, s)$，执行以下验证：

1.  **有效性检查**：确认 $r, s \in [1, n-1]$。
2.  **计算中间值**：
    * $w = s^{-1} \pmod n$
    * $u_1 = z \cdot w \pmod n$
    * $u_2 = r \cdot w \pmod n$
3.  **恢复点 $R'$**：进行点运算：
    $$R' = [u_1]G + [u_2]Q$$
4.  **判定**：检查 $R'$ 点的 $x$ 坐标是否满足 $x_{R'} \equiv r \pmod n$。若相等，则签名有效。

### 4. 以太坊的验证与恢复流程 (The `ecrecover` Logic)
以太坊验证者收到交易后，会调用底层内核函数（如 Solidity 中的 `ecrecover`）：

1. **输入**：消息哈希 $z$ 和签名 $(r, s, v)$。
2. **确定点 $R$**：
   - 利用 $r$ 还原出 $x$ 坐标， $x = r$。
   - 利用 $v$ 的奇偶性，在 $y^2 = x^3 + 7$ 中锁定唯一的 $y$ 坐标。
   - 从而完整还原出签名时的随机点 $R$。
3. **推导公钥 $Q$**：
   - 根据公式推导：
    $$Q = r^{-1}(s \cdot R - z \cdot G)$$。
4. **计算地址**：
   - 将推导出的 $Q$ 进行 `Keccak256` 哈希。
   - 取最后 20 字节得到地址。
5. **判定**：如果该地址与交易发送方 `from` 地址一致，且余额充足，则验证通过。

### 5. 数学证明（验证为何有效）
根据定义推导：

$$R' = [u_1]G + [u_2]Q = [zw]G + [rw]Q$$
代入 $Q = [d]G$ 和 $w = s^{-1}$：
$$R' = [zs^{-1}]G + [rds^{-1}]G = [(z + rd)s^{-1}]G$$
根据签名公式 $s = k^{-1}(z + rd)$，可得 $s^{-1} = k(z + rd)^{-1}$。
代入后：
$$R' = [(z + rd) \cdot k(z + rd)^{-1}]G = [k]G$$
由此可见， `R'` 确实等于签名生成时的点 `R`，因此它们的 x 坐标必然一致。



### 6. 开发安全注意事项

#### 警告：严禁重复使用随机数 $k$（Nonce Reuse Attack）

假设攻击者发现你用同一个 $k$ 对两笔不同的交易（哈希分别为 $z_1$ 和 $z_2$）进行了签名，得到了两个签名 $(r, s_1)$ 和 $(r, s_2)$。由于 $k$ 相同，它们的 $r$ 值（即 $[k]G$ 的 $x$ 坐标）必然完全一致。

#### 数学推导过程：
攻击者只需执行简单的减法运算：
$$s_1 - s_2 = k^{-1}(z_1 + r \cdot d) - k^{-1}(z_2 + r \cdot d) \pmod n$$
$$s_1 - s_2 = k^{-1}(z_1 - z_2) \pmod n$$

由此，攻击者可以轻易算出 $k$：
$$k = (z_1 - z_2)(s_1 - s_2)^{-1} \pmod n$$

#### 最终后果：
一旦获取了 $k$，私钥 $d$ 将立刻暴露：
$$d = (s \cdot k - z) \cdot r^{-1} \pmod n$$

这就是著名的 **Sony PS3 破解事件** 和早期比特币钱包被盗的根本原因。程序员为了省事使用了固定值或可预测的 $k$，导致价值数亿美元的私钥在瞬间被通过简单的代数运算解出。
**确定性签名 (RFC 6979)**：现代实现通常通过 $HMAC(d, z)$ 生成确定性的 $k$，规避随机数碰撞风险。

## BLS签名

### 配对
椭圆曲线的一个特性：配对 似乎对点乘很有效果
如果e是一个椭圆曲线双线性配对函数，k是一个数字，m是一个数字，H(m)是m映射的点，G是另一个群中的点，那么
$$e(k * G, H(m)) = e(G, H(m))^k = e(G, k * H(m))$$


### 签名聚合（Signature aggregation）

$$σagg = σ1 + σ2 + σ3 + … + σn$$
$$pkagg = pk1 + pk2 + pk3 + … + pkn$$
聚合签名验证:
$$e(pkagg,H(m)) =$$
$$= e(pk1 + pk2 + pk3 + ... + pkn,H(M))$$
$$= e((sk1 + sk2 + sk3 + ... + skn) * g1,H(m))$$
$$= e(g1,H(m))^(sk1 + sk2 + sk3 + ... + skn)$$
$$= e(g1,(sk1 + sk2 + sk3 + ... + skn) * H(m))$$
$$= e(g1,σ1 + σ2 + σ3 + ... + σn)$$
$$= e(g1,σagg)$$


## 罚没

# 以太坊罚没逻辑：从 BLS 罪证到 ECDSA 资产扣除

在以太坊中，验证者的违规行为通过 **BLS 签名**被捕获，而最终的经济惩罚则作用于其 **ECDSA 地址**关联的质押金。

---

### 1. 捕获“犯罪证据” (Evidence Collection)
当验证者试图进行“双重投票”（对同一个高度的两个不同区块投票）时：
* **双重签名**：验证者针对区块 A 产生一个 BLS 签名 $S_A$，针对区块 B 产生另一个 BLS 签名 $S_B$。
* **可证明性**：由于 BLS 签名对消息（区块哈希）是唯一的，任何人只要把这两个签名及其对应的区块头放在一起，就构成了一个不可抵赖的“罪证包”（Proving a Slashable Offense）。

---

### 2. 验证者索引与资金绑定
在以太坊中，每个验证者在进入质押池时，都关联了两个关键信息：
1. **Validator Pubkey (BLS)**：用于日常投票、签署区块。
2. **Withdrawal Credentials (ECDSA 派生)**：这是一个 32 字节的凭证，通常指向一个以太坊地址（通过 ECDSA 公钥哈希生成）。



---

### 3. 罚没执行流程 (The Slashing Flow)

一旦证据被提交并验证成功，系统会启动以下链式反应：

#### 第一步：立刻冻结 (Immediate Penalty)
验证者在共识层（Beacon Chain）的状态立刻变为 `Slashed`。系统会首先从其账户中扣除一部分固定罚金（目前约为 1 ETH）。

#### 第二步：全网广播与相关性惩罚 (Correlated Penalty)
系统会观察在同一段时间内有多少验证者同时违规：
* 如果只有你一个人违规，可能只是配置错误，罚金较少。
* 如果有大量验证者同时违规（暗示协同攻击），罚金会呈指数级上升，甚至扣除全部 **32 ETH**。

#### 第三步：资金结算 (Settlement to ECDSA)
罚没发生 36 天后（为了确保安全期），剩余的资金会被强制退出。
1. **状态更新**：共识层计算剩余金额。
2. **执行层提款**：系统通过 `Withdrawal Credentials` 找到该验证者绑定的 **以太坊地址**。
3. **资金转移**：剩余的 ETH 会以“提款”的形式发送到该地址。由于该地址是由用户的 **ECDSA 私钥**控制的，此时用户的亏损已成定局。

---

### 4. 核心逻辑对照表

| 环节 | 使用的签名/曲线 | 作用 |
| :--- | :--- | :--- |
| **违规行为** | **BLS** (secp256k1 不参与) | 验证者在共识层签发了相互矛盾的投票。 |
| **证据提交** | **BLS 聚合验证** | 协议通过双线性配对验证这两个签名确实出自该验证者。 |
| **资产绑定** | **Withdrawal Credentials** | 建立 BLS 验证者身份与 ECDSA 钱包地址的“契约”关系。 |
| **最终惩罚** | **ECDSA 地址余额减少** | 用户在主网（执行层）可见的资产发生实质性缩水。 |

---

### 总结
**BLS 是捕获犯罪行为的“指纹”，而 ECDSA 地址则是执行罚没扣款的“银行账户”。** 没有 BLS 的聚合特性，共识层无法高效发现违规；没有 ECDSA 的地址绑定，罚没行为就无法触及攻击者的核心资产。

### 以太坊双签罚没 (Double Signing Slashing) 全流程解析

在以太坊共识层中，**双签**是最容易被自动捕获且无法申辩的违规行为。它发生的物理本质是：**同一个 BLS 私钥在同一个高度（Slot）为两个不同的区块进行了签名。**

---

### 1. 为什么“双签”在数学上无法抵赖？
由于 BLS 签名的确定性，对于同一个消息（Block Root），同一个私钥生成的签名是唯一的。
* **合法行为**：验证者在 Slot $N$ 签署区块 $A$。
* **双签行为**：验证者在 Slot $N$ 同时签署了区块 $A$ 和区块 $B$。
这两个签名被打包发送到网络后，任何人只要把这两份数据（包含对应的 BLS 签名）提交给协议，**数学上就能证明你同时支持了两条分叉**。

---

### 2. 核心链路：从 BLS 签名到 ECDSA 余额扣除

| 阶段 | 动作 | 技术原理 |
| :--- | :--- | :--- |
| **违规发生** | 验证者发出两个冲突签名 | 使用 **BLS 密钥** 签署。 |
| **证据捕获** | “哨兵”（Slashing Detector）发现冲突 | 监听网络数据，对比同一个验证者索引在同高度的输出。 |
| **提交证明** | 哨兵向区块提议者提交证据 | 证据包包含：(验证者索引, 区块A签名, 区块B签名)。 |
| **全网验证** | 协议通过双线性配对验证签名 | 调用 `Pairing` 函数证明两个签名均出自该验证者的 **BLS 公钥**。 |
| **账户降级** | 验证者状态变为 `Slashed` | 共识层状态机强制修改该验证者状态。 |
| **结算退出** | 资金流回 **ECDSA 地址** | 罚款结算后的余额，通过 `Withdrawal Credentials` 转入用户的 **secp256k1 钱包**。 |

---

### 3. 后端运维最常见的“死法”
绝大多数罚没不是因为黑客攻击，而是因为**运维失误**：
1. **冗余灾备错误**：运维为了高可用，在两台服务器（A机和B机）上同时跑了同一个验证者私钥。如果 A 机网络卡顿，B 机以为 A 挂了开始签名，随后 A 又发出了签名，**双签达成，32 ETH 开始蒸发**。
2. **迁移容器未清理**：在 K8s 环境下迁移验证者节点，旧的 Pod 没完全销毁，新的 Pod 已经启动并开始签名。

---

### 4. 关键绑定：为什么能罚到你的 ECDSA 钱包？
在验证者初始化（Deposit）时，会签署一份合约，将两套身份死死绑定：
* **BLS 公钥** $\leftrightarrow$ **Withdrawal Credentials** (由用户的 **ECDSA 公钥哈希** 生成)
这种绑定是写在 Beacon Chain 状态里的硬约束。无论你在共识层怎么违规，系统最终结算时，都会通过这个凭证找到你在执行层的“银行账户”（ECDSA 地址）进行扣款。
